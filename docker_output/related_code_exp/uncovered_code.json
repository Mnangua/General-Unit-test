[
  {
    "file_path": "directory_bootstrap/__main__.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\nimport signal\nimport sys\n\nimport directory_bootstrap.shared.loaders._argparse as argparse\nfrom directory_bootstrap.distros.alpine import AlpineBootstrapper\nfrom directory_bootstrap.distros.arch import ArchBootstrapper\nfrom directory_bootstrap.distros.base import (\n        BOOTSTRAPPER_CLASS_FIELD, add_general_directory_bootstrapping_options)\nfrom directory_bootstrap.distros.gentoo import GentooBootstrapper\nfrom directory_bootstrap.distros.void import VoidBootstrapper\nfrom directory_bootstrap.shared.executor import Executor, sanitize_path\nfrom directory_bootstrap.shared.messenger import (VERBOSITY_VERBOSE, Messenger,\n                                                  fix_output_encoding)\nfrom directory_bootstrap.shared.metadata import VERSION_STR\nfrom directory_bootstrap.shared.output_control import (\n        add_output_control_options, is_color_wanted, run_handle_errors)\n\n\ndef _main__level_three(messenger, options):\n    stdout_wanted = options.verbosity is VERBOSITY_VERBOSE\n\n    if stdout_wanted:\n        child_process_stdout = None\n    else:\n        child_process_stdout = open('/dev/null', 'w')\n\n    sanitize_path()\n\n    executor = Executor(messenger, stdout=child_process_stdout)\n\n\n    bootstrapper_class = getattr(options, BOOTSTRAPPER_CLASS_FIELD)\n    bootstrap = bootstrapper_class.create(messenger, executor, options)\n\n    bootstrap.check_for_commands()\n    if bootstrap.wants_to_be_unshared():\n        bootstrap.unshare()\n    bootstrap.run()\n\n\n    if not stdout_wanted:\n        child_process_stdout.close()\n\n\ndef _main__level_two():\n    parser = argparse.ArgumentParser(prog='directory-bootstrap')\n    parser.add_argument('--version', action='version', version=VERSION_STR)\n\n    add_output_control_options(parser)\n\n    general = parser.add_argument_group('general configuration')\n    add_general_directory_bootstrapping_options(general)\n\n    system = parser.add_argument_group('system configuration')\n    system.add_argument('--resolv-conf', metavar='FILE', default='/etc/resolv.conf',\n        help='file to copy nameserver entries from (default: %(default)s)')\n\n    distros = parser.add_subparsers(title='subcommands (choice of distribution)',\n            description='Run \"%(prog)s DISTRIBUTION --help\" for details '\n                    'on options specific to that distribution.',\n            metavar='DISTRIBUTION', help='choice of distribution, pick from:')\n\n\n    for strategy_clazz in (\n            AlpineBootstrapper,\n            ArchBootstrapper,\n            GentooBootstrapper,\n            VoidBootstrapper,\n            ):\n        strategy_clazz.add_parser_to(distros)\n\n\n    parser.add_argument('target_dir', metavar='DIRECTORY')\n\n    options = parser.parse_args()\n\n\n    messenger = Messenger(options.verbosity, is_color_wanted(options))\n    run_handle_errors(_main__level_three, messenger, options)\n\n\ndef main():\n    try:\n        fix_output_encoding()\n        _main__level_two()\n    except KeyboardInterrupt:\n        sys.exit(128 + signal.SIGINT)\n\n\nif __name__ == '__main__':\n    main()\n",
    "uncovered_lines": [
      4,
      5,
      7,
      8,
      9,
      10,
      12,
      13,
      14,
      15,
      17,
      18,
      22,
      23,
      25,
      26,
      28,
      30,
      32,
      35,
      36,
      38,
      39,
      40,
      41,
      44,
      45,
      48,
      49,
      50,
      52,
      54,
      55,
      57,
      58,
      61,
      67,
      73,
      76,
      78,
      81,
      82,
      85,
      86,
      87,
      88,
      89,
      90,
      93,
      94
    ]
  },
  {
    "file_path": "directory_bootstrap/distros/alpine.py",
    "code": "import importlib.resources\nimport os\nimport re\nimport shutil\nimport tempfile\nfrom tarfile import TarFile\n\nimport directory_bootstrap.resources.alpine as resources\nfrom directory_bootstrap.distros.base import DirectoryBootstrapper\nfrom directory_bootstrap.shared.commands import COMMAND_GPG, COMMAND_UNSHARE\n\n\nSUPPORTED_ARCHITECTURES = ('i686', 'x86_64')\n\n\nclass AlpineBootstrapper(DirectoryBootstrapper):\n    DISTRO_KEY = 'alpine'\n    DISTRO_NAME_LONG = 'Alpine Linux'\n\n    __version_extractor = re.compile(\n        'Current Alpine Version <strong>(?P<version>[0-9][^<]+)</strong>')\n\n    class VersionException(Exception):\n        pass\n\n    def __init__(self, messenger, executor, abs_target_dir, abs_cache_dir,\n                architecture,\n                abs_resolv_conf):\n        super(AlpineBootstrapper, self).__init__(\n                messenger,\n                executor,\n                abs_target_dir,\n                abs_cache_dir,\n                )\n        self._architecture = architecture\n        self._abs_resolv_conf = abs_resolv_conf\n\n    def wants_to_be_unshared(self):\n        return True\n\n    @staticmethod\n    def get_commands_to_check_for():\n        return DirectoryBootstrapper.get_commands_to_check_for() + [\n                COMMAND_GPG,\n                COMMAND_UNSHARE,\n                ]\n\n    def _determine_latest_version(self):\n        downloads_page_html = self.get_url_content('https://alpinelinux.org/downloads/')\n\n        match = self.__version_extractor.search(downloads_page_html)\n        if match is None:\n            raise VersionException('Could not determine latest release version.')\n\n        return match.group('version')\n\n    @staticmethod\n    def _parse_version(version_str):\n        version_tuple = version_str.split('.')\n        if len(version_tuple) < 3:\n            raise VersionException('Version \"{}\" has unsupported format'.format(version_str))\n\n        return version_tuple\n\n    @staticmethod\n    def _create_tarball_download_url(version_tuple, arch):\n        return ('http://dl-cdn.alpinelinux.org/alpine/v{major}.{minor}/releases/{arch}/alpine-minirootfs-{major}.{minor}.{patch}-{arch}.tar.gz'\n                .format(major=version_tuple[0],\n                        minor=version_tuple[1],\n                        patch=version_tuple[2], arch=arch))\n\n    def _download_file(self, url):\n        basename = url.split('/')[-1]\n        abs_filename = os.path.join(self._abs_cache_dir, basename)\n        self.download_url_to_file(url, abs_filename)\n        return abs_filename\n\n    def run(self):\n        self.ensure_directories_writable()\n\n        self._messenger.info('Searching for latest release...')\n        version_str = self._determine_latest_version()\n        version_tuple = self._parse_version(version_str)\n        self._messenger.info('Found {} to be latest.'.format(version_str))\n\n        tarball_download_url = self._create_tarball_download_url(\n            version_tuple, self._architecture)\n        signature_download_url = '{}.asc'.format(tarball_download_url)\n\n        # Signature first, so we fail earlier if we do\n        abs_filename_signature = self._download_file(signature_download_url)\n        abs_filename_tarball = self._download_file(tarball_download_url)\n\n        abs_temp_dir = os.path.abspath(tempfile.mkdtemp())\n        try:\n            abs_gpg_home_dir = self._initialize_gpg_home(abs_temp_dir)\n            release_pubring_gpg = str(importlib.resources\n                                      .files(resources.__name__)\n                                      .joinpath(\"ncopa.asc\"))\n            self._import_gpg_key_file(abs_gpg_home_dir, release_pubring_gpg)\n            self._verify_file_gpg(abs_filename_tarball,\n                                  abs_filename_signature, abs_gpg_home_dir)\n\n            self._messenger.info('Extracting to \"{}\"...'.format(self._abs_target_dir))\n            with TarFile.open(abs_filename_tarball) as tf:\n                tf.extractall(path=self._abs_target_dir)\n        finally:\n            self._messenger.info('Cleaning up \"{}\"...'.format(abs_temp_dir))\n            shutil.rmtree(abs_temp_dir)\n\n    @classmethod\n    def add_arguments_to(clazz, distro):\n        distro.add_argument('--arch', dest='architecture', default='x86_64',\n                choices=SUPPORTED_ARCHITECTURES,\n                help='architecture (e.g. x86_64)')\n\n    @classmethod\n    def create(clazz, messenger, executor, options):\n        return clazz(\n                messenger,\n                executor,\n                os.path.abspath(options.target_dir),\n                os.path.abspath(options.cache_dir),\n                options.architecture,\n                os.path.abspath(options.resolv_conf),\n                )\n",
    "uncovered_lines": [
      1,
      2,
      3,
      4,
      5,
      6,
      8,
      9,
      10,
      13,
      16,
      17,
      18,
      20,
      23,
      26,
      29,
      35,
      36,
      38,
      39,
      41,
      42,
      43,
      48,
      49,
      51,
      52,
      53,
      55,
      57,
      58,
      59,
      60,
      61,
      63,
      65,
      66,
      67,
      72,
      73,
      74,
      75,
      76,
      78,
      79,
      81,
      82,
      83,
      84,
      86,
      88,
      91,
      92,
      94,
      95,
      96,
      97,
      100,
      101,
      104,
      105,
      106,
      108,
      109,
      111,
      112,
      113,
      117,
      118,
      119
    ]
  },
  {
    "file_path": "directory_bootstrap/distros/arch.py",
    "code": "# -*- coding: UTF-8 -*-\n# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport datetime\nimport os\nimport re\nimport shutil\nimport tempfile\nfrom collections import namedtuple\nfrom tarfile import TarFile\n\nfrom directory_bootstrap.distros.base import (\n        DirectoryBootstrapper, date_argparse_type)\nfrom directory_bootstrap.shared.commands import (\n        COMMAND_CHROOT, COMMAND_MOUNT, COMMAND_TAR,\n        COMMAND_UMOUNT, COMMAND_UNSHARE)\nfrom directory_bootstrap.shared.mount import try_unmounting\nfrom directory_bootstrap.shared.resolv_conf import filter_copy_resolv_conf\n\nSUPPORTED_ARCHITECTURES = ('i686', 'x86_64')\n\n_NON_DISK_MOUNT_TASKS = (\n        ('devtmpfs', ['-t', 'devtmpfs'], 'dev'),\n        ('devpts', ['-t', 'devpts'], 'dev/pts'),  # for gpgme\n        ('proc', ['-t', 'proc'], 'proc'),  # for pacstrap mountpoint detection\n        )\n\n\n_year = '([2-9][0-9]{3})'\n_month = '(0[1-9]|1[0-2])'\n_day = '(0[1-9]|[12][0-9]|3[01])'\n\n_keyring_package_date_matcher = re.compile('%s%s%s' % (_year, _month, _day))\n_image_date_matcher = re.compile('%s\\\\.%s\\\\.%s' % (_year, _month, _day))\n\n\nclass ArchBootstrapper(DirectoryBootstrapper):\n    DISTRO_KEY = 'arch'\n    DISTRO_NAME_LONG = 'Arch Linux'\n\n    def __init__(self, messenger, executor, abs_target_dir, abs_cache_dir,\n                architecture, image_date_triple_or_none, mirror_url,\n                abs_resolv_conf):\n        super(ArchBootstrapper, self).__init__(\n                messenger,\n                executor,\n                abs_target_dir,\n                abs_cache_dir,\n                )\n        self._architecture = architecture\n        self._image_date_triple_or_none = image_date_triple_or_none\n        self._mirror_url = mirror_url\n        self._abs_resolv_conf = abs_resolv_conf\n\n    def wants_to_be_unshared(self):\n        return True\n\n    @staticmethod\n    def get_commands_to_check_for():\n        return DirectoryBootstrapper.get_commands_to_check_for() + [\n                COMMAND_CHROOT,\n                COMMAND_MOUNT,\n                COMMAND_TAR,\n                COMMAND_UMOUNT,\n                ]\n\n    def _get_image_listing(self):\n        self._messenger.info('Downloading image listing...')\n        return self.get_url_content('https://mirrors.kernel.org/archlinux/iso/')\n\n    def _download_image(self, image_yyyy_mm_dd, suffix=''):\n        filename = os.path.join(self._abs_cache_dir, 'archlinux-bootstrap-%s-%s.tar.zst%s' % (image_yyyy_mm_dd, self._architecture, suffix))\n        url = 'https://mirrors.kernel.org/archlinux/iso/%s/archlinux-bootstrap-%s-%s.tar.zst%s' % (image_yyyy_mm_dd, image_yyyy_mm_dd, self._architecture, suffix)\n        self.download_url_to_file(url, filename)\n        return filename\n\n    def _extract_image(self, image_filename, abs_temp_dir):\n        abs_pacstrap_outer_root = os.path.join(abs_temp_dir, 'pacstrap_root', '')\n\n        self._messenger.info('Extracting bootstrap image to \"%s\"...' % abs_pacstrap_outer_root)\n        abs_pacstrap_inner_root = os.path.join(abs_pacstrap_outer_root, 'root.%s' % self._architecture)\n\n        os.makedirs(abs_pacstrap_outer_root)\n        self._executor.check_call([COMMAND_TAR,\n                                   'xf', image_filename,\n                                   '-C', abs_pacstrap_outer_root,\n                                   ])\n\n        return abs_pacstrap_inner_root\n\n    def _make_chroot_env(self):\n        env = os.environ.copy()\n        for key in ('LANG', 'LANGUAGE'):\n            env.pop(key, None)\n        env.update({\n                'LC_ALL': 'C',\n                })\n        return env\n\n    def _adjust_pacman_mirror_list(self, abs_pacstrap_inner_root):\n        abs_mirrorlist = os.path.join(abs_pacstrap_inner_root, 'etc/pacman.d/mirrorlist')\n        self._messenger.info('Adjusting mirror list at \"%s\"...' % abs_mirrorlist)\n        with open(abs_mirrorlist, 'a') as f:\n            print(file=f)\n            print('## Added by directory-bootstrap', file=f)\n            print('Server = %s' % self._mirror_url, file=f)\n\n    def _copy_etc_resolv_conf(self, abs_pacstrap_inner_root):\n        target = os.path.join(abs_pacstrap_inner_root, 'etc/resolv.conf')\n        filter_copy_resolv_conf(self._messenger, self._abs_resolv_conf, target)\n\n    def _initialize_pacman_keyring(self, abs_pacstrap_inner_root):\n        self._messenger.info('Initializing pacman keyring... (may take 2 to 7 minutes)')\n        before = datetime.datetime.now()\n\n        env = self._make_chroot_env()\n\n        cmd = [\n                COMMAND_UNSHARE,\n                '--fork', '--pid',  # to auto-kill started gpg-agent\n                COMMAND_CHROOT,\n                abs_pacstrap_inner_root,\n                'pacman-key',\n                '--init',\n                ]\n        self._executor.check_call(cmd, env=env)\n\n        cmd = [\n                COMMAND_UNSHARE,\n                '--fork', '--pid',  # to auto-kill started gpg-agent\n                COMMAND_CHROOT,\n                abs_pacstrap_inner_root,\n                'pacman-key',\n                '--populate', 'archlinux',\n                ]\n        self._executor.check_call(cmd, env=env)\n\n        after = datetime.datetime.now()\n        self._messenger.info('Took %d seconds.' % (after - before).total_seconds())\n\n    def _sync_archlinux_keyring(self, abs_pacstrap_inner_root):\n        # NOTE: Motivation is to evade pacman's inspection of two\n        #       non-existing mountpoints \"/var/cache/pacman/pkg/\" and \"/\"\n        self._messenger.info('Disabling CheckSpace for chroot pacman...')\n        env = self._make_chroot_env()\n        cmd = [\n                COMMAND_CHROOT,\n                abs_pacstrap_inner_root,\n                'sed',\n                '-e',\n                's/^CheckSpace/#CheckSpace/',\n                '-e',\n                's/^DownloadUser/#DownloadUser/',\n                '-i',\n                '/etc/pacman.conf',\n                ]\n        self._executor.check_call(cmd, env=env)\n\n        self._messenger.info('Syncing package archlinux-keyring...')\n        cmd = [\n                COMMAND_UNSHARE,\n                '--fork', '--pid',  # to auto-kill started gpg-agent\n                COMMAND_CHROOT,\n                abs_pacstrap_inner_root,\n                'pacman',\n                '--sync', '--refresh', '--noconfirm',\n                'archlinux-keyring',\n                ]\n        self._executor.check_call(cmd, env=env)\n\n    def _run_pacstrap(self, abs_pacstrap_inner_root, rel_pacstrap_target_dir):\n        self._messenger.info('Pacstrapping into \"%s\"...'\n                % (os.path.join(abs_pacstrap_inner_root, rel_pacstrap_target_dir)))\n        env = self._make_chroot_env()\n        cmd = [\n                COMMAND_CHROOT,\n                abs_pacstrap_inner_root,\n                'pacstrap',\n                os.path.join('/', rel_pacstrap_target_dir),\n                ]\n        self._executor.check_call(cmd, env=env)\n\n    def _fix_root_login_at(self, abs_chroot_dir):\n        abs_chroot_etc_shadown = os.path.join(abs_chroot_dir, 'etc', 'shadow')\n        self._messenger.info('Securing root account at \"%s\"...' % abs_chroot_etc_shadown)\n        env = self._make_chroot_env()\n        cmd = [\n            COMMAND_CHROOT,\n            abs_chroot_dir,\n            'usermod', '-p', '*', 'root',\n        ]\n        self._executor.check_call(cmd, env=env)\n\n    def _mount_disk_chroot_mounts(self, abs_pacstrap_target_dir):\n        self._executor.check_call([\n                COMMAND_MOUNT,\n                '-o', 'bind',\n                self._abs_target_dir,\n                abs_pacstrap_target_dir,\n                ])\n\n    def _mount_nondisk_chroot_mounts(self, abs_pacstrap_inner_root):\n        self._messenger.info('Mounting non-disk file systems...')\n        for source, options, target in _NON_DISK_MOUNT_TASKS:\n            self._executor.check_call([\n                    COMMAND_MOUNT,\n                    source,\n                    ] \\\n                    + options \\\n                    + [\n                        os.path.join(abs_pacstrap_inner_root, target),\n                    ])\n\n    def _unmount_disk_chroot_mounts(self, abs_pacstrap_target_dir):\n        try_unmounting(self._executor, abs_pacstrap_target_dir)\n\n    def _unmount_nondisk_chroot_mounts(self, abs_pacstrap_inner_root):\n        self._messenger.info('Unmounting non-disk file systems...')\n        for source, options, target in reversed(_NON_DISK_MOUNT_TASKS):\n            abs_path = os.path.join(abs_pacstrap_inner_root, target)\n            try_unmounting(self._executor, abs_path)\n\n    def run(self):\n        self.ensure_directories_writable()\n\n        abs_temp_dir = os.path.abspath(tempfile.mkdtemp())\n        try:\n            if self._image_date_triple_or_none is None:\n                image_listing_html = self._get_image_listing()\n                image_yyyy_mm_dd = self.extract_latest_date(image_listing_html, _image_date_matcher)\n            else:\n                image_yyyy_mm_dd = '%04s.%02d.%02d' % self._image_date_triple_or_none\n\n            image_filename = self._download_image(image_yyyy_mm_dd)\n\n            abs_pacstrap_inner_root = self._extract_image(image_filename, abs_temp_dir)\n            self._adjust_pacman_mirror_list(abs_pacstrap_inner_root)\n            self._copy_etc_resolv_conf(abs_pacstrap_inner_root)\n\n\n            rel_pacstrap_target_dir = os.path.join('mnt', 'arch_root', '')\n            abs_pacstrap_target_dir = os.path.join(abs_pacstrap_inner_root, rel_pacstrap_target_dir)\n\n            os.makedirs(abs_pacstrap_target_dir)\n\n            self._mount_disk_chroot_mounts(abs_pacstrap_target_dir)\n            try:\n                self._mount_nondisk_chroot_mounts(abs_pacstrap_inner_root)\n                try:\n                    self._initialize_pacman_keyring(abs_pacstrap_inner_root)\n                    self._sync_archlinux_keyring(abs_pacstrap_inner_root)\n                    self._run_pacstrap(abs_pacstrap_inner_root, rel_pacstrap_target_dir)\n                    self._fix_root_login_at(abs_pacstrap_target_dir)\n                finally:\n                    self._unmount_nondisk_chroot_mounts(abs_pacstrap_inner_root)\n            finally:\n                self._unmount_disk_chroot_mounts(abs_pacstrap_target_dir)\n\n        finally:\n            self._messenger.info('Cleaning up \"%s\"...' % abs_temp_dir)\n            shutil.rmtree(abs_temp_dir)\n\n    @classmethod\n    def add_arguments_to(clazz, distro):\n        distro.add_argument('--arch', dest='architecture', default='x86_64',\n                choices=SUPPORTED_ARCHITECTURES,\n                help='architecture (e.g. x86_64)')\n        distro.add_argument('--image-date', type=date_argparse_type, metavar='YYYY-MM-DD',\n                help='date to use bootstrap image of (e.g. 2015-05-01, default: latest available)')\n        distro.add_argument('--mirror', dest='mirror_url', metavar='URL',\n                default='http://mirror.rackspace.com/archlinux/$repo/os/$arch',\n                help='pacman mirror to use (default: %(default)s)')\n\n    @classmethod\n    def create(clazz, messenger, executor, options):\n        return clazz(\n                messenger,\n                executor,\n                os.path.abspath(options.target_dir),\n                os.path.abspath(options.cache_dir),\n                options.architecture,\n                options.image_date,\n                options.mirror_url,\n                os.path.abspath(options.resolv_conf),\n                )\n",
    "uncovered_lines": [
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      15,
      17,
      20,
      21,
      23,
      25,
      32,
      33,
      34,
      36,
      37,
      40,
      41,
      42,
      44,
      47,
      53,
      54,
      55,
      56,
      58,
      59,
      61,
      62,
      63,
      70,
      71,
      72,
      74,
      75,
      76,
      77,
      78,
      80,
      81,
      83,
      84,
      86,
      87,
      92,
      94,
      95,
      96,
      97,
      98,
      101,
      103,
      104,
      105,
      106,
      107,
      108,
      109,
      111,
      112,
      113,
      115,
      116,
      117,
      119,
      121,
      129,
      131,
      139,
      141,
      142,
      144,
      147,
      148,
      149,
      160,
      162,
      163,
      172,
      174,
      175,
      177,
      178,
      184,
      186,
      187,
      188,
      189,
      190,
      195,
      197,
      198,
      205,
      206,
      207,
      208,
      217,
      218,
      220,
      221,
      222,
      223,
      224,
      226,
      227,
      229,
      230,
      231,
      232,
      233,
      235,
      237,
      239,
      240,
      241,
      244,
      245,
      247,
      249,
      250,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      260,
      263,
      264,
      266,
      267,
      268,
      271,
      273,
      277,
      278,
      279
    ]
  },
  {
    "file_path": "directory_bootstrap/distros/base.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport errno\nimport os\nimport re\nfrom abc import ABCMeta, abstractmethod\nfrom textwrap import dedent\n\nimport directory_bootstrap.shared.loaders._requests as requests\nfrom directory_bootstrap.shared.commands import (\n        COMMAND_GPG, COMMAND_WGET, COMMAND_UNSHARE, COMMAND_UNXZ,\n        check_for_commands)\nfrom directory_bootstrap.shared.loaders._bs4 import BeautifulSoup\nfrom directory_bootstrap.shared.namespace import unshare_current_process\n\nBOOTSTRAPPER_CLASS_FIELD = 'bootstrapper_class'\n\n_year = '([2-9][0-9]{3})'\n_month = '(0[1-9]|1[0-2])'\n_day = '(0[1-9]|[12][0-9]|3[01])'\n\n_argparse_date_matcher = re.compile('^%s-%s-%s$' % (_year, _month, _day))\n\n_GPG_DISPLAY_KEY_FORMAT = '0xlong'\n\n\ndef date_argparse_type(text):\n    m = _argparse_date_matcher.match(text)\n    if m is None:\n        raise ValueError('Not a well-formed date: \"%s\"' % text)\n    return tuple((int(m.group(i)) for i in range(1, 3 + 1)))\n\ndate_argparse_type.__name__ = 'date'\n\n\ndef add_general_directory_bootstrapping_options(general):\n    general.add_argument('--cache-dir', metavar='DIRECTORY',\n            default='/var/cache/directory-bootstrap/',\n            help='directory to use for downloads (default: %(default)s)')\n\n\nclass DirectoryBootstrapper(object, metaclass=ABCMeta):\n    def __init__(self, messenger, executor, abs_target_dir, abs_cache_dir):\n        self._messenger = messenger\n        self._executor = executor\n        self._abs_target_dir = abs_target_dir\n        self._abs_cache_dir = abs_cache_dir\n\n    @abstractmethod\n    def wants_to_be_unshared(self):\n        pass\n\n    @classmethod\n    def add_parser_to(clazz, distros):\n        distro = distros.add_parser(clazz.DISTRO_KEY, help=clazz.DISTRO_NAME_LONG)\n        distro.set_defaults(**{BOOTSTRAPPER_CLASS_FIELD: clazz})\n        clazz.add_arguments_to(distro)\n\n    def check_for_commands(self):\n        check_for_commands(self._messenger, self.get_commands_to_check_for())\n\n    @staticmethod\n    def get_commands_to_check_for():\n        return [\n                COMMAND_WGET,\n                ]\n\n    def unshare(self):\n        unshare_current_process(self._messenger)\n\n    def extract_latest_date(self, listing_html, date_matcher):\n        soup = BeautifulSoup(listing_html, 'lxml')\n        dates = []\n        for link in soup.find_all('a'):\n            m = date_matcher.search(link.get('href'))\n            if not m:\n                continue\n            dates.append(m.group(0))\n\n        return sorted(dates)[-1]\n\n    @abstractmethod\n    def run(self):\n        pass\n\n    @classmethod\n    def add_arguments_to(clazz, distro):\n        raise NotImplementedError()\n\n    @classmethod\n    def create(clazz, messenger, executor, options):\n        raise NotImplementedError()\n\n    def get_url_content(self, url):\n        response = requests.get(url)\n        response.raise_for_status()\n        return response.text\n\n    def download_url_to_file(self, url, filename):\n        if os.path.exists(filename):\n            self._messenger.info('Re-using cache file \"%s\".' % filename)\n            return\n\n        self._messenger.info('Downloading \"%s\"...' % url)\n        cmd = [\n                COMMAND_WGET,\n                '-O%s' % filename,\n                url,\n                ]\n        self._executor.check_call(cmd)\n\n    def uncompress_xz_tarball(self, tarball_filename):\n        extension = '.xz'\n\n        if not tarball_filename.endswith(extension):\n            raise ValueError('Filename \"%s\" does not end with \"%s\"' % (tarball_filename, extension))\n\n        uncompressed_tarball_filename = tarball_filename[:-len(extension)]\n\n        if os.path.exists(uncompressed_tarball_filename):\n            self._messenger.info('Re-using cache file \"%s\".' % uncompressed_tarball_filename)\n        else:\n            self._messenger.info('Uncompressing file \"%s\"...' % tarball_filename)\n            self._executor.check_call([\n                    COMMAND_UNXZ,\n                    '--keep',\n                    tarball_filename,\n                    ])\n\n            if not os.path.exists(uncompressed_tarball_filename):\n                raise OSError(errno.ENOENT, 'File \"%s\" does not exists' % uncompressed_tarball_filename)\n\n        return uncompressed_tarball_filename\n\n    def _ensure_directory_writable(self, abs_path, creation_mode):\n        try:\n            os.makedirs(abs_path, creation_mode)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n\n            self._messenger.info('Checking access to \"%s\"...' % abs_path)\n            if not os.path.exists(abs_path):\n                raise IOError(errno.ENOENT, 'No such file or directory: \\'%s\\'' % abs_path)\n\n            if not os.access(os.path.join(abs_path, ''), os.W_OK):\n                raise IOError(errno.EACCES, 'Permission denied: \\'%s\\'' % abs_path)\n        else:\n            # NOTE: Sounding like future is intentional.\n            self._messenger.info('Creating directory \"%s\"...' % abs_path)\n\n    def ensure_directories_writable(self):\n        self._ensure_directory_writable(self._abs_cache_dir, 0o755)\n        self._ensure_directory_writable(self._abs_target_dir, 0o700)\n\n    @staticmethod\n    def _abs_keyserver_cert_filename(abs_gpg_home_dir):\n        return os.path.join(abs_gpg_home_dir, 'sks-keyservers.netCA.pem')\n\n    def _initialize_gpg_home(self, abs_temp_dir):\n        abs_gpg_home_dir = os.path.join(abs_temp_dir, 'gpg_home')\n        self._messenger.info('Initializing temporary GnuPG home at \"%s\"...' % abs_gpg_home_dir)\n        os.mkdir(abs_gpg_home_dir, 0o700)\n\n        self.download_url_to_file(\n            # This one was trouble: https://sks-keyservers.net/sks-keyservers.netCA.pem\n            'https://raw.githubusercontent.com/gpg/gnupg/master/dirmngr/sks-keyservers.netCA.pem',\n            self._abs_keyserver_cert_filename(abs_gpg_home_dir))\n\n        with open(os.path.join(abs_gpg_home_dir, 'dirmngr.conf'), 'w') as f:\n            print(dedent(\"\"\"\\\n                keyserver hkps://hkps.pool.sks-keyservers.net\n                hkp-cacert %s\n            \"\"\" % self._abs_keyserver_cert_filename(abs_gpg_home_dir)), file=f)\n\n        return abs_gpg_home_dir\n\n    def _get_gpg_argv_start(self, abs_gpg_home_dir):\n        return [\n                COMMAND_UNSHARE,\n                '--fork', '--pid',  # to auto-kill started gpg-agent\n                COMMAND_GPG,\n                '--home', abs_gpg_home_dir,\n                '--keyid-format', _GPG_DISPLAY_KEY_FORMAT,\n                '--batch',\n            ]\n\n    def _import_gpg_key_file(self, abs_gpg_home_dir, abs_key_path):\n        self._messenger.info('Importing GPG key from file \"{}\"...'.format(abs_key_path))\n        cmd = self._get_gpg_argv_start(abs_gpg_home_dir) + [\n                '--quiet',\n                '--import', abs_key_path,\n            ]\n        self._executor.check_call(cmd)\n\n    def _verify_file_gpg(self, candidate_filename, signature_filename, abs_gpg_home_dir):\n        self._messenger.info('Verifying integrity of file \"%s\"...' % candidate_filename)\n        cmd = self._get_gpg_argv_start(abs_gpg_home_dir) + [\n                '--verify',\n                signature_filename,\n                candidate_filename,\n            ]\n        self._executor.check_call(cmd)\n",
    "uncovered_lines": [
      6,
      7,
      8,
      9,
      10,
      12,
      13,
      16,
      17,
      19,
      21,
      22,
      23,
      25,
      27,
      30,
      31,
      32,
      33,
      34,
      36,
      39,
      40,
      45,
      46,
      47,
      48,
      49,
      50,
      52,
      53,
      56,
      57,
      58,
      59,
      60,
      62,
      63,
      65,
      66,
      67,
      71,
      72,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      83,
      85,
      86,
      89,
      90,
      91,
      93,
      94,
      95,
      97,
      98,
      99,
      100,
      102,
      103,
      104,
      105,
      107,
      108,
      113,
      115,
      116,
      118,
      119,
      121,
      123,
      124,
      126,
      127,
      133,
      134,
      136,
      138,
      139,
      140,
      141,
      142,
      143,
      145,
      146,
      147,
      149,
      150,
      153,
      155,
      156,
      157,
      159,
      160,
      161,
      163,
      164,
      165,
      166,
      168,
      173,
      174,
      179,
      181,
      182,
      191,
      192,
      193,
      197,
      199,
      200,
      201,
      206
    ]
  },
  {
    "file_path": "directory_bootstrap/distros/gentoo.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport datetime\nimport errno\nimport importlib.resources\nimport os\nimport re\nimport shutil\nimport subprocess\nimport tempfile\nimport time\n\nimport directory_bootstrap.resources.gentoo as resources\nimport directory_bootstrap.shared.loaders._requests as requests\nfrom directory_bootstrap.distros.base import (\n        DirectoryBootstrapper, date_argparse_type)\nfrom directory_bootstrap.shared.commands import (\n        COMMAND_GPG, COMMAND_MD5SUM, COMMAND_SHA512SUM, COMMAND_TAR,\n        COMMAND_UNXZ)\nfrom directory_bootstrap.tools.stage3_latest_parser import \\\n        find_latest_stage3_date\n\n_GPG_DISPLAY_KEY_FORMAT = '0xlong'\n\n_year = '([2-9][0-9]{3})'\n_month = '(0[1-9]|1[0-2])'\n_day = '(0[1-9]|[12][0-9]|3[01])'\n\n_snapshot_date_matcher = re.compile('%s%s%s' % (_year, _month, _day))\n\n\nclass _ChecksumVerifiationFailed(Exception):\n    def __init__(self, algorithm, filename):\n        super(_ChecksumVerifiationFailed, self).__init__(\n                'File \"%s\" failed %s verification' \\\n                % (filename, algorithm))\n\n\nclass _NotFreshEnoughException(Exception):\n    def __init__(self, year_month_day_tuple, max_age_days):\n        (year, month, day) = year_month_day_tuple\n        super(_NotFreshEnoughException, self).__init__(\n                '%04d-%02d-%02d was more than %d days ago, rejecting as too old' \\\n                % (year, month, day, max_age_days))\n\n\nclass GentooBootstrapper(DirectoryBootstrapper):\n    DISTRO_KEY = 'gentoo'\n    DISTRO_NAME_LONG = 'Gentoo'\n\n    _MIRROR_BLACKLIST = set((\n        # All previous entries removed\n    ))\n\n    def __init__(self, messenger, executor, abs_target_dir, abs_cache_dir,\n                architecture, mirror_url, max_age_days,\n                stage3_date_triple_or_none, repository_date_triple_or_none,\n                abs_resolv_conf):\n        super(GentooBootstrapper, self).__init__(\n                messenger,\n                executor,\n                abs_target_dir,\n                abs_cache_dir,\n                )\n        self._architecture = architecture\n        self._architecture_family = self._extract_architecture_family(architecture)\n        self._mirror_base_url = (mirror_url\n                                 if mirror_url\n                                 else self._retrieve_bounced_mirror_base_url()\n                                 ).rstrip('/')\n        self._max_age_days = max_age_days\n        self._stage3_date_triple_or_none = stage3_date_triple_or_none\n        self._repository_date_triple_or_none = repository_date_triple_or_none\n        self._abs_resolv_conf = abs_resolv_conf\n\n        self._gpg_supports_no_autostart = None\n\n    def _retrieve_bounced_mirror_base_url(self):\n        self._messenger.info('Obtaining mirror URL from bouncer.gentoo.org...')\n        tries = 10\n        for i in range(tries):\n            response = requests.get('https://bouncer.gentoo.org/fetch/root/all/')\n            response.raise_for_status()\n            mirror_url = response.url.rstrip('/')\n\n            if mirror_url not in self._MIRROR_BLACKLIST:\n                break\n\n            time.sleep(0.25)  # to reduce server load\n\n        self._messenger.info(f'Selected mirror {mirror_url} .')\n        return mirror_url\n\n    @staticmethod\n    def _extract_architecture_family(architecture):\n        \"\"\"\n        Map \"arm64\", \"armv6j\" etc to arm\n        \"\"\"\n        if architecture.startswith('arm'):\n            return 'arm'\n        return architecture\n\n    def wants_to_be_unshared(self):\n        return False\n\n    @staticmethod\n    def get_commands_to_check_for():\n        return DirectoryBootstrapper.get_commands_to_check_for() + [\n                COMMAND_GPG,\n                COMMAND_MD5SUM,\n                COMMAND_SHA512SUM,\n                COMMAND_TAR,\n                COMMAND_UNXZ,\n                ]\n\n    def _get_stage3_latest_file_url(self):\n        return '%s/releases/%s/autobuilds/latest-stage3.txt' % (\n                self._mirror_base_url,\n                self._architecture_family,\n                )\n\n    def _get_old_portage_snapshot_listing_url(self):\n        return '%s/releases/snapshots/current/' % self._mirror_base_url\n\n    def _get_new_portage_snapshot_listing_url(self):\n        return '%s/snapshots/' % self._mirror_base_url\n\n    def _find_latest_snapshot_date(self, snapshot_listing):\n        return self.extract_latest_date(snapshot_listing, _snapshot_date_matcher)\n\n    def _download_stage3(self, stage3_date_str, arch_flavor):\n        res = [None, None]\n        for target_index, basename in (\n                (1, 'stage3-%s%s-%s.tar.xz.DIGESTS' % (self._architecture, arch_flavor, stage3_date_str)),\n                (0, 'stage3-%s%s-%s.tar.xz' % (self._architecture, arch_flavor, stage3_date_str)),\n                ):\n            filename = os.path.join(self._abs_cache_dir, basename)\n            url = '%s/releases/%s/autobuilds/%s/%s' \\\n                    % (self._mirror_base_url, self._architecture_family, stage3_date_str, basename)\n            self.download_url_to_file(url, filename)\n\n            assert res[target_index] is None\n            res[target_index] = filename\n\n        return res\n\n    def _download_snapshot(self, snapshot_date_str, snapshot_listing_url):\n        res = [None, None, None, None]\n        for target_index, basename in (\n                (1, 'portage-%s.tar.xz.gpgsig' % snapshot_date_str),\n                (2, 'portage-%s.tar.xz.md5sum' % snapshot_date_str),\n                (3, 'portage-%s.tar.xz.umd5sum' % snapshot_date_str),\n                (0, 'portage-%s.tar.xz' % snapshot_date_str),\n                ):\n            filename = os.path.join(self._abs_cache_dir, basename)\n            url = snapshot_listing_url + basename\n            self.download_url_to_file(url, filename)\n\n            assert res[target_index] is None\n            res[target_index] = filename\n\n        return res\n\n    def _verify_sha512_sum(self, testee_file, digests_file):\n        self._messenger.info('Verifying SHA512 checksum of file \"%s\"...' \\\n                % testee_file)\n\n        expected_sha512sum = None\n        testee_file_basename = os.path.basename(testee_file)\n        with open(digests_file, 'r') as f:\n            upcoming_sha512 = False\n            for l in f:\n                line = l.rstrip()\n                if upcoming_sha512:\n                    sha512, basename = line.split('  ')\n                    if basename == testee_file_basename:\n                        if expected_sha512sum is None:\n                            expected_sha512sum = sha512\n                        else:\n                            raise ValueError('File \"%s\" mentions \"%s\" multiple times' \\\n                    % (digests_file, testee_file_basename))\n\n                upcoming_sha512 = line == '# SHA512 HASH'\n\n        if expected_sha512sum is None:\n            raise ValueError('File \"%s\" does not mention \"%s\"' \\\n                    % (digests_file, testee_file_basename))\n\n        expected_sha512sum_output = '%s  %s\\n' % (expected_sha512sum, testee_file)\n        sha512sum_output = self._executor.check_output([\n                COMMAND_SHA512SUM,\n                testee_file,\n                ])\n\n        if sha512sum_output != expected_sha512sum_output.encode('utf-8'):\n            raise _ChecksumVerifiationFailed('SHA512', testee_file)\n\n    def _verify_md5_sum(self, snapshot_tarball, snapshot_md5sum):\n        self._messenger.info('Verifying MD5 checksum of file \"%s\"...' \\\n                % snapshot_tarball)\n\n        snapshot_tarball_basename = os.path.basename(snapshot_tarball)\n        needle = snapshot_tarball_basename + '\\n'\n        with open(snapshot_md5sum, 'r') as f:\n            if f.read().count(needle) != 1:\n                raise ValueError('File \"%s\" does not mention \"%s\" exactly once' \\\n                        % (snapshot_md5sum, snapshot_tarball_basename))\n\n        cwd = os.path.dirname(snapshot_md5sum)\n        self._executor.check_call([\n                COMMAND_MD5SUM,\n                '--strict',\n                '--check',\n                snapshot_md5sum,\n                ], cwd=cwd)\n\n    def _extract_tarball(self, tarball_filename, abs_target_root):\n        self._messenger.info('Extracting file \"%s\" to \"%s\"...' % (tarball_filename, abs_target_root))\n        self._executor.check_call([\n                COMMAND_TAR,\n                'xpf',\n                tarball_filename,\n            ], cwd=abs_target_root)\n\n    def _require_fresh_enough(self, year_month_day_tuple):\n        (year, month, day) = year_month_day_tuple\n        date_to_check = datetime.date(year, month, day)\n        today = datetime.date.today()\n        if (today - date_to_check).days > self._max_age_days:\n            raise _NotFreshEnoughException((year, month, day), self._max_age_days)\n\n    def _format_date_stage3_tarball_filename(self, stage3_date_triple, stage3_date_extra=''):\n        return '%04d%02d%02d%s' % tuple(stage3_date_triple + (stage3_date_extra,))\n\n    def _parse_snapshot_listing_date(self, snapshot_date_str):\n        m = _snapshot_date_matcher.match(snapshot_date_str)\n        return (int(m.group(1)), int(m.group(2)), int(m.group(3)))\n\n    def _get_gpg_argv_start(self, abs_gpg_home_dir):\n        assert self._gpg_supports_no_autostart is not None\n\n        res = [\n                COMMAND_GPG,\n                '--home', abs_gpg_home_dir,\n                '--keyid-format', _GPG_DISPLAY_KEY_FORMAT,\n                '--batch',\n            ]\n\n        if self._gpg_supports_no_autostart:\n            res += [\n                '--no-autostart',\n                ]\n\n        return res\n\n    def _check_gpg_for_no_autostart_support(self, abs_gpg_home_dir):\n        self._messenger.info('Checking if GnuPG understands the --no-autostart option...')\n        cmd_prefix = [\n            COMMAND_GPG,\n            '--home', abs_gpg_home_dir,\n            '--list-keys',\n            ]\n\n        try:\n            self._executor.check_call(cmd_prefix + ['--no-autostart'])\n        except subprocess.CalledProcessError:\n            # Does it work without it, at least or is there some unrelated trouble?\n            self._executor.check_call(cmd_prefix)\n\n            self._gpg_supports_no_autostart = False\n            self._messenger.info('No, it does not.')\n        else:\n            self._gpg_supports_no_autostart = True\n            self._messenger.info('Yes, it does.')\n\n    def _initialize_gpg_home(self, abs_temp_dir):\n        abs_gpg_home_dir = os.path.join(abs_temp_dir, 'gpg_home')\n\n        self._messenger.info('Initializing temporary GnuPG home at \"%s\"...' % abs_gpg_home_dir)\n        os.mkdir(abs_gpg_home_dir, 0o700)\n\n        self._check_gpg_for_no_autostart_support(abs_gpg_home_dir)\n\n        self._messenger.info('Importing known GnuPG keys from disk...')\n        signatures = [  # from https://www.gentoo.org/downloads/signatures/\n            # Key Fingerprint                            # Description                                                          # Created     # Expiry\n            ('13EBBDBEDE7A12775DFDB1BABB572E0E2D182910', 'Gentoo Linux Release Engineering (Automated Weekly Release Key)',     '2009-08-25', '2020-07-01'),\n            ('DCD05B71EAB94199527F44ACDB6B8C1F96D8BF6D', 'Gentoo ebuild repository signing key (Automated Signing Key)',        '2011-11-25', '2020-07-01'),\n            ('EF9538C9E8E64311A52CDEDFA13D0EF1914E7A72', 'Gentoo repository mirrors (automated git signing key)',               '2018-05-28', '2020-07-01'),\n            ('D99EAC7379A850BCE47DA5F29E6438C817072058', 'Gentoo Linux Release Engineering (Gentoo Linux Release Signing Key)', '2004-07-20', '2020-07-01'),\n            ('ABD00913019D6354BA1D9A132839FE0D796198B1', 'Gentoo Authority Key L1',                                             '2019-04-01', '2020-07-01'),\n            ('18F703D702B1B9591373148C55D3238EC050396E', 'Gentoo Authority Key L2 for Services',                                '2019-04-01', '2020-07-01'),\n            ('2C13823B8237310FA213034930D132FF0FF50EEB', 'Gentoo Authority Key L2 for Developers',                              '2019-04-01', '2020-07-01'),\n        ]\n        for signature in signatures:\n            filename = str(importlib.resources\n                           .files(resources.__name__)\n                           .joinpath('{}.asc'.format(signature[0])))\n            cmd = self._get_gpg_argv_start(abs_gpg_home_dir) + [\n                '--import', filename,\n            ]\n            self._executor.check_call(cmd)\n\n        return abs_gpg_home_dir\n\n    def _verify_detachted_gpg_signature(self, candidate_filename, signature_filename, abs_gpg_home_dir):\n        self._messenger.info('Verifying GnuPG signature of file \"%s\"...' % candidate_filename)\n        cmd = self._get_gpg_argv_start(abs_gpg_home_dir) + [\n                '--verify',\n                signature_filename,\n                candidate_filename,\n            ]\n        self._executor.check_call(cmd)\n\n    def _verify_clearsigned_gpg_signature(self, clearsigned_filename, output_filename, abs_gpg_home_dir):\n        self._messenger.info('Verifying GnuPG signature of file \"%s\", writing file \"%s\"...' \\\n                % (clearsigned_filename, output_filename))\n\n        if os.path.exists(output_filename):\n            raise OSError(errno.EEXIST, 'File \"%s\" exists' % output_filename)\n\n        cmd = self._get_gpg_argv_start(abs_gpg_home_dir) + [\n                '--output', output_filename,\n                '--decrypt', clearsigned_filename,\n                ]\n        self._executor.check_call(cmd)\n\n        if not os.path.exists(output_filename):\n            raise OSError(errno.ENOENT, 'File \"%s\" does not exists' % output_filename)\n\n    def run(self):\n        self.ensure_directories_writable()\n\n        abs_temp_dir = os.path.abspath(tempfile.mkdtemp())\n        try:\n            abs_gpg_home_dir = self._initialize_gpg_home(abs_temp_dir)\n\n            if self._stage3_date_triple_or_none is None:\n                self._messenger.info('Searching for available stage3 tarballs...')\n                stage3_latest_file_url = self._get_stage3_latest_file_url()\n                stage3_latest_file_content = self.get_url_content(stage3_latest_file_url)\n                stage3_date_triple, stage3_date_extra, stage3_flavor = find_latest_stage3_date(stage3_latest_file_content, stage3_latest_file_url, self._architecture)\n                stage3_date_str = self._format_date_stage3_tarball_filename(stage3_date_triple, stage3_date_extra)\n                self._messenger.info('Found \"%s\" to be latest.' % stage3_date_str)\n                self._require_fresh_enough(stage3_date_triple)\n            else:\n                stage3_date_str = self._format_date_stage3_tarball_filename(self._stage3_date_triple_or_none, '')\n                stage3_flavor = ''\n\n            if self._repository_date_triple_or_none is None:\n                self._messenger.info('Searching for available portage repository snapshots...')\n                try:\n                    snapshot_listing_url = self._get_old_portage_snapshot_listing_url()\n                    snapshot_listing = self.get_url_content(snapshot_listing_url)\n                except requests.exceptions.HTTPError:\n                    snapshot_listing_url = self._get_new_portage_snapshot_listing_url()\n                    snapshot_listing = self.get_url_content(snapshot_listing_url)\n                snapshot_date_str = self._find_latest_snapshot_date(snapshot_listing)\n                self._messenger.info('Found \"%s\" to be latest.' % snapshot_date_str)\n                self._require_fresh_enough(self._parse_snapshot_listing_date(snapshot_date_str))\n            else:\n                snapshot_date_str = '%04d%02d%02d' % self._repository_date_triple_or_none\n\n            self._messenger.info('Downloading portage repository snapshot...')\n            snapshot_tarball, snapshot_gpgsig, snapshot_md5sum, snapshot_uncompressed_md5sum \\\n                    = self._download_snapshot(snapshot_date_str, snapshot_listing_url)\n            self._verify_detachted_gpg_signature(snapshot_tarball, snapshot_gpgsig, abs_gpg_home_dir)\n            self._verify_md5_sum(snapshot_tarball, snapshot_md5sum)\n\n            self._messenger.info('Downloading stage3 tarball...')\n            stage3_tarball, stage3_digests_asc \\\n                    = self._download_stage3(stage3_date_str, arch_flavor=stage3_flavor)\n            stage3_digests = os.path.join(abs_temp_dir, os.path.basename(stage3_digests_asc)[:-len('.asc')])\n            self._verify_clearsigned_gpg_signature(stage3_digests_asc, stage3_digests, abs_gpg_home_dir)\n            self._verify_sha512_sum(stage3_tarball, stage3_digests)\n\n            snapshot_tarball_uncompressed = self.uncompress_xz_tarball(snapshot_tarball)\n            self._verify_md5_sum(snapshot_tarball_uncompressed, snapshot_uncompressed_md5sum)\n\n            self._extract_tarball(stage3_tarball, self._abs_target_dir)\n            abs_var_db_repos = os.path.join(self._abs_target_dir, 'var', 'db', 'repos')\n            self._extract_tarball(snapshot_tarball_uncompressed, abs_var_db_repos)\n            os.rename(os.path.join(abs_var_db_repos, 'portage'), os.path.join(abs_var_db_repos, 'gentoo'))\n        finally:\n            self._messenger.info('Cleaning up \"%s\"...' % abs_temp_dir)\n            shutil.rmtree(abs_temp_dir)\n\n    @classmethod\n    def add_arguments_to(clazz, distro):\n        distro.add_argument('--arch', dest='architecture', default='amd64',\n                help='architecture (e.g. amd64)')\n        distro.add_argument('--stage3-date', type=date_argparse_type, metavar='YYYY-MM-DD',\n                help='date to use stage3 of (e.g. 2015-05-01, default: latest available)')\n        distro.add_argument('--repository-date', type=date_argparse_type, metavar='YYYY-MM-DD',\n                help='date to use portage repository snapshot of (e.g. 2015-05-01, default: latest available)')\n        distro.add_argument('--max-age-days', type=int, metavar='DAYS', default=14,\n                help='age in days to tolerate as recent enough (security feature, default: %(default)s days)')\n        distro.add_argument('--mirror', dest='mirror_url', metavar='URL',\n                help='precise mirror URL to use (default: let bouncer.gentoo.org decide)')\n\n    @classmethod\n    def create(clazz, messenger, executor, options):\n        return clazz(\n                messenger,\n                executor,\n                os.path.abspath(options.target_dir),\n                os.path.abspath(options.cache_dir),\n                options.architecture,\n                options.mirror_url,\n                options.max_age_days,\n                options.stage3_date,\n                options.repository_date,\n                os.path.abspath(options.resolv_conf),\n                )\n",
    "uncovered_lines": [
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      16,
      17,
      18,
      20,
      23,
      26,
      28,
      29,
      30,
      32,
      35,
      36,
      37,
      42,
      43,
      44,
      45,
      50,
      51,
      52,
      54,
      58,
      62,
      68,
      69,
      70,
      74,
      75,
      76,
      77,
      79,
      81,
      82,
      83,
      84,
      85,
      86,
      87,
      89,
      90,
      92,
      94,
      95,
      97,
      98,
      102,
      103,
      104,
      106,
      107,
      109,
      110,
      111,
      119,
      120,
      125,
      126,
      128,
      129,
      131,
      132,
      134,
      135,
      136,
      140,
      141,
      143,
      145,
      146,
      148,
      150,
      151,
      152,
      158,
      159,
      160,
      162,
      163,
      165,
      167,
      168,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      183,
      186,
      188,
      189,
      192,
      193,
      198,
      199,
      201,
      202,
      205,
      206,
      207,
      208,
      209,
      212,
      213,
      220,
      221,
      222,
      228,
      229,
      230,
      231,
      232,
      233,
      235,
      236,
      238,
      239,
      240,
      242,
      243,
      245,
      252,
      253,
      257,
      259,
      260,
      261,
      267,
      268,
      269,
      271,
      273,
      274,
      276,
      277,
      279,
      280,
      282,
      283,
      285,
      287,
      288,
      298,
      299,
      302,
      305,
      307,
      309,
      310,
      311,
      316,
      318,
      319,
      322,
      323,
      325,
      329,
      331,
      332,
      334,
      335,
      337,
      338,
      339,
      341,
      342,
      343,
      344,
      345,
      346,
      347,
      348,
      350,
      351,
      353,
      354,
      355,
      356,
      357,
      358,
      359,
      360,
      361,
      362,
      363,
      365,
      367,
      368,
      370,
      371,
      373,
      374,
      376,
      377,
      378,
      380,
      381,
      383,
      384,
      385,
      386,
      388,
      389,
      391,
      392,
      393,
      395,
      397,
      399,
      401,
      404,
      405,
      406
    ]
  },
  {
    "file_path": "directory_bootstrap/distros/void.py",
    "code": "import errno\nimport os\nimport shutil\nimport tempfile\nfrom tarfile import TarFile\n\nfrom directory_bootstrap.distros.base import DirectoryBootstrapper\nfrom directory_bootstrap.shared.commands import (\n    COMMAND_CP,\n    COMMAND_TAR,\n    COMMAND_UNXZ,\n    )\n\n\nSUPPORTED_ARCHITECTURES = ('i686', 'x86_64')\n\n\nclass VoidBootstrapper(DirectoryBootstrapper):\n    DISTRO_KEY = 'void'\n    DISTRO_NAME_LONG = 'Void Linux'\n\n    def __init__(self, messenger, executor, abs_target_dir, abs_cache_dir,\n                architecture,\n                abs_resolv_conf):\n        super(VoidBootstrapper, self).__init__(\n                messenger,\n                executor,\n                abs_target_dir,\n                abs_cache_dir,\n                )\n        self._architecture = architecture\n        self._abs_resolv_conf = abs_resolv_conf\n\n    def wants_to_be_unshared(self):\n        return True\n\n    @staticmethod\n    def get_commands_to_check_for():\n        return DirectoryBootstrapper.get_commands_to_check_for() + [\n                COMMAND_CP,\n                COMMAND_TAR,\n                COMMAND_UNXZ,\n                ]\n\n    def _download_static_image(self):\n        basename = 'xbps-static-latest.%s-musl.tar.xz' % self._architecture\n        url = 'https://repo-default.voidlinux.org/static/%s' % basename\n        abs_filename = os.path.join(self._abs_cache_dir, basename)\n        self.download_url_to_file(url, abs_filename)\n        return self.uncompress_xz_tarball(abs_filename)\n\n    def _copy_keys_into_chroot(self, abs_temp_dir):\n        rel_xbps_keys_path = 'var/db/xbps/keys'\n        abs_target_xbps_keys_path = os.path.join(self._abs_target_dir, rel_xbps_keys_path)\n\n        self._messenger.info('Copying xbps keys to \"%s\"...' % abs_target_xbps_keys_path)\n        try:\n            os.makedirs(abs_target_xbps_keys_path, 0o755)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n\n        self._executor.check_call([\n                COMMAND_CP,\n                '-r',\n                os.path.join(abs_temp_dir, rel_xbps_keys_path),\n                os.path.dirname(abs_target_xbps_keys_path),\n                ])\n\n    def run(self):\n        self.ensure_directories_writable()\n\n        abs_temp_dir = os.path.abspath(tempfile.mkdtemp())\n        try:\n            abs_static_image_filename = self._download_static_image()\n            with TarFile.open(abs_static_image_filename) as tf:\n                tf.extractall(path=abs_temp_dir)\n\n            self._copy_keys_into_chroot(abs_temp_dir)\n\n            self._messenger.info('Installing into \"%s\"...' % self._abs_target_dir)\n            xbps_install = os.path.join(abs_temp_dir, 'usr/bin/xbps-install.static')\n            self._executor.check_call([\n                    xbps_install,\n                    '--rootdir', self._abs_target_dir,\n                    '--repository=https://repo-default.voidlinux.org/current/musl',\n                    '--sync', '--yes',\n                    'base-system',\n                    ], cwd=abs_temp_dir)\n        finally:\n            self._messenger.info('Cleaning up \"%s\"...' % abs_temp_dir)\n            shutil.rmtree(abs_temp_dir)\n\n    @classmethod\n    def add_arguments_to(clazz, distro):\n        distro.add_argument('--arch', dest='architecture', default='x86_64',\n                choices=SUPPORTED_ARCHITECTURES,\n                help='architecture (e.g. x86_64)')\n\n    @classmethod\n    def create(clazz, messenger, executor, options):\n        return clazz(\n                messenger,\n                executor,\n                os.path.abspath(options.target_dir),\n                os.path.abspath(options.cache_dir),\n                options.architecture,\n                os.path.abspath(options.resolv_conf),\n                )\n",
    "uncovered_lines": [
      1,
      2,
      3,
      4,
      5,
      7,
      8,
      15,
      18,
      19,
      20,
      22,
      25,
      31,
      32,
      34,
      35,
      37,
      38,
      39,
      45,
      46,
      47,
      48,
      49,
      50,
      52,
      53,
      54,
      56,
      57,
      58,
      59,
      60,
      61,
      63,
      70,
      71,
      73,
      74,
      75,
      76,
      77,
      79,
      81,
      82,
      83,
      91,
      92,
      94,
      95,
      96,
      100,
      101,
      102
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/byte_size.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\n_UNIT_LABELS = (\n    'byte',\n    'KiB',\n    'MiB',\n    'GiB',\n    'TiB',\n)\n\n\ndef format_byte_size(size_bytes):\n    FACTOR = 1024\n    for exponent, unit in enumerate(_UNIT_LABELS):\n        if size_bytes < FACTOR:\n            if size_bytes < FACTOR / 2:\n                final_unit = unit\n            else:\n                final_unit = _UNIT_LABELS[exponent + 1]\n                size_bytes /= float(FACTOR)\n\n            value = str('%.3f' % size_bytes).rstrip('0').rstrip('.')\n            return '%s %s' % (value, final_unit)\n\n        size_bytes /= float(FACTOR)\n    else:\n        raise ValueError('Byte size too large to be supported')\n",
    "uncovered_lines": [
      30
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/commands.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\nimport errno\nimport os\nimport subprocess\nimport time\n\nCOMMAND_BLKID = 'blkid'\nCOMMAND_BLOCKDEV = 'blockdev'\nCOMMAND_CHMOD = 'chmod'\nCOMMAND_CHROOT = 'chroot'\nCOMMAND_CP = 'cp'\nCOMMAND_DB_DUMP = 'db_dump'\nCOMMAND_EXTLINUX = 'extlinux'\nCOMMAND_FILE = 'file'\nCOMMAND_FIND = 'find'\nCOMMAND_GPG = 'gpg'\nCOMMAND_INSTALL_MBR = 'install-mbr'\nCOMMAND_KPARTX = 'kpartx'\nCOMMAND_LSB_RELEASE = 'lsb_release'\nCOMMAND_MD5SUM = 'md5sum'\nCOMMAND_MKDIR = 'mkdir'\nCOMMAND_MKFS_EXT4 = 'mkfs.ext4'\nCOMMAND_MOUNT = 'mount'\nCOMMAND_PARTED = 'parted'\nCOMMAND_PARTPROBE = 'partprobe'\nCOMMAND_RM = 'rm'\nCOMMAND_RMDIR = 'rmdir'\nCOMMAND_RPM = 'rpm'\nCOMMAND_SED = 'sed'\nCOMMAND_SHA512SUM = 'sha512sum'\nCOMMAND_TAR = 'tar'\nCOMMAND_TUNE2FS = 'tune2fs'\nCOMMAND_UMOUNT = 'umount'\nCOMMAND_UNAME = 'uname'\nCOMMAND_UNSHARE = 'unshare'\nCOMMAND_UNXZ = 'unxz'\nCOMMAND_WGET = 'wget'\nCOMMAND_YUM = 'yum'\n\n\nEXIT_COMMAND_NOT_FOUND = 127\n\n\ndef check_call__keep_trying(executor, cmd):\n\tfor i in range(3):\n\t\ttry:\n\t\t\texecutor.check_call(cmd)\n\t\texcept subprocess.CalledProcessError as e:\n\t\t\tif e.returncode == EXIT_COMMAND_NOT_FOUND:\n\t\t\t\traise\n\t\t\ttime.sleep(1)\n\t\telse:\n\t\t\tbreak\n\n\ndef find_command(command):\n    assert not command.startswith('/')\n\n    dirs = os.environ['PATH'].split(':')\n    for _dir in dirs:\n        abs_path = os.path.join(_dir, command)\n        if os.path.exists(abs_path):\n            return abs_path\n\n    raise OSError(EXIT_COMMAND_NOT_FOUND, 'Command \"%s\" not found in PATH.' \\\n        % command)\n\n\ndef check_for_commands(messenger, commands_to_check_for):\n    infos_produced = False\n\n    missing_files = []\n    missing_commands = []\n    for command in sorted(set(c for c in commands_to_check_for if c is not None)):\n        if command.startswith('/'):\n            abs_path = command\n            if not os.path.exists(abs_path):\n                missing_files.append(abs_path)\n            continue\n\n        try:\n            abs_path = find_command(command)\n        except OSError as e:\n            if e.errno != EXIT_COMMAND_NOT_FOUND:\n                raise\n            missing_commands.append(command)\n            messenger.error('Checking for %s... NOT FOUND' % command)\n        else:\n            messenger.info('Checking for %s... %s' % (command, abs_path))\n            infos_produced = True\n\n    if missing_files:\n        raise OSError(errno.ENOENT, 'File \"%s\" not found.' \\\n            % missing_files[0])\n\n    if missing_commands:\n        raise OSError(EXIT_COMMAND_NOT_FOUND, 'Command \"%s\" not found in PATH.' \\\n            % missing_commands[0])\n\n    if infos_produced:\n        messenger.info_gap()\n",
    "uncovered_lines": [
      4,
      5,
      6,
      7,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      43,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      55,
      58,
      59,
      61,
      62,
      63,
      64,
      65,
      67,
      71,
      72,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      91,
      92,
      94,
      95,
      98,
      99,
      102,
      103
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/executor.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport os\nimport subprocess\nimport sys\n\n\n_WANTED_PATHS = (\n    '/usr/local/sbin',\n    '/usr/local/bin',\n    '/usr/sbin',\n    '/usr/bin',\n    '/sbin',\n    '/bin',\n)\n\n\ndef _insert_before_after(list_, befores, element, afters, strict=False):\n    \"\"\"\n    Insert somewhere after certain elements but also before certain others.\n\n    >>> list_ = [2, 0, 0, 1, 0, 0, 5, 6, 0]\n    >>> _insert_before_after(list_, [1, 2], 3, [5, 6])\n    >>> list_\n    [2, 0, 0, 1, 3, 0, 0, 5, 6, 0]\n    \"\"\"\n    def or_default(func, arg, default):\n        try:\n            return func(arg)\n        except ValueError:\n            return default\n\n    max_before_index = or_default(\n        max, (or_default(list_.index, e, -1) for e in befores),\n        -1)\n\n    min_afters_index = or_default(\n        min, (or_default(list_.index, e, len(list_)) for e in afters),\n        len(list_))\n\n    if max_before_index >= min_afters_index:\n        if strict:\n            raise Exception('Cannot satisfy \"befores\" and \"after\"'\n                            ' at the same time'\n                            ' with this particular list')\n        else:\n            insertion_index = len(list_)\n    else:\n        insertion_index = max_before_index + 1\n\n    list_.insert(insertion_index, element)\n\n\ndef _sanitize_path(path):\n    \"\"\"\n    Arch has a rather short $PATH:\n    ```\n    # env -i bash -c 'sed \"s,:,\\n,g\" <<<\"$PATH\"'\n    /usr/local/sbin\n    /usr/local/bin\n    /usr/bin\n    ```\n\n    With their symlinks it makes sense:\n    ```\n    # ls -l /bin /sbin /usr/sbin\n    lrwxrwxrwx 1 root root 7 Oct 17 07:32 /bin -> usr/bin\n    lrwxrwxrwx 1 root root 7 Oct 17 07:32 /sbin -> usr/bin\n    lrwxrwxrwx 1 root root 3 Oct 17 07:32 /usr/sbin -> bin\n    ```\n\n    Now if we call chroot on Arch, that short $PATH is used\n    in a distro made for /usr/sbin to be in $PATH.  Hence\n    we put it in ourselves.\n\n    https://github.com/hartwork/image-bootstrap/issues/62\n    \"\"\"\n\n    future_paths = path.split(os.pathsep)\n\n    tasks = [(_WANTED_PATHS[:i], wanted_path, _WANTED_PATHS[i + 1:])\n             for i, wanted_path in enumerate(_WANTED_PATHS)]\n\n    for befores, element, afters in tasks:\n        if element in future_paths:\n            continue\n\n        _insert_before_after(future_paths, befores, element, afters)\n\n    return os.pathsep.join(future_paths)\n\n\ndef sanitize_path(env=None):\n    if env is None:\n        env = os.environ\n\n    env['PATH'] = _sanitize_path(env['PATH'])\n\n\nclass Executor(object):\n    def __init__(self, messenger, stdout=None, stderr=None):\n        self._messenger = messenger\n        self._announce_target = stdout or sys.stdout\n        self._default_stdout = stdout or sys.stdout\n        self._default_stderr = stderr or sys.stderr\n\n    def check_call(self, argv, env=None, cwd=None):\n        self._messenger.announce_command(argv)\n        subprocess.check_call(argv,\n                stdout=self._default_stdout,\n                stderr=self._default_stderr,\n                env=self._without_pythonpath(env),\n                cwd=cwd,\n                )\n\n    def check_output(self, argv):\n        self._messenger.announce_command(argv)\n        return subprocess.check_output(argv, stderr=self._default_stderr)\n\n    def _without_pythonpath(self, env):\n        if env is None:\n            env = os.environ\n\n        return {k: v for k, v in env.items() if k != 'PYTHONPATH'}\n",
    "uncovered_lines": [
      45,
      46,
      50,
      97,
      98,
      100,
      105,
      106,
      107,
      108,
      111,
      112,
      120,
      121,
      124,
      125,
      127
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/messenger.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport re\nimport sys\n\nfrom directory_bootstrap.shared.loaders._colorama import Fore, Style\nfrom directory_bootstrap.shared.metadata import (\n        GITHUB_HOME_URL, RELEASE_DATE_STR, VERSION_STR)\n\n_NEEDS_ESCAPING = re.compile('([!`\"\\'$ \\\\\\\\{}()?*&<>;])')\n\nVERBOSITY_QUIET = object()\nVERBOSITY_VERBOSE = object()\n\nBANNER = r\"\"\"\n     _                          __             __      __               \n    (_)_ _  ___ ____ ____  ___ / /  ___  ___  / /____ / /________ ____  \n   / /  ' \\/ _ `/ _ `/ -_)/__// _ \\/ _ \\/ _ \\/ __(_-</ __/ __/ _ `/ _ \\ \n  /_/_/_/_/\\_,_/\\_, /\\__/    /_.__/\\___/\\___/\\__/___/\\__/_/  \\_,_/ .__/ \n               /___/                    %(3456789_123456789_)s  /_/     \n\nSoftware libre licensed under AGPL v3 or later.\nBrought to you by Sebastian Pipping <sebastian@pipping.org>.\nPlease report bugs at %(github_home)s.  Thank you!\n\"\"\" % {\n    '3456789_123456789_': '%*s' \\\n        % (len('%(3456789_123456789_)s'),\n        'v%s :: %s' % (VERSION_STR, RELEASE_DATE_STR)),\n    'github_home': GITHUB_HOME_URL,\n}\n\n\ndef fix_output_encoding():\n    \"\"\"\n    Fixes program invocation a la \"...... |& tee file.log\"\n    to not end up with UnicodeEncodeError\n    \"\"\"\n    if sys.stdout.encoding is None:\n        import codecs\n        sys.stdout = codecs.getwriter('utf-8')(sys.stdout)\n    if sys.stderr.encoding is None:\n        import codecs\n        sys.stderr = codecs.getwriter('utf-8')(sys.stderr)\n\n\nclass Messenger(object):\n    def __init__(self, verbosity, colorize):\n        self._infos_wanted = verbosity is not VERBOSITY_QUIET\n        self._warnings_wanted = verbosity is not VERBOSITY_QUIET\n        self._commands_wanted = verbosity is VERBOSITY_VERBOSE\n        self._colorize = colorize\n\n    def colorize(self, text, fore=None, style=None):\n        if not self._colorize:\n            return text\n\n        chunks = []\n        if fore:\n            chunks.append(fore)\n        if style:\n            chunks.append(style)\n        chunks.append(text)\n        if fore or style:\n            chunks.append(Style.RESET_ALL)\n        return ''.join(chunks)\n\n    def banner(self):\n        if not self._infos_wanted:\n            return\n\n        print(BANNER)\n        print()\n\n    def escape_shell(self, text):\n        escaped = _NEEDS_ESCAPING.sub('\\\\\\\\\\\\1', text)\n        if not escaped:\n            return \"''\"\n        return escaped\n\n    def announce_command(self, argv):\n        if not self._commands_wanted:\n            return\n        text = '# %s' % ' '.join((self.escape_shell(e) for e in argv))\n\n        sys.stderr.flush()\n        print(self.colorize(text, Fore.CYAN))\n        sys.stdout.flush()\n\n    def info(self, text):\n        if not self._infos_wanted:\n            return\n        print(self.colorize(text, Fore.GREEN))\n\n    def warn(self, text):\n        if not self._warnings_wanted:\n            return\n        print(self.colorize('Warning: ' + text, Fore.MAGENTA, Style.BRIGHT))\n\n    def error(self, text):\n        print(self.colorize('Error: ' + text, Fore.RED, Style.BRIGHT), file=sys.stderr)\n\n    def info_gap(self):\n        if not self._infos_wanted:\n            return\n        print()\n\n    def encourage_bug_reports(self):\n        print('If this looks like a bug to you, please file a report at %s.  Thank you!' \\\n                % GITHUB_HOME_URL, file=sys.stderr)\n",
    "uncovered_lines": [
      6,
      7,
      9,
      10,
      13,
      15,
      16,
      36,
      41,
      42,
      43,
      44,
      45,
      46,
      49,
      50,
      51,
      52,
      53,
      54,
      56,
      57,
      58,
      60,
      61,
      62,
      63,
      64,
      65,
      66,
      67,
      68,
      70,
      71,
      72,
      74,
      75,
      77,
      78,
      79,
      80,
      81,
      83,
      84,
      85,
      86,
      88,
      89,
      90,
      92,
      93,
      94,
      95,
      97,
      98,
      99,
      100,
      102,
      103,
      105,
      106,
      107,
      108,
      110,
      111
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/metadata.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\nPACKAGE_NAME = 'image-bootstrap'\n\nGITHUB_HOME_URL = 'https://github.com/hartwork/image-bootstrap'\n\nDESCRIPTION = 'Command line tool for creating bootable virtual machine images'\n\n_VERSION = (2, 0, 5)\nVERSION_STR = '.'.join((str(e) for e in _VERSION))\n\n_RELEASE_DATE = (2021, 1, 8)\nRELEASE_DATE_STR = '-'.join(('%02d' % e for e in _RELEASE_DATE))\n",
    "uncovered_lines": [
      4,
      6,
      8,
      10,
      11,
      13,
      14
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/mount.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\nfrom directory_bootstrap.shared.commands import (\n        COMMAND_UMOUNT, check_call__keep_trying)\n\n\ndef try_unmounting(executor, abs_path):\n    cmd = [\n            COMMAND_UMOUNT,\n            abs_path,\n            ]\n    check_call__keep_trying(executor, cmd)\n",
    "uncovered_lines": [
      4,
      8,
      9,
      13
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/namespace.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\nimport errno\nimport os\nfrom ctypes import CDLL, c_char_p, c_int, cast, get_errno\n\n_CLONE_NEWNS = 0x00020000\n_CLONE_NEWUTS = 0x04000000\n\n_lib_c = CDLL(\"libc.so.6\", use_errno=True)\n\n\ndef unshare_current_process(messenger):\n    messenger.info('Unsharing Linux namespaces (mount, UTS/hostname)...')\n    ret = _lib_c.unshare(c_int(_CLONE_NEWNS | _CLONE_NEWUTS))\n    if ret:\n        _errno = get_errno() or errno.EPERM\n        raise OSError(_errno, 'Unsharing Linux namespaces failed: ' + os.strerror(_errno))\n\n\ndef set_hostname(hostname):\n    hostname_char_p = cast(hostname.encode('utf-8'), c_char_p)\n    hostname_len_size_t = _lib_c.strlen(hostname_char_p)\n    ret = _lib_c.sethostname(hostname_char_p, hostname_len_size_t)\n    if ret:\n        _errno = get_errno() or errno.EPERM\n        raise OSError(_errno, 'Setting hostname failed: ' + os.strerror(_errno))\n",
    "uncovered_lines": [
      4,
      5,
      6,
      8,
      9,
      11,
      14,
      15,
      16,
      17,
      18,
      19,
      22,
      23,
      24,
      25,
      26,
      27,
      28
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/output_control.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\nimport os\nimport subprocess\nimport sys\nimport traceback\n\nfrom directory_bootstrap.shared.messenger import (\n        VERBOSITY_QUIET, VERBOSITY_VERBOSE)\n\n_COLORIZE_NEVER = 'never'\n_COLORIZE_ALWAYS = 'always'\n_COLORIZE_AUTO = 'auto'\n\n\ndef add_output_control_options(parser):\n    output = parser.add_argument_group('text output configuration')\n    output.add_argument('--color', default=_COLORIZE_AUTO, choices=[_COLORIZE_NEVER, _COLORIZE_ALWAYS, _COLORIZE_AUTO],\n        help='toggle output color (default: %(default)s)')\n    output.add_argument('--debug', action='store_true',\n        help='enable debugging')\n    output.add_argument('--quiet', dest='verbosity', action='store_const', const=VERBOSITY_QUIET,\n        help='limit output to error messages')\n    output.add_argument('--verbose', dest='verbosity', action='store_const', const=VERBOSITY_VERBOSE,\n        help='increase verbosity')\n\n\ndef is_color_wanted(options):\n    if options.color == _COLORIZE_AUTO:\n        colorize = os.isatty(sys.stdout.fileno())\n    else:\n        colorize = options.color == _COLORIZE_ALWAYS\n\n    return colorize\n\n\ndef run_handle_errors(main_function, messenger, options):\n    try:\n        main_function(messenger, options)\n    except KeyboardInterrupt:\n        messenger.info('Interrupted.')\n        raise\n    except BaseException as e:\n        if options.debug:\n            traceback.print_exc(file=sys.stderr)\n\n        if isinstance(e, subprocess.CalledProcessError):\n            # Manual work to avoid list square brackets in output\n            command_flat = ' '.join((messenger.escape_shell(e) for e in e.cmd))\n            text = 'Command \"%s\" returned non-zero exit status %s' % (command_flat, e.returncode)\n        elif hasattr(e, '_ib_abs_script_filename'):\n            text = '%s (script \"%s\")' % (str(e), e._ib_abs_script_filename)\n        else:\n            text = str(e)\n\n        messenger.error(text)\n        messenger.encourage_bug_reports()\n        sys.exit(1)\n",
    "uncovered_lines": [
      4,
      5,
      6,
      7,
      9,
      12,
      13,
      14,
      17,
      18,
      19,
      21,
      23,
      25,
      29,
      30,
      31,
      33,
      35,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      48,
      50,
      51,
      52,
      53,
      55,
      57,
      58,
      59
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/resolv_conf.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\n\ndef filter_copy_resolv_conf(messenger, abs_etc_resolv_conf, output_filename):\n    messenger.info('Writing file \"%s\" (based on file \"%s\")...'\n            % (output_filename, abs_etc_resolv_conf))\n\n    with open(abs_etc_resolv_conf) as input_f:\n        with open(output_filename, 'w') as output_f:\n            for l in input_f:\n                line = l.rstrip()\n                if line.startswith('nameserver'):\n                    print(line, file=output_f)\n",
    "uncovered_lines": [
      7,
      8,
      11,
      12,
      13,
      14,
      15,
      16
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/loaders/_argparse.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport sys\n\ntry:\n    from argparse import ArgumentParser, \\\n            RawDescriptionHelpFormatter\nexcept ImportError:\n    print('ERROR: Please use Python >=2.7 or install argparse '\n        '(https://pypi.python.org/pypi/argparse).  '\n        'Thank you!', file=sys.stderr)\n    sys.exit(1)\n\n# Mark as used\nArgumentParser\nRawDescriptionHelpFormatter\n\ndel sys\n",
    "uncovered_lines": [
      6,
      8,
      9,
      11,
      12,
      15,
      18,
      19,
      21
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/loaders/_bs4.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport sys\n\ntry:\n    from bs4 import BeautifulSoup\nexcept ImportError:\n    print('ERROR: Please install Beautiful Soup '\n        '(https://pypi.python.org/pypi/beautifulsoup4).  '\n        'Thank you!', file=sys.stderr)\n    sys.exit(1)\n\n# Mark as used\nBeautifulSoup\n\ndel sys\n",
    "uncovered_lines": [
      6,
      8,
      9,
      10,
      11,
      14,
      17,
      19
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/loaders/_colorama.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport sys\n\ntry:\n    from colorama import Fore, Style\nexcept ImportError:\n    print('ERROR: Please install Colorama '\n        '(https://pypi.python.org/pypi/colorama).  '\n        'Thank you!', file=sys.stderr)\n    sys.exit(1)\n\n# Mark as used\nFore\nStyle\n\ndel sys\n",
    "uncovered_lines": [
      6,
      8,
      9,
      10,
      11,
      14,
      17,
      18,
      20
    ]
  },
  {
    "file_path": "directory_bootstrap/shared/loaders/_requests.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport sys\n\ntry:\n    from requests import get\n    from requests.exceptions import HTTPError\nexcept ImportError as e:\n    print('ERROR: Please install Requests '\n        '(https://pypi.python.org/pypi/requests).  '\n        'Thank you!', file=sys.stderr)\n    sys.exit(1)\n\n# Create pseudeo-module forwarder\nclass _ExceptionsModule:\n    pass\nexceptions = _ExceptionsModule()\nexceptions.HTTPError = HTTPError\n\n# Mark as used\nget\n\ndel sys\n",
    "uncovered_lines": [
      6,
      8,
      9,
      10,
      11,
      12,
      15,
      18,
      20,
      21,
      24,
      26
    ]
  },
  {
    "file_path": "directory_bootstrap/tools/stage3_latest_parser.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport re\n\n_year = '([2-9][0-9]{3})'\n_month = '(0[1-9]|1[0-2])'\n_day = '(0[1-9]|[12][0-9]|3[01])'\n_time = '(T[0-9]{6}Z)?'\n\n_STAGE3_TARBALL_DATE_PATTERN = '^(?P<date>%s%s%s%s)/stage3-(?P<arch>[^ -]+)(?P<flavor>-openrc)?-[0-9]+(T[0-9]+Z)?\\\\.tar\\\\.[^ ]+ [1-9]+[0-9]*$' % (_year, _month, _day, _time)\n_stage3_tarball_date_matcher = re.compile(_STAGE3_TARBALL_DATE_PATTERN)\n\n\ndef find_latest_stage3_date(stage3_latest_file_content, stage3_latest_file_url, architecture):\n    matches = []\n    for line in stage3_latest_file_content.split('\\n'):\n        m = _stage3_tarball_date_matcher.match(line)\n        if m is None:\n            continue\n        if m.group('arch') != architecture:\n            continue\n        matches.append(m)\n\n    message = ('Content from %s does not seem to contain '\n            'well-formed OpenRC/default '\n            'stage3 tarball entr(y|ies)'\n            % stage3_latest_file_url\n            )\n\n    if not matches:\n        raise ValueError(message)\n\n    m = sorted(matches, key=lambda e: e.group(1))[-1]  # i.e. most recent\n    return (int(m.group(2)), int(m.group(3)), int(m.group(4))), m.group(5), m.group('flavor') or ''\n",
    "uncovered_lines": [
      34
    ]
  },
  {
    "file_path": "image_bootstrap/__main__.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\nimport os\nimport signal\nimport sys\n\nfrom directory_bootstrap.distros.base import \\\n        add_general_directory_bootstrapping_options\nfrom directory_bootstrap.shared.executor import Executor, sanitize_path\nfrom directory_bootstrap.shared.loaders._argparse import (\n        ArgumentParser, RawDescriptionHelpFormatter)\nfrom directory_bootstrap.shared.messenger import (\n        BANNER, VERBOSITY_VERBOSE, Messenger, fix_output_encoding)\nfrom directory_bootstrap.shared.metadata import DESCRIPTION, VERSION_STR\nfrom directory_bootstrap.shared.output_control import (\n        add_output_control_options, is_color_wanted, run_handle_errors)\nfrom image_bootstrap.distros.arch import ArchStrategy\nfrom image_bootstrap.distros.base import DISTRO_CLASS_FIELD\nfrom image_bootstrap.distros.debian import DebianStrategy\nfrom image_bootstrap.distros.gentoo import GentooStrategy\nfrom image_bootstrap.distros.ubuntu import UbuntuStrategy\nfrom image_bootstrap.engine import (\n        BOOTLOADER__AUTO, BOOTLOADER__CHROOT_GRUB2__DEVICE,\n        BOOTLOADER__CHROOT_GRUB2__DRIVE, BOOTLOADER__HOST_EXTLINUX,\n        BOOTLOADER__HOST_GRUB2__DEVICE, BOOTLOADER__HOST_GRUB2__DRIVE,\n        BOOTLOADER__NONE, BootstrapEngine, MachineConfig)\nfrom image_bootstrap.types.disk_id import disk_id_type\nfrom image_bootstrap.types.machine_id import machine_id_type\nfrom image_bootstrap.types.uuid import uuid_type\n\n_BOOTLOADER_APPROACHES = (\n        BOOTLOADER__AUTO,\n        BOOTLOADER__CHROOT_GRUB2__DEVICE,\n        BOOTLOADER__CHROOT_GRUB2__DRIVE,\n        BOOTLOADER__HOST_EXTLINUX,\n        BOOTLOADER__HOST_GRUB2__DEVICE,\n        BOOTLOADER__HOST_GRUB2__DRIVE,\n        BOOTLOADER__NONE\n        )\n\n\ndef _abspath_or_none(path_or_none):\n    return path_or_none and os.path.abspath(path_or_none)\n\n\ndef _main__level_three(messenger, options):\n    messenger.banner()\n\n    stdout_wanted = options.verbosity is VERBOSITY_VERBOSE\n\n    if stdout_wanted:\n        child_process_stdout = None\n    else:\n        child_process_stdout = open('/dev/null', 'w')\n\n    sanitize_path()\n\n    executor = Executor(messenger, stdout=child_process_stdout)\n\n    machine_config = MachineConfig(\n            options.hostname,\n            options.architecture,\n            options.root_password,\n            _abspath_or_none(options.root_password_file),\n            os.path.abspath(options.resolv_conf),\n            options.disk_id,\n            options.first_partition_uuid,\n            options.machine_id,\n            options.bootloader_approach,\n            options.bootloader_force,\n            options.with_openstack,\n            )\n\n    bootstrap = BootstrapEngine(\n            messenger,\n            executor,\n            machine_config,\n            _abspath_or_none(options.scripts_dir_pre),\n            _abspath_or_none(options.scripts_dir_chroot),\n            _abspath_or_none(options.scripts_dir_post),\n            os.path.abspath(options.target_path),\n            options.command_grub2_install,\n            )\n\n    distro_class = getattr(options, DISTRO_CLASS_FIELD)\n    bootstrap.set_distro(distro_class.create(messenger, executor, options))\n\n    bootstrap.check_release()\n    bootstrap.select_bootloader()\n    bootstrap.detect_grub2_install()\n    bootstrap.check_for_commands()\n    bootstrap.check_architecture()\n    bootstrap.check_target_block_device()\n    bootstrap.check_script_permissions()\n    bootstrap.process_root_password()\n    bootstrap.run()\n\n    if not stdout_wanted:\n        child_process_stdout.close()\n\n    messenger.info('Done.')\n\n\ndef _main__level_two():\n    parser = ArgumentParser(\n            prog='image-bootstrap',\n            description=DESCRIPTION,\n            epilog=BANNER,\n            formatter_class=RawDescriptionHelpFormatter,\n            )\n    parser.add_argument('--version', action='version', version=VERSION_STR)\n\n    add_output_control_options(parser)\n\n    machine = parser.add_argument_group('machine configuration')\n    machine.add_argument('--arch', dest='architecture', default='amd64',\n        help='architecture (e.g. amd64)')\n    machine.add_argument('--bootloader', dest='bootloader_approach',\n        default=BOOTLOADER__AUTO, choices=_BOOTLOADER_APPROACHES,\n        help='approach to take during bootloader installation (default: %(default)s)')\n    machine.add_argument('--bootloader-force', default=False, action='store_true',\n        help='apply more force when installing bootloader (default: disabled)')\n    machine.add_argument('--hostname', default='machine', metavar='NAME',\n        help='hostname to set (default: \"%(default)s\")')\n    machine.add_argument('--openstack', dest='with_openstack', default=False, action='store_true',\n        help='prepare for use with OpenStack (default: disabled)')\n    password_options = machine.add_mutually_exclusive_group()\n    password_options.add_argument('--password', dest='root_password', metavar='PASSWORD',\n        help='root password to set (default: password log-in disabled)')\n    password_options.add_argument('--password-file', dest='root_password_file', metavar='FILE',\n        help='file to read root password from (default: password log-in disabled)')\n    machine.add_argument('--resolv-conf', metavar='FILE', default='/etc/resolv.conf',\n        help='file to copy nameserver entries from (default: %(default)s)')\n    machine.add_argument('--disk-id', dest='disk_id', metavar='ID', type=disk_id_type,\n        help='specific disk identifier to apply, e.g. 0x12345678')\n    machine.add_argument('--first-partition-uuid', dest='first_partition_uuid', metavar='UUID', type=uuid_type,\n        help='specific UUID to apply to first partition, e.g. c1b9d5a2-f162-11cf-9ece-0020afc76f16')\n    machine.add_argument('--machine-id', dest='machine_id', metavar='ID', type=machine_id_type,\n        help='specific machine identifier to apply, e.g. c1b9d5a2f16211cf9ece0020afc76f16')\n\n    script_dirs = parser.add_argument_group('script integration')\n    script_dirs.add_argument('--scripts-pre', dest='scripts_dir_pre', metavar='DIRECTORY',\n        help='scripts to run prior to chrooting phase, in alphabetical order')\n    script_dirs.add_argument('--scripts-chroot', dest='scripts_dir_chroot', metavar='DIRECTORY',\n        help='scripts to run during chrooting phase, in alphabetical order')\n    script_dirs.add_argument('--scripts-post', dest='scripts_dir_post', metavar='DIRECTORY',\n        help='scripts to run after chrooting phase, in alphabetical order')\n\n    commands = parser.add_argument_group('command names')\n    commands.add_argument('--grub2-install', metavar='COMMAND', dest='command_grub2_install',\n        help='override grub2-install command')\n\n    general = parser.add_argument_group('general configuration')\n    add_general_directory_bootstrapping_options(general)\n\n    distros = parser.add_subparsers(title='subcommands (choice of distribution)',\n            description='Run \"%(prog)s DISTRIBUTION --help\" for details '\n                    'on options specific to that distribution.',\n            metavar='DISTRIBUTION', help='choice of distribution, pick from:')\n\n\n    for strategy_clazz in (\n            ArchStrategy,\n            DebianStrategy,\n            GentooStrategy,\n            UbuntuStrategy,\n            ):\n        strategy_clazz.add_parser_to(distros)\n\n\n    parser.add_argument('target_path', metavar='DEVICE',\n        help='block device to install to')\n\n    options = parser.parse_args()\n\n    messenger = Messenger(options.verbosity, is_color_wanted(options))\n    run_handle_errors(_main__level_three, messenger, options)\n\n\ndef main():\n    try:\n        fix_output_encoding()\n        _main__level_two()\n    except KeyboardInterrupt:\n        sys.exit(128 + signal.SIGINT)\n\n\nif __name__ == '__main__':\n    main()\n",
    "uncovered_lines": [
      4,
      5,
      6,
      8,
      10,
      11,
      13,
      15,
      16,
      18,
      19,
      20,
      21,
      22,
      23,
      28,
      29,
      30,
      32,
      43,
      44,
      47,
      48,
      50,
      52,
      53,
      55,
      57,
      59,
      61,
      75,
      86,
      87,
      89,
      90,
      91,
      92,
      93,
      94,
      95,
      96,
      97,
      99,
      100,
      102,
      105,
      106,
      112,
      114,
      116,
      117,
      119,
      122,
      124,
      126,
      128,
      129,
      131,
      133,
      135,
      137,
      139,
      142,
      143,
      145,
      147,
      150,
      151,
      154,
      155,
      157,
      163,
      169,
      172,
      175,
      177,
      178,
      181,
      182,
      183,
      184,
      185,
      186,
      189,
      190
    ]
  },
  {
    "file_path": "image_bootstrap/engine.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport errno\nimport os\nimport pwd\nimport stat\nimport subprocess\nimport tempfile\nimport time\nfrom contextlib import suppress\nfrom textwrap import dedent\n\nfrom directory_bootstrap.shared.byte_size import format_byte_size\nfrom directory_bootstrap.shared.commands import (\n        COMMAND_BLKID, COMMAND_BLOCKDEV, COMMAND_CHMOD, COMMAND_CHROOT,\n        COMMAND_CP, COMMAND_EXTLINUX, COMMAND_FIND, COMMAND_INSTALL_MBR,\n        COMMAND_KPARTX, COMMAND_MKDIR, COMMAND_MKFS_EXT4, COMMAND_MOUNT,\n        COMMAND_PARTED, COMMAND_PARTPROBE, COMMAND_RM, COMMAND_RMDIR,\n        COMMAND_SED, COMMAND_TUNE2FS, EXIT_COMMAND_NOT_FOUND,\n        check_call__keep_trying, check_for_commands, find_command)\nfrom directory_bootstrap.shared.mount import COMMAND_UMOUNT, try_unmounting\nfrom directory_bootstrap.shared.namespace import (\n        set_hostname, unshare_current_process)\nfrom directory_bootstrap.shared.resolv_conf import filter_copy_resolv_conf\nfrom image_bootstrap.boot_loaders.grub2 import (\n        BOOTLOADER__CHROOT_GRUB2, BOOTLOADER__CHROOT_GRUB2__DEVICE,\n        BOOTLOADER__CHROOT_GRUB2__DRIVE, BOOTLOADER__HOST_GRUB2__DEVICE,\n        BOOTLOADER__HOST_GRUB2__DRIVE, GrubTwoInstaller)\nfrom image_bootstrap.mount import MountFinder\nfrom image_bootstrap.types.uuid import require_valid_uuid\n\nBOOTLOADER__AUTO = 'auto'\nBOOTLOADER__HOST_EXTLINUX = 'host-extlinux'\nBOOTLOADER__NONE = 'none'\n\n\nBOOTLOADER__ANY_GRUB = (\n        BOOTLOADER__CHROOT_GRUB2__DEVICE,\n        BOOTLOADER__CHROOT_GRUB2__DRIVE,\n        BOOTLOADER__HOST_GRUB2__DEVICE,\n        BOOTLOADER__HOST_GRUB2__DRIVE,\n        )\nBOOTLOADER__HOST_GRUB2 = (\n        BOOTLOADER__HOST_GRUB2__DEVICE,\n        BOOTLOADER__HOST_GRUB2__DRIVE,\n        )\n\n\n_MOUNTPOINT_PARENT_DIR = '/mnt'\n_CHROOT_SCRIPT_TARGET_DIR = 'root/chroot-scripts/'\n\n_NON_DISK_MOUNT_TASKS = (\n        ('devtmpfs', ['-t', 'devtmpfs'], 'dev'),\n        ('devpts', ['-t', 'devpts'], 'dev/pts'),\n        ('tmpfs', ['-t', 'tmpfs', '-o', 'mode=1777'], 'dev/shm'),\n        ('proc', ['-t', 'proc'], 'proc'),\n        ('sysfs', ['-t', 'sysfs'], 'sys'),\n        )\n\n_DISK_ID_OFFSET = 440\n_DISK_ID_COUNT_BYTES = 4\n\n_CONSOLE_CONFIG = 'console=tty0 console=ttyS0,115200'\n\n\nclass _script_filename_telling_exceptions(object):\n    \"\"\"\n    Extends raised exceptions by filename of the causing script\n    \"\"\"\n    def __init__(self, abs_script_filename):\n        self._abs_script_filename = abs_script_filename\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_val is not None:\n            exc_val._ib_abs_script_filename = self._abs_script_filename\n\n\nclass MachineConfig(object):\n    def __init__(self,\n            hostname,\n            architecture,\n            root_password,\n            abs_root_password_file,\n            abs_etc_resolv_conf,\n            disk_id,\n            first_partition_uuid,\n            machine_id,\n            bootloader_approach,\n            bootloader_force,\n            with_openstack,\n            ):\n        self.hostname = hostname\n        self.architecture = architecture\n        self.root_password = root_password\n        self.abs_root_password_file = abs_root_password_file\n        self.abs_etc_resolv_conf = abs_etc_resolv_conf\n        self.disk_id = disk_id\n        self.first_partition_uuid = first_partition_uuid\n        self.machine_id = machine_id\n        self.bootloader_approach = bootloader_approach\n        self.bootloader_force = bootloader_force\n        self.with_openstack = with_openstack\n\n\nclass BootstrapEngine(object):\n    def __init__(self,\n            messenger,\n            executor,\n            machine_config,\n            abs_scripts_dir_pre,\n            abs_scripts_dir_chroot,\n            abs_scripts_dir_post,\n            abs_target_path,\n            command_grub2_install,\n            ):\n        self._messenger = messenger\n        self._executor = executor\n\n        assert isinstance(machine_config, MachineConfig)\n        self._config = machine_config\n\n        self._abs_scripts_dir_pre = abs_scripts_dir_pre\n        self._abs_scripts_dir_chroot = abs_scripts_dir_chroot\n        self._abs_scripts_dir_post = abs_scripts_dir_post\n        self._abs_target_path = abs_target_path\n\n        self._command_grub2_install = command_grub2_install\n\n        self._abs_mountpoint = None\n        self._abs_first_partition_device = None\n\n        self._distro = None\n\n    def set_distro(self, distro):\n        distro.set_chroot_env_prototype(self.make_environment(tell_mountpoint=False))\n        self._distro = distro\n\n    def check_release(self):\n        return self._distro.check_release()\n\n    def select_bootloader(self):\n        if self._config.bootloader_approach == BOOTLOADER__AUTO:\n            self._config.bootloader_approach = self._distro.select_bootloader()\n            self._messenger.info('Selected approach \"%s\" for bootloader installation.'\n                    % self._config.bootloader_approach)\n\n    def get_commands_to_check_for(self):\n        res = list(self._distro.get_commands_to_check_for())\n        res += [\n                COMMAND_BLKID,\n                COMMAND_BLOCKDEV,\n                COMMAND_CHMOD,\n                COMMAND_CHROOT,\n                COMMAND_CP,\n                COMMAND_FIND,\n                COMMAND_KPARTX,\n                COMMAND_MKDIR,\n                COMMAND_MKFS_EXT4,\n                COMMAND_MOUNT,\n                COMMAND_PARTED,\n                COMMAND_PARTPROBE,\n                COMMAND_RM,\n                COMMAND_RMDIR,\n                COMMAND_SED,\n                COMMAND_TUNE2FS,\n                COMMAND_UMOUNT,\n                self._command_grub2_install,\n                ]\n\n        if self._config.bootloader_approach == BOOTLOADER__HOST_EXTLINUX:\n            res += [\n                    COMMAND_EXTLINUX,\n                    COMMAND_INSTALL_MBR,\n                    ]\n\n        return res\n\n    def _protect_against_grub_legacy(self, command):\n        output = subprocess.check_output([command, '--version'])\n        if b'GRUB GRUB 0.' in output:\n            raise ValueError('Command \"%s\" is GRUB legacy while GRUB 2 is needed. '\n                    'Please install GRUB 2 or pass --grub2-install .. on the command line.' \\\n                    % command)\n\n    def detect_grub2_install(self):\n        if self._command_grub2_install:\n            return  # Explicit command given, no detection needed\n\n        if self._config.bootloader_approach not in BOOTLOADER__HOST_GRUB2:\n            return  # Host grub2-install not used, no detection needed\n\n        COMMAND_GRUB_INSTALL = 'grub-install'\n        COMMAND_GRUB2_INSTALL = 'grub2-install'\n\n        self._command_grub2_install = COMMAND_GRUB2_INSTALL\n        try:\n            find_command(self._command_grub2_install)\n        except OSError as e:\n            if e.errno != EXIT_COMMAND_NOT_FOUND:\n                raise\n\n            self._command_grub2_install = COMMAND_GRUB_INSTALL\n            try:\n                find_command(self._command_grub2_install)\n            except OSError as e:\n                if e.errno != EXIT_COMMAND_NOT_FOUND:\n                    raise\n\n                # NOTE: consecutive search for \"grub-install\" will fail and\n                #       be reported, so we don't need to raise here\n                return\n\n            self._protect_against_grub_legacy(self._command_grub2_install)\n\n    def check_for_commands(self):\n        check_for_commands(self._messenger, self.get_commands_to_check_for())\n\n    def check_target_block_device(self):\n        self._messenger.info('Checking if \"%s\" is a block device...' % self._abs_target_path)\n        props = os.stat(self._abs_target_path)\n        if not stat.S_ISBLK(props.st_mode):\n            raise OSError(errno.ENOTBLK, 'Not a block device: \"%s\"' % self._abs_target_path)\n\n    def check_architecture(self):\n        self._messenger.info('Checking for known unsupported architecture/machine combination...')\n        self._config.architecture = self._distro.check_architecture(self._config.architecture)\n        assert self._config.architecture is not None\n\n    def _script_should_be_run(self, basename):\n        if basename.startswith('.'):\n            return False\n        elif basename.endswith('~'):\n            return False\n        return True\n\n    def check_script_permissions(self):\n        infos_produced = False\n\n        good_uids = set()\n        good_uids.add(os.geteuid())\n        try:\n            sudo_uid = int(os.environ['SUDO_UID'])\n        except (KeyError, ValueError):\n            pass\n        else:\n            good_uids.add(sudo_uid)\n\n        for category, abs_scripts_dir in (\n                ('pre-chroot', self._abs_scripts_dir_pre),\n                ('chroot', self._abs_scripts_dir_chroot),\n                ('post-chroot', self._abs_scripts_dir_post),\n                ):\n            if abs_scripts_dir is None:\n                continue\n\n            self._messenger.info('Checking %s scripts directory permissions...' % category)\n            infos_produced = True\n\n            props = os.lstat(abs_scripts_dir)\n            if stat.S_ISLNK(props.st_mode):\n                raise OSError(errno.ENOTDIR, 'Directory \"%s\" is a symlink. Only true directories are supported.' % abs_scripts_dir)\n\n            if not stat.S_ISDIR(props.st_mode):\n                raise OSError(errno.ENOTDIR, 'Directory \"%s\" is not a directory' % abs_scripts_dir)\n\n            if props.st_mode & (stat.S_IWGRP | stat.S_IWOTH):\n                raise OSError(errno.EPERM, 'Directory \"%s\" is writable to users other than its owner' % abs_scripts_dir)\n\n            if props.st_uid not in good_uids:\n                user_info = ' or '.join(('user %s/%d' % (pwd.getpwuid(uid).pw_name, uid) for uid in sorted(good_uids)))\n                raise OSError(errno.EPERM, 'Directory \"%s\" is not owned by %s' % (abs_scripts_dir, user_info))\n\n            self._messenger.info('Checking %s scripts for executability...' % category)\n            infos_produced = True\n\n            for basename in sorted(os.listdir(abs_scripts_dir)):\n                if not self._script_should_be_run(basename):\n                    continue\n\n                abs_filename = os.path.join(abs_scripts_dir, basename)\n                if not os.access(abs_filename, os.X_OK):\n                    raise OSError(errno.EACCES, 'Permission denied, file \"%s\" not executable' % abs_filename)\n\n        if infos_produced:\n            self._messenger.info_gap()\n\n    def _unshare(self):\n        unshare_current_process(self._messenger)\n        set_hostname(self._config.hostname)\n\n    def _check_device_size(self):\n        self._messenger.info('Checking size of \"%s\"...' % self._abs_target_path)\n        blockdev_output = self._executor.check_output([\n                COMMAND_BLOCKDEV,\n                '--getsize64',\n                self._abs_target_path,\n                ])\n        size_bytes_found = int(blockdev_output)\n        size_bytes_needed = self._distro.get_minimum_size_bytes()\n        if size_bytes_found < size_bytes_needed:\n            raise OSError(errno.ENOSPC, 'Device \"%s\" is %s in size, %s or more needed.' % (\n                    self._abs_target_path,\n                    format_byte_size(size_bytes_found),\n                    format_byte_size(size_bytes_needed),\n                    ))\n\n    def _partition_device(self):\n        self._messenger.info('Partitioning \"%s\"...' % self._abs_target_path)\n        cmd_mklabel = [\n                COMMAND_PARTED,\n                '--script',\n                self._abs_target_path,\n                'mklabel', 'msdos',\n                ]\n        self._executor.check_call(cmd_mklabel)\n\n        # Make existing partition devices leave\n        check_call__keep_trying(self._executor, [\n                COMMAND_PARTPROBE,\n                self._abs_target_path,\n                ])\n\n        cmd_mkpart = [\n                COMMAND_PARTED,\n                '--script',\n                '--align', 'optimal',\n                self._abs_target_path,\n                'mkpart',\n                'primary', 'ext4', '1', '100%',\n                ]\n        self._executor.check_call(cmd_mkpart)\n\n        cmd_boot_flag = [\n                COMMAND_PARTED,\n                '--script',\n                self._abs_target_path,\n                'set', '1', 'boot', 'on',\n                ]\n        time.sleep(1)  # increase chances of first call working, e.g. with LVM volumes\n        check_call__keep_trying(self._executor, cmd_boot_flag)\n\n    def _create_partition_devices(self):\n        self._messenger.info('Activating partition devices...')\n        cmd_list = [\n                COMMAND_KPARTX,\n                '-l',\n                self._abs_target_path,\n                ]\n        output = self._executor.check_output(cmd_list)\n        device_name = output.split(b'\\n')[0].split(b' : ')[0].decode('utf-8')\n        self._abs_first_partition_device = '/dev/mapper/%s' % device_name\n\n        # NOTE: Ubuntu 15.04 does not have \"-u\" (issue #30)\n        #       So we try -u first, then -a if -u failed\n        try:\n            self._executor.check_call([COMMAND_KPARTX,\n                    '-u', self._abs_target_path,\n                    ])\n        except subprocess.CalledProcessError:\n            self._executor.check_call([COMMAND_KPARTX,\n                    '-a', self._abs_target_path,\n                    ])\n\n        for i in range(3):\n            if os.path.exists(self._abs_first_partition_device):\n                break\n            time.sleep(1)\n        else:\n            raise OSError(errno.ENOENT, \"No such block device file: '%s'\" \\\n                    % self._abs_first_partition_device)\n\n    def _format_partitions(self):\n        self._messenger.info('Creating file system on \"%s\"...' % self._abs_first_partition_device)\n        cmd = [\n                COMMAND_MKFS_EXT4,\n                '-F',\n        ]\n\n        if self._config.bootloader_approach == BOOTLOADER__HOST_EXTLINUX:\n            self._messenger.warn('Creating ext4 file system with '\n                    'feature \"64bit\" disabled '\n                    'to ensure bootability with extlinux.')\n            self._messenger.warn('Please see '\n                    'https://github.com/hartwork/image-bootstrap/issues/44'\n                    ' for details.')\n            cmd += ['-O', '^64bit']\n\n        cmd += self._distro.get_extra_mkfs_ext4_options()\n\n        cmd += [\n                self._abs_first_partition_device,\n                ]\n        self._executor.check_call(cmd)\n\n    def _mkdir_mountpount(self):\n        self._abs_mountpoint = tempfile.mkdtemp(dir=_MOUNTPOINT_PARENT_DIR)\n        self._messenger.info('Creating directory \"%s\"...' % self._abs_mountpoint)\n        self._distro.set_mountpoint(self._abs_mountpoint)\n\n    def _mkdir_mountpount_etc(self):\n        abs_dir = os.path.join(self._abs_mountpoint, 'etc')\n        self._messenger.info('Creating directory \"%s\"...' % abs_dir)\n        os.mkdir(abs_dir, 0o755)\n\n    def _mount_disk_chroot_mounts(self):\n        self._messenger.info('Mounting partitions...')\n        cmd = [\n                COMMAND_MOUNT,\n                self._abs_first_partition_device,\n                self._abs_mountpoint,\n                ]\n        self._executor.check_call(cmd)\n\n    def run_directory_bootstrap(self):\n        return self._distro.run_directory_bootstrap(\n                self._config.architecture,\n                self._config.bootloader_approach,\n                )\n\n    def _unmount_directory_bootstrap_leftovers(self):\n        mounts = MountFinder()\n        mounts.load()\n        for abs_mount_point in reversed(list(mounts.below(self._abs_mountpoint))):\n            self._try_unmounting(abs_mount_point)\n\n    def _set_root_password_inside_chroot(self):\n        self._messenger.info('Setting root password...')\n        if self._config.root_password is None:\n            return\n\n        cmd = [\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                'chpasswd',\n                ]\n        env = self.make_environment(tell_mountpoint=False)\n        self._messenger.announce_command(cmd)\n        p = subprocess.Popen(cmd, stdin=subprocess.PIPE, env=env)\n        p.stdin.write(('root:%s' % self._config.root_password).encode('utf-8'))\n        p.stdin.close()\n        p.wait()\n        if p.returncode:\n            raise subprocess.CalledProcessError(p.returncode, cmd)\n\n    def _set_first_partition_uuid(self):\n        if not self._config.first_partition_uuid:\n            return\n\n        self._messenger.info('Setting first partition UUID to %s...' % self._config.first_partition_uuid)\n        cmd = [COMMAND_TUNE2FS,\n                '-U', self._config.first_partition_uuid,\n                self._abs_first_partition_device,\n                ]\n        self._executor.check_call(cmd)\n\n    def _gather_first_partition_uuid(self):\n        cmd_blkid = [\n                COMMAND_BLKID,\n                '-o', 'value',\n                '-s', 'UUID',\n                self._abs_first_partition_device,\n                ]\n        output = self._executor.check_output(cmd_blkid)\n        first_partition_uuid = output.rstrip().decode('utf-8')\n        require_valid_uuid(first_partition_uuid)\n        self._config.first_partition_uuid = first_partition_uuid\n\n    def _create_etc_fstab(self):\n        filename = os.path.join(self._abs_mountpoint, 'etc', 'fstab')\n        self._messenger.info('Writing file \"%s\"...' % filename)\n        f = open(filename, 'w')\n        print('/dev/disk/by-uuid/%s / auto defaults 0 1' % self._config.first_partition_uuid, file=f)\n        f.close()\n\n    def _create_etc_machine_id(self):\n        if self._config.machine_id:\n            etc_machine_id = os.path.join(self._abs_mountpoint, 'etc/machine-id')\n            self._messenger.info('Writing file \"%s\"...' % etc_machine_id)\n            with open(etc_machine_id, 'w') as f:\n                print(self._config.machine_id, file=f)\n\n    def _configure_hostname(self):\n        self._distro.configure_hostname(self._config.hostname)\n\n    def create_network_configuration(self):\n        use_mtu_tristate = True if self._config.with_openstack else None\n        return self._distro.create_network_configuration(use_mtu_tristate)\n\n    def _fix_grub_cfg_root_device(self):\n        self._messenger.info('Post-processing GRUB config...')\n        cmd_sed = [\n                COMMAND_SED,\n                r's,root=[^ ]\\+,root=UUID=%s,g' % self._config.first_partition_uuid,\n                '-i', os.path.join(self._abs_mountpoint, 'boot', 'grub', 'grub.cfg'),\n                ]\n        self._executor.check_call(cmd_sed)\n\n    def _run_scripts_from(self, abs_scripts_dir, env):\n        for basename in sorted(os.listdir(abs_scripts_dir)):\n            if not self._script_should_be_run(basename):\n                continue\n\n            abs_script_filename = os.path.join(abs_scripts_dir, basename)\n            cmd = [abs_script_filename]\n            with _script_filename_telling_exceptions(abs_script_filename):\n                self._executor.check_call(cmd, env=env.copy())\n\n    def make_environment(self, tell_mountpoint):\n        env = os.environ.copy()\n        for key in ('LANG', 'LANGUAGE', 'TMPDIR'):\n            env.pop(key, None)\n\n        assert self._config.hostname is not None\n        env.update({\n                'HOSTNAME': self._config.hostname,  # for compatibility to grml-debootstrap\n                'IB_HOSTNAME': self._config.hostname,\n                'LC_ALL': 'C',\n                })\n\n        if tell_mountpoint:\n            assert self._abs_mountpoint is not None\n            env.update({\n                    'IB_ROOT': self._abs_mountpoint,\n                    'MNTPOINT': self._abs_mountpoint,  # for compatibility to grml-debootstrap\n                    })\n\n        return env\n\n    def _run_pre_scripts(self):\n        self._messenger.info('Running pre-chroot scripts...')\n        env = self.make_environment(tell_mountpoint=True)\n        if self._abs_scripts_dir_pre:\n            self._run_scripts_from(self._abs_scripts_dir_pre, env)\n\n    def _mount_nondisk_chroot_mounts(self):\n        self._messenger.info('Mounting non-disk file systems...')\n        for source, options, target in _NON_DISK_MOUNT_TASKS:\n            cmd = [\n                    COMMAND_MOUNT,\n                    source,\n                    ] \\\n                    + options \\\n                    + [\n                        os.path.join(self._abs_mountpoint, target),\n                    ]\n            self._executor.check_call(cmd)\n\n    def get_chroot_command_grub2_install(self):\n        return self._distro.get_chroot_command_grub2_install()\n\n    def _ensure_chroot_has_grub2_installed(self):\n        self._distro.ensure_chroot_has_grub2_installed()\n\n    def _install_bootloader__extlinux(self):\n        assert self._config.first_partition_uuid\n        d = {\n            'distro_key': self._distro.DISTRO_KEY,\n            'distro_name_long': self._distro.DISTRO_NAME_LONG,\n            'kernel_extra': (' %s' % _CONSOLE_CONFIG) if self._config.with_openstack else '',\n            'uuid': self._config.first_partition_uuid,\n            'vmlinuz': self._distro.get_vmlinuz_path(),\n            'initramfs': self._distro.get_initramfs_path(),\n        }\n\n        boot_extlinux = os.path.join(self._abs_mountpoint, 'boot/extlinux/')\n        extlinux_conf = os.path.join(boot_extlinux, 'extlinux.conf')\n\n        os.makedirs(boot_extlinux)\n\n        self._messenger.info('Writing file \"%s\"...' % extlinux_conf)\n        with open(extlinux_conf, 'w') as f:\n            print(dedent(\"\"\"\\\n                    DEFAULT  %(distro_key)s\n                    TIMEOUT  1\n\n                    LABEL    %(distro_key)s\n                    SAY      Booting %(distro_name_long)s...\n                    KERNEL   %(vmlinuz)s\n                    APPEND   initrd=%(initramfs)s root=/dev/disk/by-uuid/%(uuid)s%(kernel_extra)s\n                    INITRD   %(initramfs)s\n                    \"\"\" % d), file=f)\n\n        self._messenger.info('Installing extlinux to \"%s\"...' % boot_extlinux)\n        cmd_extlinux = [\n                COMMAND_EXTLINUX,\n                '--install',\n                boot_extlinux,\n                ]\n        self._executor.check_call(cmd_extlinux)\n\n        self._messenger.info('Writing MBR of \"%s\"...' % self._abs_target_path)\n        cmd_mbr = [\n                COMMAND_INSTALL_MBR,\n                '--force',\n                self._abs_target_path,\n                ]\n        self._executor.check_call(cmd_mbr)\n\n    def _install_bootloader__grub2(self):\n        installer = GrubTwoInstaller(\n                self._messenger,\n                self._executor,\n                self._abs_target_path,\n                self._config.bootloader_approach,\n                self._config.bootloader_force,\n                self._command_grub2_install,\n                self.get_chroot_command_grub2_install(),\n                self.make_environment(tell_mountpoint=False),\n                self._abs_mountpoint,\n                )\n        installer.run()\n\n    def adjust_grub_defaults(self):\n        res = self._distro.adjust_grub_defaults(self._config.with_openstack)\n\n        if self._config.with_openstack:\n            self._messenger.info('Enabling serial console...')\n            env = self.make_environment(tell_mountpoint=False)\n            self._executor.check_call([\n                    COMMAND_CHROOT, self._abs_mountpoint,\n                    'sed',\n                    's:^\\\\(GRUB_CMDLINE_LINUX=\"[^\"]*\\\\)\":\\\\1 %s\":'\n                            % _CONSOLE_CONFIG,\n                    '-i', '/etc/default/grub',\n                    ], env=env)\n\n        return res\n\n    def generate_grub_cfg_from_inside_chroot(self):\n        return self._distro.generate_grub_cfg_from_inside_chroot()\n\n    def _adjust_initramfs_generator_config(self):\n        self._distro.adjust_initramfs_generator_config()\n\n    def generate_initramfs_from_inside_chroot(self):\n        self._messenger.info('Generating initramfs...')\n        return self._distro.generate_initramfs_from_inside_chroot()\n\n    def _create_etc_resolv_conf(self):\n        output_filename = os.path.join(self._abs_mountpoint, 'etc', 'resolv.conf')\n\n        filter_copy_resolv_conf(self._messenger, self._config.abs_etc_resolv_conf, output_filename)\n\n    def _copy_chroot_scripts(self):\n        self._messenger.info('Copying chroot scripts into chroot...')\n        abs_path_parent = os.path.join(self._abs_mountpoint, _CHROOT_SCRIPT_TARGET_DIR)\n        cmd_mkdir = [\n                COMMAND_MKDIR,\n                abs_path_parent,\n                ]\n        self._executor.check_call(cmd_mkdir)\n        for basename in os.listdir(self._abs_scripts_dir_chroot):\n            if not self._script_should_be_run(basename):\n                continue\n\n            abs_path_source = os.path.join(self._abs_scripts_dir_chroot, basename)\n            abs_path_target = os.path.join(self._abs_mountpoint, _CHROOT_SCRIPT_TARGET_DIR, basename)\n            cmd_copy = [\n                    COMMAND_CP,\n                    abs_path_source,\n                    abs_path_target,\n                    ]\n            self._executor.check_call(cmd_copy)\n            cmd_chmod = [\n                    COMMAND_CHMOD,\n                    'a+x',\n                    abs_path_target,\n                    ]\n            self._executor.check_call(cmd_chmod)\n\n    def _run_chroot_scripts(self):\n        self._messenger.info('Running chroot scripts...')\n        env = self.make_environment(tell_mountpoint=False)\n        for basename in sorted(os.listdir(self._abs_scripts_dir_chroot)):\n            if not self._script_should_be_run(basename):\n                continue\n\n            abs_script_filename = os.path.join(\n                    self._abs_scripts_dir_chroot, basename)\n            cmd_run = [\n                    COMMAND_CHROOT,\n                    self._abs_mountpoint,\n                    os.path.join('/', _CHROOT_SCRIPT_TARGET_DIR, basename),\n                    ]\n            with _script_filename_telling_exceptions(abs_script_filename):\n                self._executor.check_call(cmd_run, env=env.copy())\n\n    def _remove_chroot_scripts(self):\n        self._messenger.info('Removing chroot scripts...')\n        for basename in os.listdir(self._abs_scripts_dir_chroot):\n            if not self._script_should_be_run(basename):\n                continue\n\n            abs_path_target = os.path.join(self._abs_mountpoint, _CHROOT_SCRIPT_TARGET_DIR, basename)\n            cmd_rm = [\n                    COMMAND_RM,\n                    abs_path_target,\n                    ]\n            self._executor.check_call(cmd_rm)\n\n        abs_path_parent = os.path.join(self._abs_mountpoint, _CHROOT_SCRIPT_TARGET_DIR)\n        cmd_rmdir = [\n                COMMAND_RMDIR,\n                abs_path_parent,\n                ]\n        self._executor.check_call(cmd_rmdir)\n\n    def _try_unmounting(self, abs_path):\n        return try_unmounting(self._executor, abs_path)\n\n    def _unmount_nondisk_chroot_mounts(self):\n        self._messenger.info('Unmounting non-disk file systems...')\n        for source, options, target in reversed(_NON_DISK_MOUNT_TASKS):\n            abs_path = os.path.join(self._abs_mountpoint, target)\n            self._try_unmounting(abs_path)\n\n    def _perform_in_chroot_shipping_clean_up(self):\n        self._distro.perform_in_chroot_shipping_clean_up()\n\n    def perform_post_chroot_clean_up(self):\n        return self._distro.perform_post_chroot_clean_up()\n\n    def _run_post_scripts(self):\n        self._messenger.info('Running post-chroot scripts...')\n        env = self.make_environment(tell_mountpoint=True)\n        if self._abs_scripts_dir_post:\n            self._run_scripts_from(self._abs_scripts_dir_post, env)\n\n    def _unmount_disk_chroot_mounts(self):\n        self._messenger.info('Unmounting partitions...')\n        self._try_unmounting(self._abs_mountpoint)\n\n    def _remove_partition_devices(self):\n        self._messenger.info('Deactivating partition devices...')\n        cmd = [\n                COMMAND_KPARTX,\n                '-d',\n                self._abs_target_path,\n                ]\n        check_call__keep_trying(self._executor, cmd)\n\n    def _rmdir_mountpount(self):\n        self._messenger.info('Removing directory \"%s\"...' % self._abs_mountpoint)\n        for i in range(3):\n            try:\n                os.rmdir(self._abs_mountpoint)\n            except OSError as e:\n                if e.errno != errno.EBUSY:\n                    raise\n                time.sleep(1)\n            else:\n                break\n\n    def _set_disk_id_in_mbr(self):\n        if not self._config.disk_id:\n            return\n\n        content = self._config.disk_id.byte_sequence()\n        assert len(content) == _DISK_ID_COUNT_BYTES\n\n        self._messenger.info('Setting MBR disk identifier to %s (4 bytes)...' % str(self._config.disk_id))\n        f = open(self._abs_target_path, 'w')\n        f.seek(_DISK_ID_OFFSET)\n        f.write(content)\n        f.close()\n\n    def process_root_password(self):\n        if self._config.abs_root_password_file:\n            self._messenger.info('Reading root password from file \"%s\"...' % self._config.abs_root_password_file)\n            f = open(self._config.abs_root_password_file)\n            self._config.root_password = f.read().split('\\n')[0]\n            f.close()\n        elif self._config.root_password is not None:\n            self._messenger.warn('Using --password PASSWORD is a security risk more often than not; '\n                    'please consider using --password-file FILE, instead.')\n\n    def _install_dhcp_client(self):\n        return self._distro.install_dhcp_client()\n\n    def _install_sudo(self):\n        return self._distro.install_sudo()\n\n    def _create_sudo_nopasswd_user(self):\n        user_name = self._distro.get_cloud_username()\n        self._messenger.info('Creating user \"%s\"...' % user_name)\n        cmd = [\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                'useradd',\n                '--comment', 'Cloud-init-user',\n                '--base-dir', '/home',\n                '--create-home',\n                '--shell', '/bin/bash',\n                '--user-group', user_name,\n                ]\n        env = self.make_environment(tell_mountpoint=False)\n        self._executor.check_call(cmd, env)\n\n        self._messenger.info('Allowing user \"%s\" to call sudo with no password...' % user_name)\n        sudoers_path = os.path.join(self._abs_mountpoint, 'etc/sudoers.d/%s-nopasswd' % user_name)\n        with open(sudoers_path, 'w') as f:\n            print('%s ALL = NOPASSWD: ALL' % user_name, file=f)\n            os.fchmod(f.fileno(), 0o440)\n\n    def _install_cloud_init_and_friends(self):\n        self._distro.install_cloud_init_and_friends()\n\n    def _configure_cloud_init_and_friends(self):\n        self._distro.adjust_etc_cloud_cfg()\n\n        cloud_cfg_d_file_path = os.path.join(self._abs_mountpoint,\n                self._distro.get_cloud_init_datasource_cfg_path().lstrip('/'))\n        self._messenger.info('Writing file \"%s\"...' % cloud_cfg_d_file_path)\n        with open(cloud_cfg_d_file_path, 'w') as f:\n            print(dedent(\"\"\"\\\n                    # generated by image-bootstrap\n                    datasource_list: [ConfigDrive, NoCloud, OpenStack, Ec2]\n                    \"\"\"), file=f)\n\n    def _install_sshd(self):\n        return self._distro.install_sshd()\n\n    def _delete_sshd_keys(self):\n        # Even with new keys generated by cloud-init, it would\n        # be cool to not have the current keys go into the image.\n        #\n        # May not affect all distros, some may not generate them\n        # before the SSH server is started, e.g. Arch\n        self._messenger.info('Deleting SSH server keys (if any)...')\n        cmd = [\n                COMMAND_FIND,\n                os.path.join(self._abs_mountpoint, 'etc/ssh/'),\n                '-type', 'f',\n                '-name', 'ssh_host_*key*',\n                '-delete', '-print',\n                ]\n        self._executor.check_call(cmd)\n\n    def _clean_machine_id(self):\n        dbus_machine_id = os.path.join(self._abs_mountpoint, 'var/lib/dbus/machine-id')\n        try:\n            os.remove(dbus_machine_id)\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise\n        else:\n            self._messenger.info('Removing file \"%s\"...' % dbus_machine_id)\n\n        if not self._config.machine_id:  # i.e. keep if explicit ID requested\n            etc_machine_id = os.path.join(self._abs_mountpoint, 'etc/machine-id')\n            self._messenger.info('Truncating file \"%s\"...' % etc_machine_id)\n            with open(etc_machine_id, 'w') as f:\n                f.truncate(0)\n\n    def _make_openstack_services_autostart(self):\n        return self._distro.make_openstack_services_autostart()\n\n    def _disable_clearing_tty1(self):\n        noclear_file_path = os.path.join(self._abs_mountpoint, 'etc/systemd/system/getty@tty1.service.d/noclear.conf')\n        self._messenger.info('Disabling clearing of tty1 (file \"%s\")...' % noclear_file_path)\n        os.makedirs(os.path.dirname(noclear_file_path), 0o755)\n        with open(noclear_file_path, 'w') as f:\n            print(dedent(\"\"\"\\\n                    [Service]\n                    TTYVTDisallocate=no\n                    \"\"\"), file=f)\n\n    def _disable_pcspkr_autoloading(self):\n        abs_modprobe_d = os.path.join(self._abs_mountpoint, 'etc/modprobe.d')\n        with suppress(FileExistsError):\n            os.mkdir(abs_modprobe_d, 0o755)\n\n        file_name = os.path.join(abs_modprobe_d, 'pcspkr_no_autoload.conf')\n        self._messenger.info('Disabling auto-loading of pcspkr kernel module...')\n        with open(file_name, 'w') as f:\n            print(dedent(\"\"\"\\\n                # disable auto-loading of pcspkr module, by image-bootstrap\n                blacklist pcspkr\n                \"\"\"), file=f)\n\n    def _install_acpid_unless_using_systemd(self):\n        if not self._distro.uses_systemd():\n            return self._distro.install_acpid()\n\n    def _allow_autostart_of_services(self, allow):\n        # The idea is to avoid starting services in the chroot\n        # that we would only need to kill one way or another\n        self._distro.allow_autostart_of_services(allow)\n\n    def _prepare_installation_of_packages(self):\n        self._distro.prepare_installation_of_packages()\n\n    def _install_kernel(self):\n        self._distro.install_kernel()\n\n    def _turn_etc_resolv_conf_to_systemd_resolved(self):\n        self._messenger.info('Handing /etc/resolv.conf over to systemd-resolved...')\n        os.remove(os.path.join(self._abs_mountpoint, 'etc', 'resolv.conf'))\n        env = self.make_environment(tell_mountpoint=False)\n        self._executor.check_call([\n                COMMAND_CHROOT, self._abs_mountpoint,\n                'ln', '-s', '/run/systemd/resolve/resolv.conf', '/etc/resolv.conf',\n                ], env=env)\n\n    def run(self):\n        self._unshare()\n        self._check_device_size()\n        self._partition_device()\n        self._set_disk_id_in_mbr()\n        self._create_partition_devices()\n        try:\n            self._format_partitions()\n\n            if self._config.first_partition_uuid:\n                self._set_first_partition_uuid()\n            else:\n                self._gather_first_partition_uuid()\n            assert self._config.first_partition_uuid\n\n            self._mkdir_mountpount()\n            try:\n                self._mount_disk_chroot_mounts()\n                try:\n                    self._mkdir_mountpount_etc()\n                    self._configure_hostname()  # first time\n                    self._create_etc_resolv_conf()  # first time\n                    try:\n                        self.run_directory_bootstrap()\n                    finally:\n                        self._unmount_directory_bootstrap_leftovers()\n                    self._configure_hostname()  # re-write\n                    self._create_etc_resolv_conf()  # re-write\n                    self._create_etc_fstab()\n                    self._create_etc_machine_id()  # potentially re-write\n                    self._run_pre_scripts()\n                    if self._config.bootloader_approach in BOOTLOADER__HOST_GRUB2:\n                        self._install_bootloader__grub2()\n                    elif self._config.bootloader_approach == BOOTLOADER__HOST_EXTLINUX:\n                        self._install_bootloader__extlinux()\n                    self._mount_nondisk_chroot_mounts()\n                    try:\n                        self._allow_autostart_of_services(False)\n                        self._set_root_password_inside_chroot()\n                        self._prepare_installation_of_packages()\n\n                        # NOTE: Kernel is configured/installed early to allow other\n                        #       packages to run their checks on the kernel configuration\n                        #       with the actual kernel configuration\n                        self._install_kernel()\n\n                        if self._config.bootloader_approach in BOOTLOADER__ANY_GRUB:\n                            # Need grub2-mkconfig in any case\n                            self._ensure_chroot_has_grub2_installed()\n\n                        if self._config.bootloader_approach in BOOTLOADER__CHROOT_GRUB2:\n                            self._install_bootloader__grub2()\n\n                        if self._config.with_openstack:\n                            # Essentials\n                            self._install_dhcp_client()\n                            self._install_sudo()\n                            self._install_cloud_init_and_friends()\n                            self._configure_cloud_init_and_friends()\n                            self._install_sshd()\n                            self._make_openstack_services_autostart()\n\n                            # Goodies\n                            self._disable_clearing_tty1()\n                            self._disable_pcspkr_autoloading()\n                            self._install_acpid_unless_using_systemd()\n                        # elif with vagrant support:\n                        #   ...\n                        #   self._install_sudo()\n                        #   self._create_sudo_nopasswd_user()\n                        #   ...\n\n                        self.create_network_configuration()  # after DHCP client install\n\n                        self._adjust_initramfs_generator_config()\n                        self.generate_initramfs_from_inside_chroot()\n\n                        if self._config.bootloader_approach in BOOTLOADER__ANY_GRUB:\n                            self.adjust_grub_defaults()\n                            self._messenger.info('Generating GRUB configuration...')\n                            self.generate_grub_cfg_from_inside_chroot()\n                            self._fix_grub_cfg_root_device()\n\n                        if self._abs_scripts_dir_chroot:\n                            self._copy_chroot_scripts()\n                            try:\n                                self._run_chroot_scripts()\n                            finally:\n                                self._remove_chroot_scripts()\n\n                        if self._config.with_openstack:\n                            # Essentials (that better go last)\n                            self._delete_sshd_keys()\n                            self._clean_machine_id()\n                            self._perform_in_chroot_shipping_clean_up()\n\n                            if self._distro.uses_systemd_resolved(self._config.with_openstack):\n                                # Cannot go early, breaks chroot connectivity\n                                self._turn_etc_resolv_conf_to_systemd_resolved()\n\n                        self._allow_autostart_of_services(True)\n                    finally:\n                        self._unmount_nondisk_chroot_mounts()\n                    self.perform_post_chroot_clean_up()\n                    self._run_post_scripts()\n                finally:\n                    self._unmount_disk_chroot_mounts()\n            finally:\n                self._rmdir_mountpount()\n        finally:\n            self._remove_partition_devices()\n",
    "uncovered_lines": [
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      16,
      17,
      24,
      25,
      27,
      28,
      32,
      33,
      35,
      36,
      37,
      40,
      46,
      52,
      53,
      55,
      63,
      64,
      66,
      69,
      73,
      74,
      76,
      79,
      80,
      81,
      84,
      85,
      98,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      107,
      108,
      111,
      112,
      122,
      123,
      125,
      126,
      128,
      129,
      130,
      131,
      133,
      135,
      136,
      138,
      140,
      141,
      142,
      144,
      145,
      147,
      148,
      149,
      150,
      153,
      154,
      155,
      176,
      177,
      182,
      184,
      185,
      186,
      187,
      191,
      192,
      193,
      195,
      196,
      198,
      199,
      201,
      202,
      203,
      204,
      205,
      206,
      208,
      209,
      210,
      211,
      212,
      213,
      217,
      219,
      221,
      222,
      224,
      225,
      226,
      227,
      228,
      230,
      231,
      232,
      233,
      235,
      236,
      237,
      238,
      239,
      240,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      252,
      254,
      259,
      260,
      262,
      263,
      265,
      266,
      267,
      269,
      270,
      272,
      273,
      275,
      276,
      277,
      279,
      280,
      282,
      283,
      284,
      286,
      287,
      288,
      290,
      291,
      293,
      294,
      295,
      297,
      298,
      299,
      304,
      305,
      306,
      307,
      313,
      314,
      315,
      321,
      324,
      329,
      337,
      339,
      345,
      346,
      348,
      349,
      350,
      355,
      356,
      357,
      361,
      362,
      365,
      366,
      370,
      371,
      372,
      373,
      375,
      378,
      379,
      380,
      385,
      386,
      389,
      392,
      394,
      396,
      399,
      401,
      402,
      403,
      404,
      406,
      407,
      408,
      409,
      411,
      412,
      413,
      418,
      420,
      421,
      426,
      427,
      428,
      429,
      430,
      432,
      433,
      434,
      435,
      437,
      442,
      443,
      444,
      445,
      446,
      447,
      448,
      449,
      451,
      452,
      453,
      455,
      456,
      460,
      462,
      463,
      469,
      470,
      471,
      472,
      474,
      475,
      476,
      477,
      478,
      479,
      481,
      482,
      483,
      484,
      485,
      486,
      488,
      489,
      491,
      492,
      493,
      495,
      496,
      497,
      502,
      504,
      505,
      506,
      507,
      509,
      510,
      511,
      512,
      514,
      515,
      516,
      517,
      519,
      520,
      526,
      527,
      528,
      533,
      535,
      536,
      537,
      538,
      539,
      541,
      542,
      543,
      544,
      552,
      554,
      555,
      557,
      558,
      560,
      561,
      562,
      571,
      572,
      574,
      576,
      577,
      578,
      589,
      590,
      595,
      597,
      598,
      603,
      605,
      606,
      617,
      619,
      620,
      622,
      623,
      624,
      625,
      633,
      635,
      636,
      638,
      639,
      641,
      642,
      643,
      645,
      646,
      648,
      650,
      651,
      652,
      653,
      657,
      658,
      659,
      660,
      662,
      663,
      664,
      669,
      670,
      675,
      677,
      678,
      679,
      680,
      681,
      682,
      684,
      686,
      691,
      692,
      694,
      695,
      696,
      697,
      698,
      700,
      701,
      705,
      707,
      708,
      712,
      714,
      715,
      717,
      718,
      719,
      720,
      721,
      723,
      724,
      726,
      727,
      729,
      730,
      731,
      732,
      733,
      735,
      736,
      737,
      739,
      740,
      741,
      746,
      748,
      749,
      750,
      751,
      752,
      753,
      754,
      755,
      756,
      758,
      760,
      761,
      762,
      764,
      765,
      767,
      768,
      769,
      770,
      771,
      773,
      774,
      775,
      776,
      777,
      778,
      779,
      780,
      783,
      784,
      786,
      787,
      789,
      790,
      791,
      792,
      802,
      803,
      805,
      806,
      807,
      808,
      809,
      811,
      812,
      814,
      815,
      817,
      819,
      820,
      821,
      826,
      827,
      829,
      835,
      836,
      843,
      845,
      846,
      847,
      848,
      849,
      850,
      851,
      853,
      855,
      856,
      857,
      858,
      859,
      861,
      862,
      864,
      865,
      866,
      867,
      868,
      869,
      874,
      875,
      876,
      877,
      879,
      880,
      881,
      882,
      887,
      888,
      889,
      891,
      894,
      896,
      897,
      899,
      900,
      902,
      903,
      904,
      905,
      906,
      911,
      912,
      913,
      914,
      915,
      916,
      917,
      918,
      920,
      921,
      923,
      924,
      926,
      927,
      928,
      929,
      930,
      931,
      932,
      933,
      934,
      936,
      937,
      938,
      939,
      940,
      941,
      942,
      943,
      944,
      945,
      946,
      947,
      948,
      949,
      950,
      955,
      957,
      959,
      961,
      962,
      964,
      966,
      967,
      968,
      969,
      970,
      971,
      974,
      975,
      976,
      983,
      985,
      986,
      988,
      989,
      990,
      991,
      992,
      994,
      995,
      996,
      997,
      999,
      1001,
      1003,
      1004,
      1005,
      1007,
      1009,
      1011,
      1013,
      1014,
      1015,
      1017,
      1019,
      1021
    ]
  },
  {
    "file_path": "image_bootstrap/mount.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport os\nimport re\n\n# See https://www.kernel.org/doc/Documentation/filesystems/proc.txt\n_PROC_PID_MOUNTINFO_LINE = re.compile(\n        '^(?P<mount_id>[0-9]+) '\n        '(?P<parent_id>[0-9]+) '\n        '(?P<major>[0-9]+):(?P<minor>[0-9]+) '\n        '(?P<root>(?:/|mnt:|net:)[^ ]*) '\n        '(?P<mount>/[^ ]*) '  # Spaces are encoded as \"\\040\"\n        '.+$')\n\n\nclass MountFinder(object):\n    def __init__(self):\n        self._mount_points = []\n\n    @staticmethod\n    def _parse_line(line):\n        assert '\\n' not in line\n        match = _PROC_PID_MOUNTINFO_LINE.match(line)\n        if match is None:\n            raise ValueError(f'Unexpected line format: {line!r}')\n        return match.groupdict()\n\n    def _load_text(self, text):\n        for line in text.split('\\n'):\n            if not line:\n                continue\n            self._mount_points.append(self._parse_line(line)['mount'])\n\n    def load(self, filename=None):\n        if filename is None:\n            filename = '/proc/%d/mountinfo' % os.getpid()\n\n        with open(filename, 'r') as f:\n            self._load_text(f.read())\n\n    def _normpath_no_trailing_slash(self, abs_path):\n        return os.path.normpath(abs_path)\n\n    def _normpath_trailing_slash(self, abs_path):\n        return os.path.join(os.path.normpath(abs_path), '')\n\n    def below(self, abs_path, inclusive=False):\n        prefix = self._normpath_trailing_slash(abs_path)\n        for abs_candidate in self._mount_points:\n            normed_candidate = self._normpath_trailing_slash(abs_candidate)\n            if normed_candidate.startswith(prefix):\n                if normed_candidate == prefix and not inclusive:\n                    continue\n                yield self._normpath_no_trailing_slash(normed_candidate)\n",
    "uncovered_lines": [
      28,
      45,
      48,
      51,
      52,
      53,
      54,
      55,
      56,
      57
    ]
  },
  {
    "file_path": "image_bootstrap/boot_loaders/grub2.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport errno\nimport os\n\nfrom directory_bootstrap.shared.commands import COMMAND_CHROOT\n\nBOOTLOADER__CHROOT_GRUB2__DEVICE = 'chroot-grub2-device'\nBOOTLOADER__CHROOT_GRUB2__DRIVE = 'chroot-grub2-drive'\nBOOTLOADER__HOST_GRUB2__DEVICE = 'host-grub2-device'\nBOOTLOADER__HOST_GRUB2__DRIVE = 'host-grub2-drive'\n\nBOOTLOADER__CHROOT_GRUB2 = (\n        BOOTLOADER__CHROOT_GRUB2__DEVICE,\n        BOOTLOADER__CHROOT_GRUB2__DRIVE,\n        )\n\n_BOOTLOADER__ANY_GRUB2__DRIVE = (\n        BOOTLOADER__CHROOT_GRUB2__DRIVE,\n        BOOTLOADER__HOST_GRUB2__DRIVE,\n        )\n\n\nclass GrubTwoInstaller(object):\n    def __init__(self,\n            messenger,\n            executor,\n            abs_target_path,\n            bootloader_approach,\n            bootloader_force,\n            command_host_grub2_install,\n            command_chroot_grub2_install,\n            chroot_env,\n            abs_mountpoint,\n            ):\n        self._messenger = messenger\n        self._executor = executor\n\n        self._abs_target_path = abs_target_path\n        self._bootloader_approach = bootloader_approach\n        self._bootloader_force = bootloader_force\n\n        self._command_host_grub2_install = command_host_grub2_install\n\n        self._command_chroot_grub2_install = command_chroot_grub2_install\n        self._chroot_env = chroot_env\n        self._abs_mountpoint = abs_mountpoint\n\n    def _create_bootloader_install_message(self, real_abs_target):\n        hints = []\n        if real_abs_target != os.path.normpath(self._abs_target_path):\n            hints.append('actually \"%s\"' % real_abs_target)\n        hints.append('approach \"%s\"' % self._bootloader_approach)\n\n        return 'Installing bootloader to device \"%s\" (%s)...' % (\n                self._abs_target_path, ', '.join(hints))\n\n    def run(self):\n        real_abs_target = os.path.realpath(self._abs_target_path)\n        message = self._create_bootloader_install_message(real_abs_target)\n\n        use_chroot = self._bootloader_approach in BOOTLOADER__CHROOT_GRUB2\n        use_device_map = self._bootloader_approach in _BOOTLOADER__ANY_GRUB2__DRIVE\n\n        chroot_boot_grub = os.path.join(self._abs_mountpoint, 'boot', 'grub')\n        try:\n            os.makedirs(chroot_boot_grub, 0o755)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n\n        if use_device_map:\n            # Write device map just for being able to call grub-install\n            abs_chroot_device_map = os.path.join(chroot_boot_grub, 'device.map')\n            grub_drive = '(hd9999)'\n            self._messenger.info('Writing device map to \"%s\" (mapping \"%s\" to \"%s\")...' \\\n                    % (abs_chroot_device_map, grub_drive, real_abs_target))\n            f = open(abs_chroot_device_map, 'w')\n            print('%s\\t%s' % (grub_drive, real_abs_target), file=f)\n            f.close()\n\n        self._messenger.info(message)\n\n        cmd = []\n\n        if use_chroot:\n            cmd += [\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                self._command_chroot_grub2_install,\n                ]\n            env = self._chroot_env\n        else:\n            cmd += [\n                self._command_host_grub2_install,\n                '--boot-directory',\n                os.path.join(self._abs_mountpoint, 'boot'),\n                ]\n            env = None\n\n        cmd.append('--target=i386-pc')  # ensure non-EFI\n\n        if self._bootloader_force:\n            cmd.append('--force')\n\n        if use_device_map:\n            cmd.append(grub_drive)\n        else:\n            cmd.append(self._abs_target_path)\n\n        self._executor.check_call(cmd, env=env)\n\n        if use_device_map:\n            os.remove(abs_chroot_device_map)\n",
    "uncovered_lines": [
      6,
      7,
      9,
      11,
      12,
      13,
      14,
      16,
      21,
      27,
      28,
      39,
      40,
      42,
      43,
      44,
      46,
      48,
      49,
      50,
      52,
      53,
      54,
      55,
      56,
      58,
      61,
      62,
      63,
      65,
      66,
      68,
      69,
      70,
      71,
      72,
      73,
      75,
      77,
      78,
      79,
      81,
      82,
      83,
      85,
      87,
      89,
      90,
      95,
      97,
      102,
      104,
      106,
      107,
      109,
      110,
      112,
      114,
      116,
      117
    ]
  },
  {
    "file_path": "image_bootstrap/distros/arch.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport os\nfrom textwrap import dedent\n\nfrom directory_bootstrap.distros.arch import (\n        SUPPORTED_ARCHITECTURES, ArchBootstrapper)\nfrom directory_bootstrap.shared.commands import (\n        COMMAND_CHROOT, COMMAND_CP, COMMAND_FIND, COMMAND_RM, COMMAND_SED,\n        COMMAND_WGET)\nfrom image_bootstrap.distros.base import DISTRO_CLASS_FIELD, DistroStrategy\n\n\nclass ArchStrategy(DistroStrategy):\n    DISTRO_KEY = 'arch'\n    DISTRO_NAME_SHORT = 'Arch'\n    DISTRO_NAME_LONG = 'Arch Linux'\n\n    def __init__(self, messenger, executor,\n                abs_cache_dir, image_date_triple_or_none, mirror_url,\n                abs_resolv_conf):\n        super(ArchStrategy, self).__init__(\n                messenger,\n                executor,\n                abs_cache_dir,\n                abs_resolv_conf,\n                )\n\n        self._image_date_triple_or_none = image_date_triple_or_none\n        self._mirror_url = mirror_url\n\n    def get_commands_to_check_for(self):\n        return ArchBootstrapper.get_commands_to_check_for() + [\n                COMMAND_CHROOT,\n                COMMAND_CP,\n                COMMAND_FIND,\n                COMMAND_RM,\n                COMMAND_SED,\n                COMMAND_WGET,\n                ]\n\n    def check_architecture(self, architecture):\n        if architecture == 'amd64':\n            architecture = 'x86_64'\n\n        if architecture not in SUPPORTED_ARCHITECTURES:\n            raise ValueError('Architecture \"%s\" not supported' % architecture)\n\n        return architecture\n\n    def configure_hostname(self, hostname):\n        self.write_etc_hostname(hostname)\n\n    def allow_autostart_of_services(self, allow):\n        pass  # services are not auto-started on Arch\n\n    def run_directory_bootstrap(self, architecture, bootloader_approach):\n        self._messenger.info('Bootstrapping %s into \"%s\"...'\n                % (self.DISTRO_NAME_SHORT, self._abs_mountpoint))\n\n        bootstrap = ArchBootstrapper(\n                self._messenger,\n                self._executor,\n                self._abs_mountpoint,\n                self._abs_cache_dir,\n                architecture,\n                self._image_date_triple_or_none,\n                self._mirror_url,\n                self._abs_resolv_conf,\n                )\n        bootstrap.run()\n\n    def create_network_configuration(self, use_mtu_tristate):\n        self._messenger.info('Making sure that network interfaces get named eth*...')\n        os.symlink('/dev/null', os.path.join(self._abs_mountpoint, 'etc/udev/rules.d/80-net-setup-link.rules'))\n\n        network_filename = os.path.join(self._abs_mountpoint, 'etc/systemd/network/eth0-dhcp.network')\n        self._messenger.info('Writing file \"%s\"...' % network_filename)\n        with open(network_filename, 'w') as f:\n            if use_mtu_tristate is None:\n                print(dedent(\"\"\"\\\n                        [Match]\n                        Name=eth0\n\n                        [Network]\n                        DHCP=yes\n                        \"\"\"), file=f)\n            else:\n                d = {\n                    'use_mtu': 'true' if use_mtu_tristate else 'false',\n                }\n                print(dedent(\"\"\"\\\n                        [Match]\n                        Name=eth0\n\n                        [Network]\n                        DHCP=yes\n\n                        [DHCP]\n                        UseMTU=%(use_mtu)s\n                        \"\"\" % d), file=f)\n\n    def _install_packages(self, package_names):\n        cmd = [\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                'pacman',\n                '--noconfirm',\n                '--sync',\n                ] + list(package_names)\n        self._executor.check_call(cmd, env=self.create_chroot_env())\n\n    def ensure_chroot_has_grub2_installed(self):\n        self._install_packages(['grub'])\n\n    def get_chroot_command_grub2_install(self):\n        return 'grub-install'\n\n    def generate_grub_cfg_from_inside_chroot(self):\n        cmd = [\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                'grub-mkconfig',\n                '-o', '/boot/grub/grub.cfg',\n                ]\n        self._executor.check_call(cmd, env=self.create_chroot_env())\n\n    def adjust_initramfs_generator_config(self):\n        abs_linux_preset = os.path.join(self._abs_mountpoint, 'etc', 'mkinitcpio.d', 'linux.preset')\n        self._messenger.info('Adjusting \"%s\"...' % abs_linux_preset)\n        cmd_sed = [\n                COMMAND_SED,\n                's,^[# \\\\t]*default_options=.*,default_options=\"-S autodetect\"  # set by image-bootstrap,g',\n                '-i', abs_linux_preset,\n                ]\n        self._executor.check_call(cmd_sed)\n\n    def generate_initramfs_from_inside_chroot(self):\n        cmd_mkinitcpio = [\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                'mkinitcpio',\n                '-p', 'linux',\n                ]\n        self._executor.check_call(cmd_mkinitcpio, env=self.create_chroot_env())\n\n    def _setup_pacman_reanimation(self):\n        self._messenger.info('Installing haveged (for reanimate-pacman, only)...')\n        self._install_packages(['haveged'])\n\n        local_reanimate_path = '/usr/sbin/reanimate-pacman'\n\n        full_reanimate_path = os.path.join(self._abs_mountpoint, local_reanimate_path.lstrip('/'))\n        self._messenger.info('Writing file \"%s\"...' % full_reanimate_path)\n        with open(full_reanimate_path, 'w') as f:\n            print(dedent(\"\"\"\\\n                    #! /bin/bash\n                    if [[ -e /etc/pacman.d/gnupg ]]; then\n                            exit 0\n                    fi\n\n                    haveged -F &\n                    haveged_pid=$!\n\n                    /usr/bin/pacman-key --init\n                    /usr/bin/pacman-key --populate archlinux\n\n                    kill -9 \"${haveged_pid}\"\n                    \"\"\"), file=f)\n            os.fchmod(f.fileno(), 0o755)\n\n        pacman_reanimation_service = os.path.join(self._abs_mountpoint,\n                'etc/systemd/system/pacman-reanimation.service')\n        self._messenger.info('Writing file \"%s\"...' % pacman_reanimation_service)\n        with open(pacman_reanimation_service, 'w') as f:\n            print(dedent(\"\"\"\\\n                    [Unit]\n                    Description=Pacman reanimation\n\n                    [Service]\n                    ExecStart=/bin/true\n                    ExecStartPost=%s\n\n                    [Install]\n                    WantedBy=multi-user.target\n                    \"\"\" % local_reanimate_path), file=f)\n\n        self._make_services_autostart(['pacman-reanimation'])\n\n    def perform_in_chroot_shipping_clean_up(self):\n        self._setup_pacman_reanimation()\n\n        # NOTE: After this, calling pacman needs reanimation, first\n        pacman_gpg_path = os.path.join(self._abs_mountpoint, 'etc/pacman.d/gnupg')\n        self._messenger.info('Deleting pacman keys at \"%s\"...' % pacman_gpg_path)\n        cmd = [\n                COMMAND_RM,\n                '-Rv', pacman_gpg_path,\n                ]\n        self._executor.check_call(cmd)\n\n\n    def perform_post_chroot_clean_up(self):\n        self._messenger.info('Cleaning chroot pacman cache...')\n        cmd = [\n                COMMAND_FIND,\n                os.path.join(self._abs_mountpoint, 'var/cache/pacman/pkg/'),\n                '-type', 'f',\n                '-delete',\n                ]\n        self._executor.check_call(cmd)\n\n    def install_dhcp_client(self):\n        pass  # already installed (part of systemd)\n\n    def install_sudo(self):\n        self._install_packages(['sudo'])\n\n    def install_cloud_init_and_friends(self):\n        self._install_packages(['cloud-init'])\n        self.disable_cloud_init_syslog_fix_perms()\n        self.install_growpart()\n\n        # cloud-unit makes use of command \"hostname\"\n        # that is provided by package \"inetutils\" in Arch but the\n        # cloud-init packaging lacks a runtime dependency on inetutils,\n        # see Arch bug https://bugs.archlinux.org/task/67941 .\n        # Installing inetutils ourselves helps while waiting for a fix in Arch.\n        # See also: https://github.com/hartwork/image-bootstrap/pull/90\n        self._install_packages(['inetutils'])\n\n    def get_cloud_init_datasource_cfg_path(self):\n        return '/etc/cloud/cloud.cfg.d/90_datasource.cfg'\n\n    def install_sshd(self):\n        self._install_packages(['openssh'])\n\n    def _make_services_autostart(self, service_names):\n        for service_name in service_names:\n            self._messenger.info('Making service \"%s\" start automatically...' % service_name)\n            cmd = [\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                'systemctl',\n                'enable',\n                service_name,\n                ]\n            self._executor.check_call(cmd, env=self.create_chroot_env())\n\n    def make_openstack_services_autostart(self):\n        self._make_services_autostart([\n                'systemd-networkd',\n                'systemd-resolved',  # for nameserver IPs from DHCP\n                'sshd',\n                'cloud-init-main',\n                'cloud-init-local',\n                'cloud-init-network',\n                'cloud-config',\n                'cloud-final',\n                ])\n\n    def get_vmlinuz_path(self):\n        return '/boot/vmlinuz-linux'\n\n    def get_initramfs_path(self):\n        return '/boot/initramfs-linux.img'\n\n    def install_kernel(self):\n        self._install_packages(['linux'])\n\n    def adjust_cloud_cfg_dict(self, cloud_cfg_dict):\n        super(ArchStrategy, self).adjust_cloud_cfg_dict(cloud_cfg_dict)\n\n        # Get rid of groups cdrom, dailout, dip, netdev, plugdev, sudo.\n        # https://github.com/hartwork/image-bootstrap/issues/49#issuecomment-317191835\n        # https://bugs.archlinux.org/task/54911\n        system_info = cloud_cfg_dict.setdefault('system_info', {})\n        system_info__default_user = system_info.setdefault('default_user', {})\n        system_info__default_user['groups'] = ['adm']\n\n    def uses_systemd(self):\n        return True\n\n    def uses_systemd_resolved(self, with_openstack):\n        return with_openstack\n\n    def get_minimum_size_bytes(self):\n        return 3 * 1024**3\n\n    @classmethod\n    def add_parser_to(clazz, distros):\n        arch = distros.add_parser(clazz.DISTRO_KEY, help=clazz.DISTRO_NAME_LONG)\n        arch.set_defaults(**{DISTRO_CLASS_FIELD: clazz})\n\n        ArchBootstrapper.add_arguments_to(arch)\n\n    @classmethod\n    def create(clazz, messenger, executor, options):\n        return clazz(\n                messenger,\n                executor,\n                os.path.abspath(options.cache_dir),\n                options.image_date,\n                options.mirror_url,\n                os.path.abspath(options.resolv_conf),\n                )\n",
    "uncovered_lines": [
      6,
      7,
      9,
      11,
      14,
      17,
      18,
      19,
      20,
      22,
      25,
      32,
      33,
      35,
      36,
      45,
      46,
      47,
      49,
      50,
      52,
      54,
      55,
      57,
      58,
      60,
      61,
      64,
      74,
      76,
      77,
      78,
      80,
      81,
      82,
      83,
      84,
      92,
      95,
      106,
      107,
      114,
      116,
      117,
      119,
      120,
      122,
      123,
      129,
      131,
      132,
      133,
      134,
      139,
      141,
      142,
      148,
      150,
      151,
      152,
      154,
      156,
      157,
      158,
      159,
      173,
      175,
      177,
      178,
      179,
      191,
      193,
      194,
      197,
      198,
      199,
      203,
      206,
      207,
      208,
      214,
      216,
      217,
      219,
      220,
      222,
      223,
      224,
      225,
      233,
      235,
      236,
      238,
      239,
      241,
      242,
      243,
      244,
      251,
      253,
      254,
      265,
      266,
      268,
      269,
      271,
      272,
      274,
      275,
      280,
      281,
      282,
      284,
      285,
      287,
      288,
      290,
      291,
      293,
      294,
      295,
      296,
      298,
      300,
      301,
      302
    ]
  },
  {
    "file_path": "image_bootstrap/distros/base.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport os\nfrom abc import ABCMeta, abstractmethod\n\nimport image_bootstrap.loaders._yaml as yaml\nfrom directory_bootstrap.shared.commands import COMMAND_CHROOT, COMMAND_WGET\nfrom image_bootstrap.engine import BOOTLOADER__CHROOT_GRUB2__DRIVE\n\nDISTRO_CLASS_FIELD = 'distro_class'\n\n\nclass DistroStrategy(object, metaclass=ABCMeta):\n    def __init__(self, messenger, executor, abs_cache_dir, abs_resolv_conf):\n        self._messenger = messenger\n        self._executor = executor\n\n        self._abs_cache_dir = abs_cache_dir\n        self._abs_resolv_conf = abs_resolv_conf\n\n    def set_mountpoint(self, abs_mountpoint):\n        self._abs_mountpoint = abs_mountpoint\n\n    def set_chroot_env_prototype(self, chroot_env_prototype):\n        self._chroot_env_prototype = chroot_env_prototype\n\n    def create_chroot_env(self):\n        return self._chroot_env_prototype.copy()\n\n    def check_release(self):\n        pass\n\n    def select_bootloader(self):\n        return BOOTLOADER__CHROOT_GRUB2__DRIVE\n\n    def write_etc_hostname(self, hostname):\n        filename = os.path.join(self._abs_mountpoint, 'etc', 'hostname')\n        self._messenger.info('Writing file \"%s\"...' % filename)\n        f = open(filename, 'w')\n        print(hostname, file=f)\n        f.close()\n\n    @abstractmethod  # leave calling write_etc_hostname to derived classes\n    def configure_hostname(self, hostname):\n        pass\n\n    @abstractmethod\n    def get_commands_to_check_for(self):\n        pass\n\n    def check_architecture(self, architecture):\n        return architecture\n\n    @abstractmethod\n    def allow_autostart_of_services(self, allow):\n        pass\n\n    @abstractmethod\n    def run_directory_bootstrap(self, architecture, bootloader_approach):\n        pass\n\n    @abstractmethod\n    def create_network_configuration(self, use_mtu_tristate):\n        pass\n\n    @abstractmethod\n    def ensure_chroot_has_grub2_installed(self):\n        pass\n\n    @abstractmethod\n    def get_chroot_command_grub2_install(self):\n        pass\n\n    @abstractmethod\n    def generate_grub_cfg_from_inside_chroot(self):\n        pass\n\n    def adjust_initramfs_generator_config(self):\n        pass\n\n    @abstractmethod\n    def generate_initramfs_from_inside_chroot(self):\n        pass\n\n    @abstractmethod\n    def perform_in_chroot_shipping_clean_up(self):\n        pass\n\n    @abstractmethod\n    def perform_post_chroot_clean_up(self):\n        pass\n\n    def get_cloud_username(self):\n        return self.DISTRO_KEY\n\n    def get_cloud_init_distro(self):\n        return self.DISTRO_KEY\n\n    @abstractmethod\n    def install_dhcp_client(self):\n        pass\n\n    @abstractmethod\n    def install_sudo(self):\n        pass\n\n    @abstractmethod\n    def install_cloud_init_and_friends(self):\n        pass\n\n    @abstractmethod\n    def get_cloud_init_datasource_cfg_path(self):\n        pass\n\n    @abstractmethod\n    def install_sshd(self):\n        pass\n\n    @abstractmethod\n    def make_openstack_services_autostart(self):\n        pass\n\n    @abstractmethod\n    def get_vmlinuz_path(self):\n        pass\n\n    @abstractmethod\n    def get_initramfs_path(self):\n        pass\n\n    def prepare_installation_of_packages(self):\n        pass\n\n    @abstractmethod\n    def install_kernel(self):\n        pass\n\n    def _fetch_install_chmod(self, url, local_path, permissions):\n        full_local_path = os.path.join(self._abs_mountpoint, local_path.lstrip('/'))\n        cmd = [\n                COMMAND_WGET,\n                '-O%s' % full_local_path,\n                url,\n                ]\n        self._executor.check_call(cmd)\n        os.chmod(full_local_path, permissions)\n\n    def install_growpart(self):\n        self._messenger.info('Fetching growpart of cloud-utils...')\n        self._fetch_install_chmod(\n                'https://raw.githubusercontent.com/canonical/cloud-utils/0.31/bin/growpart',\n                '/usr/bin/growpart', 0o755)\n\n    def disable_cloud_init_syslog_fix_perms(self):\n        # https://github.com/hartwork/image-bootstrap/issues/17\n        filename = os.path.join(self._abs_mountpoint, 'etc/cloud/cloud.cfg.d/00_syslog_fix_perms.cfg')\n        self._messenger.info('Writing file \"%s\"...' % filename)\n        with open(filename, 'w') as f:\n            print('syslog_fix_perms: null', file=f)\n\n    def adjust_cloud_cfg_dict(self, cloud_cfg_dict):\n        system_info = cloud_cfg_dict.setdefault('system_info', {})\n\n        system_info__default_user = system_info.setdefault('default_user', {})\n        system_info__default_user['name'] = self.get_cloud_username()\n        system_info__default_user['gecos'] = 'Cloud-init-user'\n        system_info__default_user.setdefault('sudo',\n                                             ['ALL=(ALL) NOPASSWD:ALL'])\n\n        system_info['distro'] = self.get_cloud_init_distro()\n\n    def adjust_etc_cloud_cfg(self):\n        filename = os.path.join(self._abs_mountpoint, 'etc/cloud/cloud.cfg')\n        self._messenger.info('Adjusting file \"%s\"...' % filename)\n        with open(filename, 'r') as f:\n            d = yaml.safe_load(f.read())\n        self.adjust_cloud_cfg_dict(d)\n        with open(filename, 'w') as f:\n            print('# Re-written by image-bootstrap', file=f)\n            print(yaml.safe_dump(d, default_flow_style=False), file=f)\n\n    @abstractmethod\n    def uses_systemd(self):\n        pass\n\n    @abstractmethod\n    def uses_systemd_resolved(self, with_openstack):\n        pass\n\n    @abstractmethod\n    def get_minimum_size_bytes(self):\n        pass\n\n    def _ensure_eth0_naming(self):\n        etc_default_grub = os.path.join(self._abs_mountpoint, 'etc/default/grub')\n        self._messenger.info('Adjusting file \"%s\"...' % etc_default_grub)\n        self._executor.check_call([\n                COMMAND_CHROOT, self._abs_mountpoint,\n                'sed',\n                's,#\\\\?GRUB_CMDLINE_LINUX=.*\",GRUB_CMDLINE_LINUX=\"net.ifnames=0\"  # set by image-bootstrap,',\n                '-i', '/etc/default/grub',\n                ], env=self.create_chroot_env())\n\n    def adjust_grub_defaults(self, with_openstack):\n        pass\n\n    def install_acpid(self):\n        # NOTE: Only called for distros NOT using systemd\n        raise NotImplementedError()\n\n    def get_extra_mkfs_ext4_options(self):\n        return []\n\n    @classmethod\n    def add_parser_to(clazz, distros):\n        raise NotImplementedError()\n\n    @classmethod\n    def create(clazz, messenger, executor, options):\n        raise NotImplementedError()\n",
    "uncovered_lines": [
      6,
      7,
      9,
      10,
      11,
      13,
      16,
      17,
      18,
      19,
      21,
      22,
      24,
      25,
      27,
      28,
      30,
      31,
      33,
      36,
      37,
      39,
      40,
      41,
      42,
      43,
      44,
      46,
      47,
      50,
      51,
      54,
      55,
      57,
      58,
      61,
      62,
      65,
      66,
      69,
      70,
      73,
      74,
      77,
      78,
      81,
      84,
      85,
      88,
      89,
      92,
      93,
      96,
      97,
      99,
      100,
      102,
      103,
      106,
      107,
      110,
      111,
      114,
      115,
      118,
      119,
      122,
      123,
      126,
      127,
      130,
      131,
      134,
      137,
      138,
      141,
      142,
      143,
      148,
      149,
      151,
      152,
      153,
      157,
      159,
      160,
      161,
      162,
      164,
      165,
      167,
      168,
      169,
      170,
      173,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      185,
      186,
      189,
      190,
      193,
      194,
      197,
      198,
      199,
      200,
      207,
      210,
      212,
      214,
      215,
      217,
      218,
      219,
      221,
      222,
      223
    ]
  },
  {
    "file_path": "image_bootstrap/distros/debian.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nfrom image_bootstrap.distros.debian_based import DebianBasedDistroStrategy\n\n\nclass DebianStrategy(DebianBasedDistroStrategy):\n    DISTRO_KEY = 'debian'\n    DISTRO_NAME_SHORT = 'Debian'\n    DISTRO_NAME_LONG = 'Debian GNU/Linux'\n    DEFAULT_RELEASE = 'bookworm'\n    DEFAULT_MIRROR_URL = 'http://httpredir.debian.org/debian'\n    APT_CACHER_NG_URL = 'http://localhost:3142/debian'\n\n    def check_release(self):\n        if self._release in ('stable', 'testing'):\n            raise ValueError('For Debian releases, please use names like \"%s\" rather than \"%s\".'\n                % (self.DEFAULT_RELEASE, self._release))\n\n        if self._release in ('wheezy', 'jessie', 'stretch', 'buster'):\n            raise ValueError('Release \"%s\" is no longer supported.' % self._release)\n\n    def get_kernel_package_name(self, architecture):\n        if architecture == 'i386':\n            return 'linux-image-686-pae'\n\n        return 'linux-image-%s' % architecture\n\n    def install_cloud_init_and_friends(self):\n        self._install_packages(['cloud-init', 'cloud-utils', 'cloud-initramfs-growroot'])\n\n    def uses_systemd(self):\n        return True\n\n    def uses_systemd_resolved(self, with_openstack):\n        return False\n\n    def get_minimum_size_bytes(self):\n        return 2 * 1024**3\n\n    def get_extra_mkfs_ext4_options(self):\n        args = super(DebianStrategy, self).get_extra_mkfs_ext4_options()\n        args += ['-O', '^metadata_csum']\n        return args\n",
    "uncovered_lines": [
      6,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      17,
      18,
      19,
      22,
      23,
      25,
      26,
      27,
      29,
      31,
      32,
      34,
      35,
      37,
      38,
      40,
      41,
      43,
      44,
      45,
      46
    ]
  },
  {
    "file_path": "image_bootstrap/distros/debian_based.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport errno\nimport os\nimport subprocess\nfrom abc import ABCMeta, abstractmethod\nfrom textwrap import dedent\n\nfrom directory_bootstrap.shared.commands import (\n        COMMAND_FIND, COMMAND_UNAME, COMMAND_UNSHARE)\nfrom image_bootstrap.distros.base import DISTRO_CLASS_FIELD, DistroStrategy\nfrom image_bootstrap.engine import (\n        BOOTLOADER__ANY_GRUB, BOOTLOADER__HOST_EXTLINUX, COMMAND_CHROOT)\n\n\n_ETC_NETWORK_INTERFACES_CONTENT = \"\"\"\\\n# This file describes the network interfaces available on your system\n# and how to activate them. For more information, see interfaces(5).\n\nsource /etc/network/interfaces.d/*\n\n# The loopback network interface\nauto lo\niface lo inet loopback\n\n# The primary network interface\nallow-hotplug eth0\niface eth0 inet dhcp\n\"\"\"\n\n\nclass _ArchitectureMachineMismatch(Exception):\n    def __init__(self, architecture, machine):\n        self._architecture = architecture\n        self._machine = machine\n\n    def __str__(self):\n        return 'Bootstrapping architecture %s on %s machines not supported' \\\n            % (self._architecture, self._machine)\n\n\nclass DebianBasedDistroStrategy(DistroStrategy, metaclass=ABCMeta):\n    def __init__(self,\n            messenger,\n            executor,\n\n            release,\n            mirror_url,\n            command_debootstrap,\n            debootstrap_opt,\n            ):\n        self._messenger = messenger\n        self._executor = executor\n\n        self._release = release\n        self._mirror_url = mirror_url\n        self._command_debootstrap = command_debootstrap\n        self._debootstrap_opt = debootstrap_opt\n\n    @abstractmethod\n    def check_release(self):\n        pass\n\n    def get_commands_to_check_for(self):\n        return [\n                    COMMAND_CHROOT,\n                    COMMAND_FIND,\n                    COMMAND_UNAME,\n                    COMMAND_UNSHARE,\n                    self._command_debootstrap,\n                ]\n\n    @abstractmethod\n    def get_kernel_package_name(self, architecture):\n        pass\n\n    def check_architecture(self, architecture):\n        uname_output = subprocess.check_output([COMMAND_UNAME, '-m'])\n        host_machine = uname_output.rstrip().decode('utf-8')\n\n        trouble = False\n        if architecture == 'amd64' and host_machine != 'x86_64':\n            trouble = True\n        elif architecture == 'i386':\n            if host_machine not in ('i386', 'i486', 'i586', 'i686', 'x86_64'):\n                trouble = True\n\n        if trouble:\n            raise _ArchitectureMachineMismatch(architecture, host_machine)\n\n        return architecture\n\n    def configure_hostname(self, hostname):\n        self.write_etc_hostname(hostname)\n\n    def allow_autostart_of_services(self, allow):\n        policy_rc_d_path = os.path.join(self._abs_mountpoint, 'usr/sbin/policy-rc.d')\n\n        verb_activate = 'Re-activating' if allow else 'Deactivating'\n        verb_create = 'removing' if allow else 'writing'\n        self._messenger.info('%s auto-starting of services from package installations (by %s file \"%s\")...'\n                % (verb_activate, verb_create, policy_rc_d_path))\n\n        if allow:\n            try:\n                os.remove(policy_rc_d_path)\n            except OSError as e:\n                if e.errno != errno.ENOENT:\n                    raise\n        else:\n            # https://people.debian.org/~hmh/invokerc.d-policyrc.d-specification.txt\n            with open(policy_rc_d_path, 'w') as f:\n                print(dedent(\"\"\"\\\n                        #! /bin/sh\n                        exit 101\n                        \"\"\"), file=f)\n                os.fchmod(f.fileno(), 0o755)\n\n    def run_directory_bootstrap(self, architecture, bootloader_approach):\n        self._messenger.info('Bootstrapping %s \"%s\" into \"%s\"...'\n                % (self.DISTRO_NAME_SHORT, self._release, self._abs_mountpoint))\n\n        _extra_packages = [\n                'initramfs-tools',  # for update-initramfs\n                self.get_kernel_package_name(architecture),\n                ]\n        if bootloader_approach in BOOTLOADER__ANY_GRUB:\n            _extra_packages.append('grub-pc')\n        elif bootloader_approach == BOOTLOADER__HOST_EXTLINUX:\n            pass\n        else:\n            raise NotImplementedError('Unsupported bootloader for %s' % self.DISTRO_NAME_SHORT)\n\n        cmd = [\n                COMMAND_UNSHARE,\n                '--mount',\n                '--',\n                self._command_debootstrap,\n                '--arch', architecture,\n                '--include=%s' % ','.join(_extra_packages),\n                ] \\\n                + self._debootstrap_opt \\\n                + [\n                self._release,\n                self._abs_mountpoint,\n                self._mirror_url,\n                ]\n        self._executor.check_call(cmd)\n\n    def create_network_configuration(self, use_mtu_tristate):\n        filename = os.path.join(self._abs_mountpoint, 'etc', 'network', 'interfaces')\n        self._messenger.info('Writing file \"%s\"...' % filename)\n        f = open(filename, 'w')\n        print(_ETC_NETWORK_INTERFACES_CONTENT, file=f)\n        f.close()\n\n        # TODO For non-None use_mtu_tristate, force DHCP client option 26/interface-mtu\n        use_mtu_tristate\n\n    def ensure_chroot_has_grub2_installed(self):\n        pass  # debootstrap has already pulled GRUB 2.x in\n\n    def get_chroot_command_grub2_install(self):\n        return 'grub-install'\n\n    def generate_grub_cfg_from_inside_chroot(self):\n        cmd = [\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                'update-grub',\n                ]\n        self._executor.check_call(cmd, env=self.create_chroot_env())\n\n    def generate_initramfs_from_inside_chroot(self):\n        cmd = [\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                'update-initramfs',\n                '-u',\n                '-k', 'all',\n                ]\n        self._executor.check_call(cmd, env=self.create_chroot_env())\n\n    def perform_in_chroot_shipping_clean_up(self):\n        pass  # nothing, yet\n\n    def perform_post_chroot_clean_up(self):\n        self._messenger.info('Cleaning chroot apt cache...')\n        cmd = [\n                COMMAND_FIND,\n                os.path.join(self._abs_mountpoint, 'var', 'cache', 'apt', 'archives'),\n                '-type', 'f',\n                '-name', '*.deb',\n                '-delete',\n                ]\n        self._executor.check_call(cmd)\n\n    def _install_packages(self, package_names):\n        self._messenger.info('Installing %s...' % ', '.join(package_names))\n        env = self.create_chroot_env()\n        env.setdefault('DEBIAN_FRONTEND', 'noninteractive')\n        cmd = [\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                'apt-get',\n                'install',\n                '-y', '--no-install-recommends', '-V',\n                ] + list(package_names)\n        self._executor.check_call(cmd, env=env)\n\n    def install_dhcp_client(self):\n        pass  # already installed\n\n    def install_sudo(self):\n        self._install_packages(['sudo'])\n\n    @abstractmethod\n    def install_cloud_init_and_friends(self):\n        pass\n\n    def get_cloud_init_datasource_cfg_path(self):\n        return '/etc/cloud/cloud.cfg.d/90_dpkg.cfg'  # existing file\n\n    def install_sshd(self):\n        self._install_packages(['openssh-server'])\n\n    def make_openstack_services_autostart(self):\n        pass  # autostarted in Debian, already\n\n    def get_vmlinuz_path(self):\n        return '/vmlinuz'\n\n    def get_initramfs_path(self):\n        return '/initrd.img'\n\n    def install_kernel(self):\n        pass  # Kernel installed, already\n\n    def adjust_grub_defaults(self, with_openstack):\n        self._ensure_eth0_naming()\n\n    def install_acpid(self):\n        self._install_packages(['acpid'])\n\n    @classmethod\n    def add_parser_to(clazz, distros):\n        debian = distros.add_parser(clazz.DISTRO_KEY, help=clazz.DISTRO_NAME_LONG)\n        debian.set_defaults(**{DISTRO_CLASS_FIELD: clazz})\n\n        debian_commands = debian.add_argument_group('command names')\n        debian_commands.add_argument('--debootstrap', metavar='COMMAND',\n                dest='command_debootstrap', default='debootstrap',\n                help='override debootstrap command')\n\n        debian.add_argument('--release', dest='release', default=clazz.DEFAULT_RELEASE,\n                metavar='RELEASE',\n                help='specify %s release (default: %%(default)s)'\n                % clazz.DISTRO_NAME_SHORT)\n        debian.add_argument('--mirror', dest='mirror_url', metavar='URL',\n                default=clazz.DEFAULT_MIRROR_URL,\n                help='specify %s mirror to use (e.g. %s for '\n                    'a local instance of apt-cacher-ng; default: %%(default)s)'\n                    % (clazz.DISTRO_NAME_SHORT, clazz.APT_CACHER_NG_URL))\n\n        debian.add_argument('--debootstrap-opt', dest='debootstrap_opt',\n                metavar='OPTION', action='append', default=[],\n                help='option to pass to debootstrap, in addition; '\n                    'can be passed several times; '\n                    'use with --debootstrap-opt=... syntax, i.e. with \"=\"')\n\n    @classmethod\n    def create(clazz, messenger, executor, options):\n        return clazz(\n                messenger,\n                executor,\n                options.release,\n                options.mirror_url,\n                options.command_debootstrap,\n                options.debootstrap_opt,\n                )\n",
    "uncovered_lines": [
      6,
      7,
      8,
      9,
      10,
      12,
      14,
      15,
      19,
      35,
      36,
      37,
      38,
      40,
      41,
      45,
      46,
      55,
      56,
      58,
      59,
      60,
      61,
      63,
      64,
      67,
      68,
      76,
      77,
      80,
      81,
      82,
      84,
      85,
      86,
      87,
      88,
      89,
      91,
      92,
      94,
      96,
      97,
      99,
      100,
      102,
      103,
      104,
      107,
      108,
      109,
      110,
      111,
      112,
      115,
      116,
      120,
      122,
      123,
      126,
      130,
      131,
      132,
      135,
      137,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      161,
      163,
      164,
      166,
      167,
      169,
      170,
      175,
      177,
      178,
      185,
      187,
      188,
      190,
      191,
      192,
      199,
      201,
      202,
      203,
      204,
      205,
      212,
      214,
      215,
      217,
      218,
      220,
      221,
      224,
      225,
      227,
      228,
      230,
      231,
      233,
      234,
      236,
      237,
      239,
      240,
      242,
      243,
      245,
      246,
      248,
      249,
      250,
      251,
      253,
      254,
      258,
      262,
      268,
      274,
      275,
      276
    ]
  },
  {
    "file_path": "image_bootstrap/distros/gentoo.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport errno\nimport glob\nimport os\nimport platform\nimport shutil\nfrom textwrap import dedent\n\nfrom directory_bootstrap.distros.gentoo import GentooBootstrapper\nfrom directory_bootstrap.shared.commands import (\n        COMMAND_CHROOT, COMMAND_FIND, COMMAND_WGET)\nfrom image_bootstrap.distros.base import DISTRO_CLASS_FIELD, DistroStrategy\n\n_ABS_PACKAGE_USE = '/etc/portage/package.use'\n_ABS_PACKAGE_KEYWORDS = '/etc/portage/package.accept_keywords'\n_ABS_PACKAGE_MASK = '/etc/portage/package.mask'\n_ABS_PACKAGE_UNMASK = '/etc/portage/package.unmask'\n\n_ARCH_OF_PLATFORM = {\n    # TODO more arches here\n    'x86_64': 'amd64',\n}\n\n_HOST_PLATFORM = platform.machine()\n_HOST_ARCH = _ARCH_OF_PLATFORM.get(_HOST_PLATFORM, _HOST_PLATFORM)\n\n\nclass GentooStrategy(DistroStrategy):\n    DISTRO_KEY = 'gentoo'\n    DISTRO_NAME_SHORT = 'Gentoo'\n    DISTRO_NAME_LONG = 'Gentoo'\n\n    def __init__(self, messenger, executor, abs_cache_dir,\n                mirror_url, max_age_days,\n                stage3_date_triple_or_none, repository_date_triple_or_none,\n                abs_resolv_conf):\n        super(GentooStrategy, self).__init__(\n                messenger,\n                executor,\n                abs_cache_dir,\n                abs_resolv_conf,\n                )\n\n        self._mirror_url = mirror_url\n        self._max_age_days = max_age_days\n        self._stage3_date_triple_or_none = stage3_date_triple_or_none\n        self._repository_date_triple_or_none = repository_date_triple_or_none\n\n    def _write_etc_conf_d_hostname(self):\n        etc_conf_d = os.path.join(self._abs_mountpoint, 'etc/conf.d')\n        try:\n            os.makedirs(etc_conf_d, 0o755)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n\n        etc_conf_d_hostname = os.path.join(etc_conf_d, 'hostname')\n        with open(etc_conf_d_hostname, 'w') as f:\n            print(dedent(\"\"\"\\\n                    # Written by image-bootstrap\n                    if [ -f /etc/hostname ]; then\n                        hostname=\"`cat /etc/hostname`\"\n                    fi\n\n                    if [ -z \"${hostname}\" ]; then\n                        hostname=localhost\n                    fi\n                    \"\"\"), file=f)\n\n    def configure_hostname(self, hostname):\n        self.write_etc_hostname(hostname)\n        self._write_etc_conf_d_hostname()\n\n    def allow_autostart_of_services(self, allow):\n        pass  # services are not auto-started on Gentoo\n\n    def _patch_etc_dhcpcd_conf(self, use_mtu):\n        etc_dhcpcd_conf = os.path.join(self._abs_mountpoint, 'etc/dhcpcd.conf')\n        with open(etc_dhcpcd_conf) as f:\n            input_lines = f.read().split('\\n')\n\n        ENABLED = 'option interface_mtu'\n        DISABLED = '#option interface_mtu'\n\n        output_lines = []\n        configured = False\n        for l in input_lines:\n            if 'option interface_mtu' in l:\n                commented_out = l.lstrip().startswith('#')\n                if commented_out and use_mtu:\n                    l = ENABLED\n                elif not commented_out and not use_mtu:\n                    l = DISABLED\n                configured = True\n            output_lines.append(l)\n\n        if not configured:\n            output_lines.append(ENABLED if use_mtu else DISABLED)\n\n        with open(etc_dhcpcd_conf, 'w') as f:\n            print('\\n'.join(output_lines), file=f)\n\n    def create_network_configuration(self, use_mtu_tristate):\n        etc_conf_d_net = os.path.join(self._abs_mountpoint, 'etc/conf.d/net')\n        with open(etc_conf_d_net, 'w') as f:\n            print(dedent(\"\"\"\\\n                    # Generated by image-bootstrap\n                    modules=\"dhcpcd\"\n                    config_eth0=\"dhcp\"\n                    \"\"\"), file=f)\n\n        if use_mtu_tristate is not None:\n            self._patch_etc_dhcpcd_conf(use_mtu_tristate)\n\n    def _set_package_use_flags(self, package_name, flags_str, package_atom=None):\n        if package_atom is None:\n            package_atom = package_name\n\n        filename = os.path.join(self._abs_mountpoint, _ABS_PACKAGE_USE.lstrip('/'), package_name.replace('/', '--'))\n        with open(filename, 'w') as f:\n            print('# generated by image-bootstrap', file=f)\n            print('%s %s' % (package_atom, flags_str), file=f)\n\n    def _set_package_keywords(self, package_name, keywords_str, package_atom=None):\n        if package_atom is None:\n            package_atom = package_name\n\n        filename = os.path.join(self._abs_mountpoint,\n                _ABS_PACKAGE_KEYWORDS.lstrip('/'),\n                package_name.replace('/', '--'),\n                )\n        with open(filename, 'w') as f:\n            print('# generated by image-bootstrap', file=f)\n            print('%s %s' % (package_atom, keywords_str), file=f)\n\n    def _add_package_mask(self, package_name, package_atom=None, invert=False):\n        if package_atom is None:\n            package_atom = package_name\n\n        filename = os.path.join(self._abs_mountpoint,\n                (_ABS_PACKAGE_UNMASK if invert else _ABS_PACKAGE_MASK).lstrip('/'),\n                package_name.replace('/', '--'),\n                )\n        with open(filename, 'w') as f:\n            print('# generated by image-bootstrap', file=f)\n            print(package_atom, file=f)\n\n    def _install_package_atoms(self, packages, reinstall=False):\n        env = self.create_chroot_env().update({\n            'DONT_MOUNT_BOOT': '1',  # sys-boot/grub\n            'MAKEOPTS': '-j2',\n        })\n        argv = [\n            COMMAND_CHROOT,\n            self._abs_mountpoint,\n            'env',\n            'FEATURES=-news',\n            'emerge',\n            '--ignore-default-opts',\n            '--tree',\n            '--verbose',\n            '--verbose-conflicts',\n            '--jobs', '2',\n        ]\n        if not reinstall:\n            argv += ['--update', '--changed-use']\n        argv += list(packages)\n\n        self._executor.check_call(argv, env=env)\n\n    def ensure_chroot_has_grub2_installed(self):\n        self._set_package_use_flags(\n                'sys-boot/grub', 'device-mapper grub_platforms_pc', 'sys-boot/grub:2')\n        self._set_package_use_flags(\n                'sys-fs/lvm2', '-thin')\n        self._install_package_atoms(['sys-boot/grub:2'])\n\n    def _disable_grub2_gfxmode(self):\n        self._executor.check_call([\n                COMMAND_CHROOT, self._abs_mountpoint,\n                'sed',\n                '/GRUB_TERMINAL=/ s,.*GRUB_TERMINAL=.*,GRUB_TERMINAL=console  # forced by image-bootstrap,',\n                '-i', '/etc/default/grub',\n                ], env=self.create_chroot_env())\n\n    def adjust_grub_defaults(self, with_openstack):\n        if with_openstack:\n            self._disable_grub2_gfxmode()\n            self._ensure_eth0_naming()\n\n    def generate_grub_cfg_from_inside_chroot(self):\n        cmd = [\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                'grub-mkconfig',\n                '-o', '/boot/grub/grub.cfg',\n                ]\n        self._executor.check_call(cmd, env=self.create_chroot_env())\n\n    def _get_installed_kernel_version(self):\n        prefix = 'vmlinuz-'\n        kernel_bins = [os.path.basename(e) for e\n                in sorted(glob.glob(os.path.join(self._abs_mountpoint, 'boot/%s*' % prefix)))]\n        if not kernel_bins:\n            raise ValueError('No kernel binary found')  # TODO proper exception\n\n        kernel_version = kernel_bins[-1][len(prefix):]\n        if len(kernel_bins) > 1:\n            self._messenger.warn('Multiple kernel binaries found, picked \"%s-%s\" for version extraction' % (prefix, kernel_version))\n\n        return kernel_version\n\n    def _make_initramfs_symlink(self):\n        # NOTE: dracut default is /boot/initramfs-<kernel version>.img\n        initramfs_images = [os.path.basename(e) for e\n                in sorted(glob.glob(os.path.join(self._abs_mountpoint, 'boot/initramfs-*.img')))]\n        if not initramfs_images:\n            raise ValueError('No initramfs image found')  # TODO proper exception\n\n        target_basename = initramfs_images[-1]\n        if len(initramfs_images) > 1:\n            self._messenger.warn('Multiple initramfs images found, picked \"%s\" for the symlink' % target_basename)\n\n        os.symlink(target_basename, os.path.join(self._abs_mountpoint, self.get_initramfs_path().lstrip('/')))\n\n    def generate_initramfs_from_inside_chroot(self):\n        kernel_version_str = self._get_installed_kernel_version()\n\n        self._install_package_atoms(['sys-kernel/dracut'])\n        # NOTE: Pass kernel version to Dracut so it does not end up\n        #       picking that of the host (rather than the chroot) from uname\n        self._executor.check_call([\n                COMMAND_CHROOT,\n                self._abs_mountpoint,\n                'dracut',\n                '--kver', kernel_version_str,\n                ], env=self.create_chroot_env())\n\n        self._make_initramfs_symlink()\n\n    def get_chroot_command_grub2_install(self):\n        return 'grub-install'\n\n    def get_cloud_init_datasource_cfg_path(self):\n        return '/etc/cloud/cloud.cfg.d/90_datasource.cfg'\n\n    def get_commands_to_check_for(self):\n        return GentooBootstrapper.get_commands_to_check_for() + [\n                COMMAND_CHROOT,\n                COMMAND_FIND,\n                COMMAND_WGET,\n                ]\n\n    def get_initramfs_path(self):\n        return '/boot/initramfs'\n\n    def get_vmlinuz_path(self):\n        return '/boot/vmlinuz'\n\n    def install_cloud_init_and_friends(self):\n        # NOTE This will make virtual/rust pull in dev-lang/rust-bin\n        #      instead of dev-lang/rust (which asked for \"11520 MiB disk space\")\n        self._add_package_mask('dev-lang/rust')\n\n        self._set_package_keywords('app-emulation/cloud-init', f'~{_HOST_ARCH}')\n\n        self._install_package_atoms(['app-emulation/cloud-init', 'net-misc/openssh'])\n        self.disable_cloud_init_syslog_fix_perms()\n        self.install_growpart()\n\n    def install_sshd(self):\n        self._install_package_atoms(['net-misc/openssh'])\n\n        init_script_path = os.path.join(self._abs_mountpoint, 'etc/init.d/sshd-need-root')\n        with open(init_script_path, 'w') as f:\n            print(dedent(\"\"\"\\\n                    #!/sbin/runscript\n                    # Workaround to ensure that sshd has a writable root file system\n                    # during key generation\n                    # https://bugs.gentoo.org/show_bug.cgi?id=554804\n                    #\n                    # Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n                    # Licensed under AGPL v3 or later\n\n                    depend() {\n                        if ! ls /etc/ssh/ssh_host_*_key 1>/dev/null 2>/dev/null; then\n                            need root\n                        fi\n                        before sshd\n                    }\n\n                    start() { :; }\n                    stop() { :; }\n                    \"\"\"), file=f)\n            os.fchmod(f.fileno(), 0o755)\n\n    def install_dhcp_client(self):\n        self._install_package_atoms(['net-misc/dhcpcd'])\n\n    def install_sudo(self):\n        self._set_package_use_flags('app-admin/sudo', '-sendmail')\n        self._install_package_atoms(['app-admin/sudo'])\n\n    def _create_network_init_script_symlink(self, interface_name):\n        net_service = 'net.%s' % interface_name\n        net_init_script = os.path.join(self._abs_mountpoint, 'etc/init.d', net_service)\n        os.symlink('net.lo', net_init_script)\n        return net_service\n\n    def _make_service_autostart(self, service_name):\n        self._executor.check_call([\n            COMMAND_CHROOT,\n            self._abs_mountpoint,\n            'rc-update',\n            'add', service_name, 'default',\n            ], env=self.create_chroot_env())\n\n    def make_openstack_services_autostart(self):\n        net_service = self._create_network_init_script_symlink('eth0')\n\n        for service in (\n                net_service,\n                'sshd',\n                'sshd-need-root',  # written by image-bootstrap above\n                'cloud-init-local',\n                'cloud-init',\n                'cloud-config',\n                'cloud-final',\n                ):\n            self._make_service_autostart(service)\n\n    def _mark_all_news_as_read(self):\n        self._executor.check_call([\n            COMMAND_CHROOT, self._abs_mountpoint,\n            'eselect', 'news',\n            'read', '--quiet', 'all',\n            ], env=self.create_chroot_env())\n\n    def perform_in_chroot_shipping_clean_up(self):\n        self._mark_all_news_as_read()\n\n    def _clean_distfiles(self):\n        distfiles_abs_path = os.path.join(self._abs_mountpoint, 'var/cache/distfiles')\n        self._messenger.info('Cleaning distfiles at \"%s\"...' % distfiles_abs_path)\n        cmd = [\n                COMMAND_FIND,\n                distfiles_abs_path,\n                '-type', 'f',\n                '-delete',\n                ]\n        self._executor.check_call(cmd)\n\n    def perform_post_chroot_clean_up(self):\n        self._clean_distfiles()\n\n    def run_directory_bootstrap(self, architecture, bootloader_approach):\n        self._messenger.info('Bootstrapping %s into \"%s\"...'\n                % (self.DISTRO_NAME_SHORT, self._abs_mountpoint))\n\n        bootstrap = GentooBootstrapper(\n                self._messenger,\n                self._executor,\n                self._abs_mountpoint,\n                self._abs_cache_dir,\n                architecture,\n                self._mirror_url,\n                self._max_age_days,\n                self._stage3_date_triple_or_none,\n                self._repository_date_triple_or_none,\n                self._abs_resolv_conf,\n                )\n        bootstrap.run()\n\n    def prepare_installation_of_packages(self):\n        for chroot_abs_path in (\n                _ABS_PACKAGE_KEYWORDS,\n                _ABS_PACKAGE_MASK,\n                _ABS_PACKAGE_UNMASK,\n                _ABS_PACKAGE_USE,\n                ):\n            try:\n                os.makedirs(os.path.join(self._abs_mountpoint, chroot_abs_path.lstrip('/')), 0o755)\n            except OSError as e:\n                if e.errno != errno.EEXIST:\n                    raise\n\n    def _enable_kernel_option(self, option_name):\n        self._executor.check_call([\n                COMMAND_CHROOT, self._abs_mountpoint,\n                '/usr/src/linux/scripts/config',\n                '--file', '/usr/src/linux/.config',\n                '--enable', option_name,\n                ], env=self.create_chroot_env())\n\n    def _configure_kernel__enable_kvm_support(self):\n        tasks = dedent(\"\"\"\\\n                # Based on https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/configs/kvm_guest.config?h=v5.17.3\n                CONFIG_NET=y\n                CONFIG_NET_CORE=y\n                CONFIG_NETDEVICES=y\n                CONFIG_BLOCK=y\n                CONFIG_BLK_DEV=y\n                CONFIG_NETWORK_FILESYSTEMS=y\n                CONFIG_INET=y\n                CONFIG_TTY=y\n                CONFIG_SERIAL_8250=y\n                CONFIG_SERIAL_8250_CONSOLE=y\n                CONFIG_IP_PNP=y\n                CONFIG_IP_PNP_DHCP=y\n                CONFIG_BINFMT_ELF=y\n                CONFIG_PCI=y\n                CONFIG_PCI_MSI=y\n                # CONFIG_DEBUG_KERNEL=y\n                CONFIG_VIRTUALIZATION=y\n                CONFIG_HYPERVISOR_GUEST=y\n                CONFIG_PARAVIRT=y\n                CONFIG_KVM_GUEST=y\n                CONFIG_VIRTIO=y\n                CONFIG_VIRTIO_MENU=y\n                CONFIG_VIRTIO_PCI=y\n                CONFIG_VIRTIO_BLK=y\n                CONFIG_VIRTIO_CONSOLE=y\n                CONFIG_VIRTIO_NET=y\n                CONFIG_9P_FS=y\n                CONFIG_NET_9P=y\n                CONFIG_NET_9P_VIRTIO=y\n                CONFIG_SCSI_LOWLEVEL=y\n                CONFIG_SCSI_VIRTIO=y\n                CONFIG_VIRTIO_INPUT=y\n                CONFIG_DRM_VIRTIO_GPU=y\n                \"\"\")\n        for line in tasks.split('\\n'):\n            if not line or line.startswith('#'):\n                continue\n            assert line.startswith('CONFIG_')\n            assert line.endswith('=y')\n            option_name = line[len('CONFIG_'):-len('=y')]\n\n            self._enable_kernel_option(option_name)\n\n    def _configure_kernel__finish(self):\n        self._executor.check_call([\n                COMMAND_CHROOT, self._abs_mountpoint,\n                'make',\n                '-C', '/usr/src/linux',\n                'olddefconfig',\n                ], env=self.create_chroot_env())\n        self._executor.check_call([\n                COMMAND_CHROOT, self._abs_mountpoint,\n                '/usr/src/linux/scripts/diffconfig',\n                '-m',\n                '/usr/src/linux/.config.initial',\n                '/usr/src/linux/.config',\n                ], env=self.create_chroot_env())\n\n    def install_kernel(self):\n        self._set_package_keywords('sys-kernel/vanilla-sources', f'~{_HOST_ARCH}')\n        self._set_package_use_flags('sys-kernel/vanilla-sources', 'symlink')\n        self._install_package_atoms(['sys-kernel/vanilla-sources', 'sys-kernel/installkernel'])\n        self._executor.check_call([\n                COMMAND_CHROOT, self._abs_mountpoint,\n                'make', '-C', '/usr/src/linux', 'defconfig',\n                ], env=self.create_chroot_env())\n        shutil.copyfile(\n                os.path.join(self._abs_mountpoint, 'usr/src/linux/.config'),\n                os.path.join(self._abs_mountpoint, 'usr/src/linux/.config.initial'),\n                )\n\n        self._configure_kernel__enable_kvm_support()\n        self._configure_kernel__finish()\n\n        self._executor.check_call([\n                COMMAND_CHROOT, self._abs_mountpoint,\n                'make',\n                '-C', '/usr/src/linux',\n                '-j2',\n                ], env=self.create_chroot_env())\n        self._executor.check_call([\n                COMMAND_CHROOT, self._abs_mountpoint,\n                'ln', '-s', 'MISSING', '/boot/vmlinuz',\n                ], env=self.create_chroot_env())\n        self._executor.check_call([\n                COMMAND_CHROOT, self._abs_mountpoint,\n                'make',\n                '-C', '/usr/src/linux',\n                'modules_install', 'install', 'clean',\n                ], env=self.create_chroot_env())\n        self._executor.check_call([\n                COMMAND_CHROOT, self._abs_mountpoint,\n                'rm', '-f', '/boot/vmlinuz.old',\n                ], env=self.create_chroot_env())\n\n    def uses_systemd(self):\n        return False\n\n    def uses_systemd_resolved(self, with_openstack):\n        return False\n\n    def get_minimum_size_bytes(self):\n        return 5 * 1024**3\n\n    def install_acpid(self):\n        self._install_package_atoms(['sys-power/acpid'])\n        self._make_service_autostart('acpid')\n\n    @classmethod\n    def add_parser_to(clazz, distros):\n        gentoo = distros.add_parser(clazz.DISTRO_KEY, help=clazz.DISTRO_NAME_LONG)\n        gentoo.set_defaults(**{DISTRO_CLASS_FIELD: clazz})\n\n        GentooBootstrapper.add_arguments_to(gentoo)\n\n    @classmethod\n    def create(clazz, messenger, executor, options):\n        return clazz(\n                messenger,\n                executor,\n                os.path.abspath(options.cache_dir),\n                options.mirror_url,\n                options.max_age_days,\n                options.stage3_date,\n                options.repository_date,\n                os.path.abspath(options.resolv_conf),\n                )\n",
    "uncovered_lines": [
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      14,
      16,
      18,
      19,
      20,
      21,
      23,
      28,
      29,
      32,
      33,
      34,
      35,
      37,
      41,
      48,
      49,
      50,
      51,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      61,
      62,
      63,
      74,
      75,
      76,
      78,
      79,
      81,
      82,
      83,
      84,
      86,
      87,
      89,
      90,
      91,
      92,
      93,
      94,
      95,
      96,
      97,
      98,
      99,
      101,
      102,
      104,
      105,
      107,
      108,
      109,
      110,
      116,
      117,
      119,
      120,
      121,
      123,
      124,
      125,
      126,
      128,
      129,
      130,
      132,
      136,
      137,
      138,
      140,
      141,
      142,
      144,
      148,
      149,
      150,
      152,
      153,
      157,
      169,
      170,
      171,
      173,
      175,
      176,
      178,
      180,
      182,
      183,
      190,
      191,
      192,
      193,
      195,
      196,
      202,
      204,
      205,
      206,
      208,
      209,
      211,
      212,
      213,
      215,
      217,
      219,
      221,
      222,
      224,
      225,
      226,
      228,
      230,
      231,
      233,
      236,
      243,
      245,
      246,
      248,
      249,
      251,
      252,
      258,
      259,
      261,
      262,
      264,
      267,
      269,
      271,
      272,
      273,
      275,
      276,
      278,
      279,
      280,
      299,
      301,
      302,
      304,
      305,
      306,
      308,
      309,
      310,
      311,
      312,
      314,
      315,
      322,
      323,
      325,
      334,
      336,
      337,
      343,
      344,
      346,
      347,
      348,
      349,
      355,
      357,
      358,
      360,
      361,
      364,
      376,
      378,
      379,
      385,
      386,
      387,
      388,
      389,
      391,
      392,
      399,
      400,
      436,
      437,
      438,
      439,
      440,
      441,
      443,
      445,
      446,
      452,
      460,
      461,
      462,
      463,
      464,
      468,
      473,
      474,
      476,
      482,
      486,
      492,
      497,
      498,
      500,
      501,
      503,
      504,
      506,
      507,
      508,
      510,
      511,
      512,
      513,
      515,
      517,
      518,
      519
    ]
  },
  {
    "file_path": "image_bootstrap/distros/ubuntu.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\nimport os\n\nfrom image_bootstrap.distros.debian_based import DebianBasedDistroStrategy\nfrom image_bootstrap.engine import BOOTLOADER__HOST_EXTLINUX\n\n\nclass UbuntuStrategy(DebianBasedDistroStrategy):\n    DISTRO_KEY = 'ubuntu'\n    DISTRO_NAME_SHORT = 'Ubuntu'\n    DISTRO_NAME_LONG = 'Ubuntu'\n    DEFAULT_RELEASE = 'trusty'\n    DEFAULT_MIRROR_URL = 'http://archive.ubuntu.com/ubuntu'\n    APT_CACHER_NG_URL = 'http://localhost:3142/ubuntu'\n\n    def select_bootloader(self):\n        return BOOTLOADER__HOST_EXTLINUX\n\n    def check_release(self):\n        pass\n\n    def get_kernel_package_name(self, architecture):\n        return 'linux-image-generic'\n\n    def adjust_grub_defaults(self, with_openstack):\n        super(UbuntuStrategy, self).adjust_grub_defaults(with_openstack)\n\n        subst = (\n            ('GRUB_TIMEOUT=', 'GRUB_TIMEOUT=1'),\n            ('GRUB_HIDDEN_TIMEOUT', None),\n        )\n        etc_default_grub = os.path.join(self._abs_mountpoint, 'etc/default/grub')\n        with open(etc_default_grub, 'r') as f:\n            content = f.read()\n\n        lines_to_write = []\n        for line in content.split('\\n'):\n            for prefix, replacement in subst:\n                if line.startswith(prefix):\n                    if replacement is None:\n                        line = '## ' + line\n                    else:\n                        line = replacement\n            lines_to_write.append(line)\n\n        self._messenger.info('Adjusting file \"%s\"...' % etc_default_grub)\n        with open(etc_default_grub, 'w') as f:\n            f.write('\\n'.join(lines_to_write))\n\n    def install_cloud_init_and_friends(self):\n        # Do not install cloud-initramfs-growroot (from universe)\n        # if cloud-init and growpart alone work just fine\n        self._install_packages(['cloud-init', 'cloud-utils'])\n\n    def uses_systemd(self):\n        # NOTE: assumes not supporting anything older than trusty\n        return self._release != 'trusty'\n\n    def uses_systemd_resolved(self, with_openstack):\n        return False\n\n    def get_minimum_size_bytes(self):\n        return 2 * 1024**3\n",
    "uncovered_lines": [
      4,
      6,
      7,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      18,
      19,
      21,
      24,
      25,
      27,
      28,
      30,
      34,
      35,
      36,
      38,
      39,
      40,
      41,
      42,
      43,
      45,
      46,
      48,
      49,
      50,
      52,
      55,
      57,
      59,
      61,
      62,
      64,
      65
    ]
  },
  {
    "file_path": "image_bootstrap/loaders/_yaml.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\n\n\nimport sys\n\ntry:\n    from yaml import safe_dump, safe_load\nexcept ImportError:\n    print('ERROR: Please install PyYAML '\n        '(https://pypi.python.org/pypi/PyYAML).  '\n        'Thank you!', file=sys.stderr)\n    sys.exit(1)\n\n# Mark as used\nsafe_dump\nsafe_load\n\ndel sys\n",
    "uncovered_lines": [
      6,
      8,
      9,
      10,
      11,
      14,
      17,
      18,
      20
    ]
  },
  {
    "file_path": "image_bootstrap/types/disk_id.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\nimport re\n\n_DISK_ID_PATTERN = '^0x[0-9a-fA-F]{1,8}$'\n_DISK_ID_MATCHER = re.compile(_DISK_ID_PATTERN)\n\n\ndef _hex_string_to_number(text):\n    if not _DISK_ID_MATCHER.match(text):\n        raise ValueError('\"%s\" does not match pattern \"%s\"' % (text, _DISK_ID_PATTERN))\n\n    return int(text, 16)\n\n\nclass DiskIdentifier(object):\n    def __init__(self, number):\n        self._number = number\n\n    def __str__(self):\n        return '0x%8x' % self._number\n\n    def byte_sequence(self):\n        return ''.join([chr((self._number >> i * 8) & 255) for i in range(4)])\n\n\ndef disk_id_type(text):\n    \"\"\"\n    Meant to be used as an argparse type\n    \"\"\"\n    return DiskIdentifier(_hex_string_to_number(text))\n\n\ndisk_id_type.__name__ = 'disk identifier'\n",
    "uncovered_lines": [
      4,
      6,
      7,
      10,
      11,
      12,
      14,
      17,
      18,
      19,
      21,
      22,
      24,
      25,
      28,
      32,
      35
    ]
  },
  {
    "file_path": "image_bootstrap/types/machine_id.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\nimport re\n\n_MACHINE_ID_PATTERN = '^[0-9a-f]{32}$'\n_MACHINE_ID_MATCHER = re.compile(_MACHINE_ID_PATTERN)\n\n\ndef machine_id_type(text):\n    \"\"\"\n    Meant to be used as an argparse type\n    \"\"\"\n    if not _MACHINE_ID_MATCHER.match(text):\n        raise ValueError('\"%s\" does not match pattern \"%s\"' % (text, _MACHINE_ID_PATTERN))\n    return text\n\n\nmachine_id_type.__name__ = 'machine identifier'\n",
    "uncovered_lines": [
      4,
      6,
      7,
      10,
      14,
      15,
      16,
      19
    ]
  },
  {
    "file_path": "image_bootstrap/types/uuid.py",
    "code": "# Copyright (C) 2015 Sebastian Pipping <sebastian@pipping.org>\n# Licensed under AGPL v3 or later\n\nimport re\n\n_UUID_PATTERN = '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'\n_SANE_UUID_CHECKER = re.compile(_UUID_PATTERN)\n\n\ndef require_valid_uuid(text):\n    if not _SANE_UUID_CHECKER.match(text):\n        raise ValueError('Not a well-formed UUID: \"%s\"' % text)\n\n\ndef uuid_type(text):\n    \"\"\"\n    Meant to be used as an argparse type\n    \"\"\"\n    require_valid_uuid(text)\n    return text\n\n\nuuid_type.__name__ = 'UUID'\n",
    "uncovered_lines": [
      4,
      6,
      7,
      10,
      11,
      12,
      15,
      19,
      20,
      23
    ]
  }
]
[
  {
    "file_path": "xendit/api_client.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport json\nimport atexit\nimport mimetypes\nfrom multiprocessing.pool import ThreadPool\nimport io\nimport os\nimport re\nimport typing\nimport base64\nfrom urllib.parse import quote\nfrom urllib3.fields import RequestField\n\n\nfrom xendit import rest\nfrom xendit.configuration import Configuration\nfrom xendit.exceptions import ApiTypeError, ApiValueError, XenditSdkException\nfrom xendit.model_utils import (\n    ModelNormal,\n    ModelSimple,\n    ModelComposed,\n    check_allowed_values,\n    check_validations,\n    date,\n    datetime,\n    deserialize_file,\n    file_type,\n    model_to_dict,\n    none_type,\n    validate_and_convert_types\n)\n\n\nclass ApiClient(object):\n    \"\"\"Generic API client for OpenAPI client library builds.\n\n    OpenAPI generic API client. This client handles the client-\n    server communication, and is invariant across implementations. Specifics of\n    the methods and models for each application are generated from the OpenAPI\n    templates.\n\n    NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n    Do not edit the class manually.\n\n    :param configuration: .Configuration object for this client\n    :param header_name: a header to pass when making calls to the API.\n    :param header_value: a header value to pass when making calls to\n        the API.\n    :param cookie: a cookie to include in the header when making calls\n        to the API\n    :param pool_threads: The number of threads to use for async requests\n        to the API. More threads means more concurrent API requests.\n    \"\"\"\n\n    _pool = None\n\n    def __init__(self, configuration=None, header_name=None, header_value=None,\n                 cookie=None, pool_threads=1):\n        if configuration is None:\n            configuration = Configuration.get_default_copy()\n        self.configuration = configuration\n        self.pool_threads = pool_threads\n\n        self.rest_client = rest.RESTClientObject(configuration)\n        self.default_headers = {}\n        if header_name is not None:\n            self.default_headers[header_name] = header_value\n\n\n        # XENDIT headers\n        self.default_headers['xendit-lib'] = 'python'\n        self.default_headers['xendit-lib-ver'] = '7.0.0'\n            \n        self.cookie = cookie\n        # Set default User-Agent.\n        self.user_agent = 'OpenAPI-Generator/7.0.0/python'\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.close()\n\n    def close(self):\n        if self._pool:\n            self._pool.close()\n            self._pool.join()\n            self._pool = None\n            if hasattr(atexit, 'unregister'):\n                atexit.unregister(self.close)\n\n    @property\n    def pool(self):\n        \"\"\"Create thread pool on first request\n         avoids instantiating unused threadpool for blocking clients.\n        \"\"\"\n        if self._pool is None:\n            atexit.register(self.close)\n            self._pool = ThreadPool(self.pool_threads)\n        return self._pool\n\n    @property\n    def user_agent(self):\n        \"\"\"User agent for this API client\"\"\"\n        return self.default_headers['User-Agent']\n\n    @user_agent.setter\n    def user_agent(self, value):\n        self.default_headers['User-Agent'] = value\n\n    def set_default_header(self, header_name, header_value):\n        self.default_headers[header_name] = header_value\n\n    def auth(self, apikey):\n        return \"Basic \" + base64.b64encode((apikey + \":\").encode('utf-8')).decode('utf-8')\n\n    def __call_api(\n        self,\n        resource_path: str,\n        method: str,\n        path_params: typing.Optional[typing.Dict[str, typing.Any]] = None,\n        query_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,\n        header_params: typing.Optional[typing.Dict[str, typing.Any]] = None,\n        body: typing.Optional[typing.Any] = None,\n        post_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,\n        files: typing.Optional[typing.Dict[str, typing.List[io.IOBase]]] = None,\n        response_type: typing.Optional[typing.Tuple[typing.Any]] = None,\n        auth_settings: typing.Optional[typing.List[str]] = None,\n        _return_http_data_only: typing.Optional[bool] = None,\n        collection_formats: typing.Optional[typing.Dict[str, str]] = None,\n        _preload_content: bool = True,\n        _request_timeout: typing.Optional[typing.Union[int, float, typing.Tuple]] = None,\n        _host: typing.Optional[str] = None,\n        _check_type: typing.Optional[bool] = None,\n        _content_type: typing.Optional[str] = None,\n        _request_auths: typing.Optional[typing.List[typing.Dict[str, typing.Any]]] = None\n    ):\n\n        config = self.configuration\n\n        # header parameters\n        header_params = header_params or {}\n        header_params.update(self.default_headers)\n        if self.cookie:\n            header_params['Cookie'] = self.cookie\n        if header_params:\n            header_params = self.sanitize_for_serialization(header_params)\n            header_params = dict(self.parameters_to_tuples(header_params,\n                                                           collection_formats))\n\n        # path parameters\n        if path_params:\n            path_params = self.sanitize_for_serialization(path_params)\n            path_params = self.parameters_to_tuples(path_params,\n                                                    collection_formats)\n            for k, v in path_params:\n                # specified safe chars, encode everything\n                resource_path = resource_path.replace(\n                    '{%s}' % k,\n                    quote(str(v), safe=config.safe_chars_for_path_param)\n                )\n\n        # query parameters\n        if query_params:\n            query_params = self.sanitize_for_serialization(query_params)\n            query_params = self.parameters_to_tuples(query_params,\n                                                     collection_formats)\n\n        # post parameters\n        if post_params or files:\n            post_params = post_params if post_params else []\n            post_params = self.sanitize_for_serialization(post_params)\n            post_params = self.parameters_to_tuples(post_params,\n                                                    collection_formats)\n            post_params.extend(self.files_parameters(files))\n            if header_params['Content-Type'].startswith(\"multipart\"):\n                post_params = self.parameters_to_multipart(post_params,\n                                                           (dict))\n\n        # body\n        if body:\n            body = self.sanitize_for_serialization(body)\n\n        # auth setting\n        header_params['Authorization'] = self.auth(config.api_key)\n\n        # request url\n        if _host is None:\n            url = self.configuration.host + resource_path\n        else:\n            # use server/host defined in path or operation instead\n            url = _host + resource_path\n\n        try:\n            # perform request and return response\n            response_data = self.request(\n                method, url, query_params=query_params, headers=header_params,\n                post_params=post_params, body=body,\n                _preload_content=_preload_content,\n                _request_timeout=_request_timeout)\n        except XenditSdkException as e:\n            raise e\n\n        self.last_response = response_data\n\n        return_data = response_data\n\n        if not _preload_content:\n            return (return_data)\n            return return_data\n\n        # deserialize response data\n        if response_type:\n            if response_type != (file_type,):\n                encoding = \"utf-8\"\n                content_type = response_data.getheader('content-type')\n                if content_type is not None:\n                    match = re.search(r\"charset=([a-zA-Z\\-\\d]+)[\\s\\;]?\", content_type)\n                    if match:\n                        encoding = match.group(1)\n                response_data.data = response_data.data.decode(encoding)\n\n            return_data = self.deserialize(\n                response_data,\n                response_type,\n                _check_type\n            )\n        else:\n            return_data = None\n\n        if _return_http_data_only:\n            return (return_data)\n        else:\n            return (return_data, response_data.status,\n                    response_data.getheaders())\n\n    def parameters_to_multipart(self, params, collection_types):\n        \"\"\"Get parameters as list of tuples, formatting as json if value is collection_types\n\n        :param params: Parameters as list of two-tuples\n        :param dict collection_types: Parameter collection types\n        :return: Parameters as list of tuple or urllib3.fields.RequestField\n        \"\"\"\n        new_params = []\n        if collection_types is None:\n            collection_types = (dict)\n        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501\n            if isinstance(\n                     v, collection_types): # v is instance of collection_type, formatting as application/json\n                v = json.dumps(v, ensure_ascii=False).encode(\"utf-8\")\n                field = RequestField(k, v)\n                field.make_multipart(content_type=\"application/json; charset=utf-8\")\n                new_params.append(field)\n            else:\n                new_params.append((k, v))\n        return new_params\n\n    @classmethod\n    def sanitize_for_serialization(cls, obj):\n        \"\"\"Prepares data for transmission before it is sent with the rest client\n        If obj is None, return None.\n        If obj is str, int, long, float, bool, return directly.\n        If obj is datetime.datetime, datetime.date\n            convert to string in iso8601 format.\n        If obj is list, sanitize each element in the list.\n        If obj is dict, return the dict.\n        If obj is OpenAPI model, return the properties dict.\n        If obj is io.IOBase, return the bytes\n        :param obj: The data to serialize.\n        :return: The serialized form of data.\n        \"\"\"\n        if isinstance(obj, (ModelNormal, ModelComposed)):\n            return {\n                key: cls.sanitize_for_serialization(val) for key,\n                val in model_to_dict(\n                    obj,\n                    serialize=True).items()}\n        elif isinstance(obj, io.IOBase):\n            return cls.get_file_data_and_close_file(obj)\n        elif isinstance(obj, (str, int, float, none_type, bool)):\n            return obj\n        elif isinstance(obj, (datetime, date)):\n            return obj.isoformat()\n        elif isinstance(obj, ModelSimple):\n            return cls.sanitize_for_serialization(obj.value)\n        elif isinstance(obj, list):\n            return [cls.sanitize_for_serialization(item) for item in obj]\n        elif isinstance(obj, tuple):\n            return tuple(cls.sanitize_for_serialization(item) for item in obj)\n        if isinstance(obj, dict):\n            return {key: cls.sanitize_for_serialization(val) for key, val in obj.items()}\n        raise ApiValueError(\n            'Unable to prepare type {} for serialization'.format(\n                obj.__class__.__name__))\n\n    def deserialize(self, response, response_type, _check_type):\n        \"\"\"Deserializes response into an object.\n\n        :param response: RESTResponse object to be deserialized.\n        :param response_type: For the response, a tuple containing:\n            valid classes\n            a list containing valid classes (for list schemas)\n            a dict containing a tuple of valid classes as the value\n            Example values:\n            (str,)\n            (Pet,)\n            (float, none_type)\n            ([int, none_type],)\n            ({str: (bool, str, int, float, date, datetime, str, none_type)},)\n        :param _check_type: boolean, whether to check the types of the data\n            received from the server\n        :type _check_type: bool\n\n        :return: deserialized object.\n        \"\"\"\n        # handle file downloading\n        # save response body into a tmp file and return the instance\n        if response_type == (file_type,):\n            content_disposition = response.getheader(\"Content-Disposition\")\n            return deserialize_file(response.data, self.configuration,\n                                    content_disposition=content_disposition)\n\n        # fetch data from response object\n        try:\n            received_data = json.loads(response.data)\n        except ValueError:\n            received_data = response.data\n\n        # store our data under the key of 'received_data' so users have some\n        # context if they are deserializing a string and the data type is wrong\n        deserialized_data = validate_and_convert_types(\n            received_data,\n            response_type,\n            ['received_data'],\n            True,\n            _check_type,\n            configuration=self.configuration\n        )\n        return deserialized_data\n\n    def call_api(\n        self,\n        resource_path: str,\n        method: str,\n        path_params: typing.Optional[typing.Dict[str, typing.Any]] = None,\n        query_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,\n        header_params: typing.Optional[typing.Dict[str, typing.Any]] = None,\n        body: typing.Optional[typing.Any] = None,\n        post_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,\n        files: typing.Optional[typing.Dict[str, typing.List[io.IOBase]]] = None,\n        response_type: typing.Optional[typing.Tuple[typing.Any]] = None,\n        auth_settings: typing.Optional[typing.List[str]] = None,\n        async_req: typing.Optional[bool] = None,\n        _return_http_data_only: typing.Optional[bool] = None,\n        collection_formats: typing.Optional[typing.Dict[str, str]] = None,\n        _preload_content: bool = True,\n        _request_timeout: typing.Optional[typing.Union[int, float, typing.Tuple]] = None,\n        _host: typing.Optional[str] = None,\n        _check_type: typing.Optional[bool] = None,\n        _request_auths: typing.Optional[typing.List[typing.Dict[str, typing.Any]]] = None\n    ):\n        \"\"\"Makes the HTTP request (synchronous) and returns deserialized data.\n\n        To make an async_req request, set the async_req parameter.\n\n        :param resource_path: Path to method endpoint.\n        :param method: Method to call.\n        :param path_params: Path parameters in the url.\n        :param query_params: Query parameters in the url.\n        :param header_params: Header parameters to be\n            placed in the request header.\n        :param body: Request body.\n        :param post_params dict: Request post form parameters,\n            for `application/x-www-form-urlencoded`, `multipart/form-data`.\n        :param auth_settings list: Auth Settings names for the request.\n        :param response_type: For the response, a tuple containing:\n            valid classes\n            a list containing valid classes (for list schemas)\n            a dict containing a tuple of valid classes as the value\n            Example values:\n            (str,)\n            (Pet,)\n            (float, none_type)\n            ([int, none_type],)\n            ({str: (bool, str, int, float, date, datetime, str, none_type)},)\n        :param files: key -> field name, value -> a list of open file\n            objects for `multipart/form-data`.\n        :type files: dict\n        :param async_req bool: execute request asynchronously\n        :type async_req: bool, optional\n        :param _return_http_data_only: response data without head status code\n                                       and headers\n        :type _return_http_data_only: bool, optional\n        :param collection_formats: dict of collection formats for path, query,\n            header, and post parameters.\n        :type collection_formats: dict, optional\n        :param _preload_content: if False, the urllib3.HTTPResponse object will\n                                 be returned without reading/decoding response\n                                 data. Default is True.\n        :type _preload_content: bool, optional\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :param _check_type: boolean describing if the data back from the server\n            should have its type checked.\n        :type _check_type: bool, optional\n        :param _request_auths: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :type _request_auths: list, optional\n        :return:\n            If async_req parameter is True,\n            the request will be called asynchronously.\n            The method will return the request thread.\n            If parameter async_req is False or missing,\n            then the method will return the response directly.\n        \"\"\"\n        if not async_req:\n            return self.__call_api(resource_path, method,\n                                   path_params, query_params, header_params,\n                                   body, post_params, files,\n                                   response_type, auth_settings,\n                                   _return_http_data_only, collection_formats,\n                                   _preload_content, _request_timeout, _host,\n                                   _check_type, _request_auths=_request_auths)\n\n        return self.pool.apply_async(self.__call_api, (resource_path,\n                                                       method, path_params,\n                                                       query_params,\n                                                       header_params, body,\n                                                       post_params, files,\n                                                       response_type,\n                                                       auth_settings,\n                                                       _return_http_data_only,\n                                                       collection_formats,\n                                                       _preload_content,\n                                                       _request_timeout,\n                                                       _host, _check_type, None, _request_auths))\n\n    def request(self, method, url, query_params=None, headers=None,\n                post_params=None, body=None, _preload_content=True,\n                _request_timeout=None):\n        \"\"\"Makes the HTTP request using RESTClient.\"\"\"\n        if method == \"GET\":\n            return self.rest_client.GET(url,\n                                        query_params=query_params,\n                                        _preload_content=_preload_content,\n                                        _request_timeout=_request_timeout,\n                                        headers=headers)\n        elif method == \"HEAD\":\n            return self.rest_client.HEAD(url,\n                                         query_params=query_params,\n                                         _preload_content=_preload_content,\n                                         _request_timeout=_request_timeout,\n                                         headers=headers)\n        elif method == \"OPTIONS\":\n            return self.rest_client.OPTIONS(url,\n                                            query_params=query_params,\n                                            headers=headers,\n                                            post_params=post_params,\n                                            _preload_content=_preload_content,\n                                            _request_timeout=_request_timeout,\n                                            body=body)\n        elif method == \"POST\":\n            return self.rest_client.POST(url,\n                                         query_params=query_params,\n                                         headers=headers,\n                                         post_params=post_params,\n                                         _preload_content=_preload_content,\n                                         _request_timeout=_request_timeout,\n                                         body=body)\n        elif method == \"PUT\":\n            return self.rest_client.PUT(url,\n                                        query_params=query_params,\n                                        headers=headers,\n                                        post_params=post_params,\n                                        _preload_content=_preload_content,\n                                        _request_timeout=_request_timeout,\n                                        body=body)\n        elif method == \"PATCH\":\n            return self.rest_client.PATCH(url,\n                                          query_params=query_params,\n                                          headers=headers,\n                                          post_params=post_params,\n                                          _preload_content=_preload_content,\n                                          _request_timeout=_request_timeout,\n                                          body=body)\n        elif method == \"DELETE\":\n            return self.rest_client.DELETE(url,\n                                           query_params=query_params,\n                                           headers=headers,\n                                           _preload_content=_preload_content,\n                                           _request_timeout=_request_timeout,\n                                           body=body)\n        else:\n            raise ApiValueError(\n                \"http method must be `GET`, `HEAD`, `OPTIONS`,\"\n                \" `POST`, `PATCH`, `PUT` or `DELETE`.\"\n            )\n\n    def parameters_to_tuples(self, params, collection_formats):\n        \"\"\"Get parameters as list of tuples, formatting collections.\n\n        :param params: Parameters as dict or list of two-tuples\n        :param dict collection_formats: Parameter collection formats\n        :return: Parameters as list of tuples, collections formatted\n        \"\"\"\n        new_params = []\n        if collection_formats is None:\n            collection_formats = {}\n        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501\n            if k in collection_formats:\n                collection_format = collection_formats[k]\n                if collection_format == 'multi':\n                    new_params.extend((k, value) for value in v)\n                else:\n                    if collection_format == 'ssv':\n                        delimiter = ' '\n                    elif collection_format == 'tsv':\n                        delimiter = '\\t'\n                    elif collection_format == 'pipes':\n                        delimiter = '|'\n                    else:  # csv is the default\n                        delimiter = ','\n                    new_params.append(\n                        (k, delimiter.join(str(value) for value in v)))\n            else:\n                new_params.append((k, v))\n        return new_params\n\n    @staticmethod\n    def get_file_data_and_close_file(file_instance: io.IOBase) -> bytes:\n        file_data = file_instance.read()\n        file_instance.close()\n        return file_data\n\n    def files_parameters(self,\n                         files: typing.Optional[typing.Dict[str,\n                                                            typing.List[io.IOBase]]] = None):\n        \"\"\"Builds form parameters.\n\n        :param files: None or a dict with key=param_name and\n            value is a list of open file objects\n        :return: List of tuples of form parameters with file data\n        \"\"\"\n        if files is None:\n            return []\n\n        params = []\n        for param_name, file_instances in files.items():\n            if file_instances is None:\n                # if the file field is nullable, skip None values\n                continue\n            for file_instance in file_instances:\n                if file_instance is None:\n                    # if the file field is nullable, skip None values\n                    continue\n                if file_instance.closed is True:\n                    raise ApiValueError(\n                        \"Cannot read a closed file. The passed in file_type \"\n                        \"for %s must be open.\" % param_name\n                    )\n                filename = os.path.basename(file_instance.name)\n                filedata = self.get_file_data_and_close_file(file_instance)\n                mimetype = (mimetypes.guess_type(filename)[0] or\n                            'application/octet-stream')\n                params.append(\n                    tuple([param_name, tuple([filename, filedata, mimetype])]))\n\n        return params\n\n    def select_header_accept(self, accepts):\n        \"\"\"Returns `Accept` based on an array of accepts provided.\n\n        :param accepts: List of headers.\n        :return: Accept (e.g. application/json).\n        \"\"\"\n        if not accepts:\n            return\n\n        accepts = [x.lower() for x in accepts]\n\n        if 'application/json' in accepts:\n            return 'application/json'\n        else:\n            return ', '.join(accepts)\n\n    def select_header_content_type(self, content_types, method=None, body=None):\n        \"\"\"Returns `Content-Type` based on an array of content_types provided.\n\n        :param content_types: List of content-types.\n        :param method: http method (e.g. POST, PATCH).\n        :param body: http body to send.\n        :return: Content-Type (e.g. application/json).\n        \"\"\"\n        if not content_types:\n            return None\n\n        content_types = [x.lower() for x in content_types]\n\n        if (method == 'PATCH' and\n                'application/json-patch+json' in content_types and\n                isinstance(body, list)):\n            return 'application/json-patch+json'\n\n        if 'application/json' in content_types or '*/*' in content_types:\n            return 'application/json'\n        else:\n            return content_types[0]\n\n    def update_params_for_auth(self, headers, queries, auth_settings,\n                               resource_path, method, body, request_auths=None):\n        \"\"\"Updates header and query params based on authentication setting.\n\n        :param headers: Header parameters dict to be updated.\n        :param queries: Query parameters tuple list to be updated.\n        :param auth_settings: Authentication setting identifiers list.\n        :param resource_path: A string representation of the HTTP request resource path.\n        :param method: A string representation of the HTTP request method.\n        :param body: A object representing the body of the HTTP request.\n            The object type is the return value of _encoder.default().\n        :param request_auths: if set, the provided settings will\n            override the token in the configuration.\n        \"\"\"\n        if not auth_settings:\n            return\n\n        if request_auths:\n            for auth_setting in request_auths:\n                self._apply_auth_params(\n                    headers, queries, resource_path, method, body, auth_setting)\n            return\n\n        for auth in auth_settings:\n            auth_setting = self.configuration.auth_settings().get(auth)\n            if auth_setting:\n                self._apply_auth_params(\n                    headers, queries, resource_path, method, body, auth_setting)\n\n    def _apply_auth_params(self, headers, queries, resource_path, method, body, auth_setting):\n        if auth_setting['in'] == 'cookie':\n            headers['Cookie'] = auth_setting['key'] + \"=\" + auth_setting['value']\n        elif auth_setting['in'] == 'header':\n            if auth_setting['type'] != 'http-signature':\n                headers[auth_setting['key']] = auth_setting['value']\n        elif auth_setting['in'] == 'query':\n            queries.append((auth_setting['key'], auth_setting['value']))\n        else:\n            raise ApiValueError(\n                'Authentication token must be in `query` or `header`'\n            )\n\n\nclass Endpoint(object):\n    def __init__(self, settings=None, params_map=None, root_map=None,\n                 headers_map=None, api_client=None, callable=None):\n        \"\"\"Creates an endpoint\n\n        Args:\n            settings (dict): see below key value pairs\n                'response_type' (tuple/None): response type\n                'auth' (list): a list of auth type keys\n                'endpoint_path' (str): the endpoint path\n                'operation_id' (str): endpoint string identifier\n                'http_method' (str): POST/PUT/PATCH/GET etc\n                'servers' (list): list of str servers that this endpoint is at\n            params_map (dict): see below key value pairs\n                'all' (list): list of str endpoint parameter names\n                'required' (list): list of required parameter names\n                'nullable' (list): list of nullable parameter names\n                'enum' (list): list of parameters with enum values\n                'validation' (list): list of parameters with validations\n            root_map\n                'validations' (dict): the dict mapping endpoint parameter tuple\n                    paths to their validation dictionaries\n                'allowed_values' (dict): the dict mapping endpoint parameter\n                    tuple paths to their allowed_values (enum) dictionaries\n                'openapi_types' (dict): param_name to openapi type\n                'attribute_map' (dict): param_name to camelCase name\n                'location_map' (dict): param_name to  'body', 'file', 'form',\n                    'header', 'path', 'query'\n                collection_format_map (dict): param_name to `csv` etc.\n            headers_map (dict): see below key value pairs\n                'accept' (list): list of Accept header strings\n                'content_type' (list): list of Content-Type header strings\n            api_client (ApiClient) api client instance\n            callable (function): the function which is invoked when the\n                Endpoint is called\n        \"\"\"\n        self.settings = settings\n        self.params_map = params_map\n        self.params_map['all'].extend([\n            'async_req',\n            '_host_index',\n            '_preload_content',\n            '_request_timeout',\n            '_return_http_data_only',\n            '_check_input_type',\n            '_check_return_type',\n            '_content_type',\n            '_spec_property_naming',\n            '_request_auths'\n        ])\n        self.params_map['nullable'].extend(['_request_timeout'])\n        self.validations = root_map['validations']\n        self.allowed_values = root_map['allowed_values']\n        self.openapi_types = root_map['openapi_types']\n        extra_types = {\n            'async_req': (bool,),\n            '_host_index': (none_type, int),\n            '_preload_content': (bool,),\n            '_request_timeout': (none_type, float, (float,), [float], int, (int,), [int]),\n            '_return_http_data_only': (bool,),\n            '_check_input_type': (bool,),\n            '_check_return_type': (bool,),\n            '_spec_property_naming': (bool,),\n            '_content_type': (none_type, str),\n            '_request_auths': (none_type, list)\n        }\n        self.openapi_types.update(extra_types)\n        self.attribute_map = root_map['attribute_map']\n        self.location_map = root_map['location_map']\n        self.collection_format_map = root_map['collection_format_map']\n        self.headers_map = headers_map\n        self.api_client = api_client\n        self.callable = callable\n\n    def __validate_inputs(self, kwargs):\n        for param in self.params_map['enum']:\n            if param in kwargs:\n                check_allowed_values(\n                    self.allowed_values,\n                    (param,),\n                    kwargs[param]\n                )\n\n        for param in self.params_map['validation']:\n            if param in kwargs:\n                check_validations(\n                    self.validations,\n                    (param,),\n                    kwargs[param],\n                    configuration=self.api_client.configuration\n                )\n\n        if kwargs['_check_input_type'] is False:\n            return\n\n        for key, value in kwargs.items():\n            fixed_val = validate_and_convert_types(\n                value,\n                self.openapi_types[key],\n                [key],\n                kwargs['_spec_property_naming'],\n                kwargs['_check_input_type'],\n                configuration=self.api_client.configuration\n            )\n            kwargs[key] = fixed_val\n\n    def __gather_params(self, kwargs):\n        params = {\n            'body': None,\n            'collection_format': {},\n            'file': {},\n            'form': [],\n            'header': {},\n            'path': {},\n            'query': []\n        }\n\n        for param_name, param_value in kwargs.items():\n            param_location = self.location_map.get(param_name)\n            if param_location is None:\n                continue\n            if param_location:\n                if param_location == 'body':\n                    params['body'] = param_value\n                    continue\n                base_name = self.attribute_map[param_name]\n                if (param_location == 'form' and\n                        self.openapi_types[param_name] == (file_type,)):\n                    params['file'][base_name] = [param_value]\n                elif (param_location == 'form' and\n                        self.openapi_types[param_name] == ([file_type],)):\n                    # param_value is already a list\n                    params['file'][base_name] = param_value\n                elif param_location in {'form', 'query'}:\n                    param_value_full = (base_name, param_value)\n                    params[param_location].append(param_value_full)\n                if param_location not in {'form', 'query'}:\n                    params[param_location][base_name] = param_value\n                collection_format = self.collection_format_map.get(param_name)\n                if collection_format:\n                    params['collection_format'][base_name] = collection_format\n\n        return params\n\n    def __call__(self, *args, **kwargs):\n        \"\"\" This method is invoked when endpoints are called\n        Example:\n\n        api_instance = PaymentRequestApi()\n        api_instance.create_payment_request  # this is an instance of the class Endpoint\n        api_instance.create_payment_request()  # this invokes api_instance.create_payment_request.__call__()\n        which then invokes the callable functions stored in that endpoint at\n        api_instance.create_payment_request.callable or self.callable in this class\n\n        \"\"\"\n        return self.callable(self, *args, **kwargs)\n\n    def call_with_http_info(self, **kwargs):\n\n        try:\n            index = self.api_client.configuration.server_operation_index.get(\n                self.settings['operation_id'], self.api_client.configuration.server_index\n            ) if kwargs['_host_index'] is None else kwargs['_host_index']\n            server_variables = self.api_client.configuration.server_operation_variables.get(\n                self.settings['operation_id'], self.api_client.configuration.server_variables\n            )\n            _host = self.api_client.configuration.get_host_from_settings(\n                index, variables=server_variables, servers=self.settings['servers']\n            )\n        except IndexError:\n            if self.settings['servers']:\n                raise ApiValueError(\n                    \"Invalid host index. Must be 0 <= index < %s\" %\n                    len(self.settings['servers'])\n                )\n            _host = None\n\n        for key, value in kwargs.items():\n            if key not in self.params_map['all']:\n                raise ApiTypeError(\n                    \"Got an unexpected parameter '%s'\"\n                    \" to method `%s`\" %\n                    (key, self.settings['operation_id'])\n                )\n            # only throw this nullable ApiValueError if _check_input_type\n            # is False, if _check_input_type==True we catch this case\n            # in self.__validate_inputs\n            if (key not in self.params_map['nullable'] and value is None\n                    and kwargs['_check_input_type'] is False):\n                raise ApiValueError(\n                    \"Value may not be None for non-nullable parameter `%s`\"\n                    \" when calling `%s`\" %\n                    (key, self.settings['operation_id'])\n                )\n\n        for key in self.params_map['required']:\n            if key not in kwargs.keys():\n                raise ApiValueError(\n                    \"Missing the required parameter `%s` when calling \"\n                    \"`%s`\" % (key, self.settings['operation_id'])\n                )\n\n        self.__validate_inputs(kwargs)\n\n        params = self.__gather_params(kwargs)\n\n        accept_headers_list = self.headers_map['accept']\n        if accept_headers_list:\n            params['header']['Accept'] = self.api_client.select_header_accept(\n                accept_headers_list)\n\n        if kwargs.get('_content_type'):\n            params['header']['Content-Type'] = kwargs['_content_type']\n        else:\n            content_type_headers_list = self.headers_map['content_type']\n            if content_type_headers_list:\n                if params['body'] != \"\":\n                    content_types_list = self.api_client.select_header_content_type(\n                        content_type_headers_list, self.settings['http_method'],\n                        params['body'])\n                    if content_types_list:\n                        params['header']['Content-Type'] = content_types_list\n\n        return self.api_client.call_api(\n            self.settings['endpoint_path'], self.settings['http_method'],\n            params['path'],\n            params['query'],\n            params['header'],\n            body=params['body'],\n            post_params=params['form'],\n            files=params['file'],\n            response_type=self.settings['response_type'],\n            auth_settings=self.settings['auth'],\n            async_req=kwargs['async_req'],\n            _check_type=kwargs['_check_return_type'],\n            _return_http_data_only=kwargs['_return_http_data_only'],\n            _preload_content=kwargs['_preload_content'],\n            _request_timeout=kwargs['_request_timeout'],\n            _host=_host,\n            _request_auths=kwargs['_request_auths'],\n            collection_formats=params['collection_format'])\n",
    "uncovered_lines": [
      65,
      72,
      84,
      87,
      90,
      91,
      92,
      93,
      94,
      95,
      102,
      103,
      104,
      105,
      110,
      117,
      150,
      170,
      171,
      176,
      177,
      178,
      180,
      181,
      182,
      193,
      194,
      197,
      199,
      201,
      206,
      207,
      209,
      211,
      213,
      214,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      228,
      234,
      236,
      237,
      239,
      249,
      250,
      251,
      252,
      253,
      255,
      256,
      257,
      258,
      260,
      261,
      284,
      288,
      290,
      292,
      294,
      297,
      323,
      324,
      325,
      329,
      330,
      331,
      332,
      336,
      344,
      433,
      450,
      451,
      456,
      457,
      462,
      463,
      470,
      471,
      478,
      479,
      486,
      487,
      494,
      495,
      502,
      516,
      519,
      520,
      521,
      523,
      524,
      525,
      526,
      527,
      528,
      530,
      531,
      539,
      540,
      541,
      552,
      553,
      555,
      556,
      557,
      559,
      560,
      561,
      563,
      564,
      565,
      569,
      570,
      571,
      573,
      576,
      585,
      592,
      603,
      610,
      615,
      631,
      632,
      634,
      635,
      636,
      638,
      640,
      641,
      642,
      643,
      647,
      648,
      649,
      650,
      651,
      652,
      653,
      655,
      736,
      737,
      744,
      745,
      753,
      788,
      792,
      794,
      795,
      800,
      815,
      829,
      830,
      831,
      835,
      839,
      849,
      857,
      872
    ]
  },
  {
    "file_path": "xendit/configuration.py",
    "code": "\"\"\"\n    XENDIT Client Configuration\n\"\"\"\nimport copy\nimport logging\nimport multiprocessing\nimport sys\nimport urllib3\n\nfrom http import client as http_client\nfrom xendit.exceptions import ApiValueError\n\nJSON_SCHEMA_VALIDATION_KEYWORDS = {\n    'multipleOf', 'maximum', 'exclusiveMaximum',\n    'minimum', 'exclusiveMinimum', 'maxLength',\n    'minLength', 'pattern', 'maxItems', 'minItems'\n}\n\ndef set_api_key(api_key):\n    config = Configuration()\n    config.api_key = api_key\n    config.set_default(config)\n\nclass Configuration(object):\n    \"\"\"NOTE: This class is auto generated\n    Do not edit the class manually.\n\n    :param host: Base url\n    :param api_key: Dict to store API key(s).\n      Each entry in the dict specifies an API key.\n      The dict key is the name of the security scheme in the OAS specification.\n      The dict value is the API key secret.\n    :param api_key_prefix: Dict to store API prefix (e.g. Bearer)\n      The dict key is the name of the security scheme in the OAS specification.\n      The dict value is an API key prefix when generating the auth data.\n    :param username: Username for HTTP basic authentication\n    :param password: Password for HTTP basic authentication\n    :param discard_unknown_keys: Boolean value indicating whether to discard\n      unknown properties. A server may send a response that includes additional\n      properties that are not known by the client in the following scenarios:\n      1. The OpenAPI document is incomplete, i.e. it does not match the server\n         implementation.\n      2. The client was generated using an older version of the OpenAPI document\n         and the server has been upgraded since then.\n      If a schema in the OpenAPI document defines the additionalProperties attribute,\n      then all undeclared properties received by the server are injected into the\n      additional properties map. In that case, there are undeclared properties, and\n      nothing to discard.\n    :param disabled_client_side_validations (string): Comma-separated list of\n      JSON schema validation keywords to disable JSON schema structural validation\n      rules. The following keywords may be specified: multipleOf, maximum,\n      exclusiveMaximum, minimum, exclusiveMinimum, maxLength, minLength, pattern,\n      maxItems, minItems.\n      By default, the validation is performed for data generated locally by the client\n      and data received from the server, independent of any validation performed by\n      the server side. If the input data does not satisfy the JSON schema validation\n      rules specified in the OpenAPI document, an exception is raised.\n      If disabled_client_side_validations is set, structural validation is\n      disabled. This can be useful to troubleshoot data validation problem, such as\n      when the OpenAPI document validation rules do not match the actual API data\n      received by the server.\n    :param server_index: Index to servers configuration.\n    :param server_variables: Mapping with string values to replace variables in\n      templated server configuration. The validation of enums is performed for\n      variables with defined enum values before.\n    :param server_operation_index: Mapping from operation ID to an index to server\n      configuration.\n    :param server_operation_variables: Mapping from operation ID to a mapping with\n      string values to replace variables in templated server configuration.\n      The validation of enums is performed for variables with defined enum values before.\n    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates\n      in PEM format\n    \"\"\"\n\n    _default = None\n\n    def __init__(self, host=None,\n                 api_key=None, api_key_prefix=None,\n                 access_token=None,\n                 discard_unknown_keys=False,\n                 disabled_client_side_validations=\"\",\n                 server_index=None, server_variables=None,\n                 server_operation_index=None, server_operation_variables=None,\n                 ssl_ca_cert=None,\n                 ):\n        \"\"\"Constructor\n        \"\"\"\n        self._base_path = \"https://api.xendit.co\" if host is None else host\n        \"\"\"Default Base url\n        \"\"\"\n        self.server_index = 0 if server_index is None and host is None else server_index\n        self.server_operation_index = server_operation_index or {}\n        \"\"\"Default server index\n        \"\"\"\n        self.server_variables = server_variables or {}\n        self.server_operation_variables = server_operation_variables or {}\n        \"\"\"Default server variables\n        \"\"\"\n        self.temp_folder_path = None\n        \"\"\"Temp file folder for downloading files\n        \"\"\"\n        # Authentication Settings\n        self.access_token = access_token\n        self.api_key = api_key\n        self.api_key_prefix = {}\n        if api_key_prefix:\n            self.api_key_prefix = api_key_prefix\n        self.refresh_api_key_hook = None\n        \"\"\"function hook to refresh API key if expired\n        \"\"\"\n        self.discard_unknown_keys = discard_unknown_keys\n        self.disabled_client_side_validations = disabled_client_side_validations\n        self.logger = {}\n        \"\"\"Logging Settings\n        \"\"\"\n        self.logger[\"package_logger\"] = logging.getLogger(\"xendit\")\n        self.logger[\"urllib3_logger\"] = logging.getLogger(\"urllib3\")\n        self.logger_format = '%(asctime)s %(levelname)s %(message)s'\n        \"\"\"Log format\n        \"\"\"\n        self.logger_stream_handler = None\n        \"\"\"Log stream handler\n        \"\"\"\n        self.logger_file_handler = None\n        \"\"\"Log file handler\n        \"\"\"\n        self.logger_file = None\n        \"\"\"Debug file location\n        \"\"\"\n        self.debug = False\n        \"\"\"Debug switch\n        \"\"\"\n\n        self.verify_ssl = True\n        \"\"\"SSL/TLS verification\n           Set this to false to skip verifying SSL certificate when calling API\n           from https server.\n        \"\"\"\n        self.ssl_ca_cert = ssl_ca_cert\n        \"\"\"Set this to customize the certificate file to verify the peer.\n        \"\"\"\n        self.cert_file = None\n        \"\"\"client certificate file\n        \"\"\"\n        self.key_file = None\n        \"\"\"client key file\n        \"\"\"\n        self.assert_hostname = None\n        \"\"\"Set this to True/False to enable/disable SSL hostname verification.\n        \"\"\"\n        self.tls_server_name = None\n        \"\"\"SSL/TLS Server Name Indication (SNI)\n           Set this to the SNI value expected by the server.\n        \"\"\"\n\n        self.connection_pool_maxsize = multiprocessing.cpu_count() * 5\n        \"\"\"urllib3 connection pool's maximum number of connections saved\n           per pool. urllib3 uses 1 connection as default value, but this is\n           not the best value when you are making a lot of possibly parallel\n           requests to the same host, which is often the case here.\n           cpu_count * 5 is used as default value to increase performance.\n        \"\"\"\n\n        self.proxy = None\n        \"\"\"Proxy URL\n        \"\"\"\n        self.no_proxy = None\n        \"\"\"bypass proxy for host in the no_proxy list.\n        \"\"\"\n        self.proxy_headers = None\n        \"\"\"Proxy headers\n        \"\"\"\n        self.safe_chars_for_path_param = ''\n        \"\"\"Safe chars for path_param\n        \"\"\"\n        self.retries = None\n        \"\"\"Adding retries to override urllib3 default value 3\n        \"\"\"\n        # Enable client side validation\n        self.client_side_validation = True\n\n        # Options to pass down to the underlying urllib3 socket\n        self.socket_options = None\n\n    def __deepcopy__(self, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for k, v in self.__dict__.items():\n            if k not in ('logger', 'logger_file_handler'):\n                setattr(result, k, copy.deepcopy(v, memo))\n        # shallow copy of loggers\n        result.logger = copy.copy(self.logger)\n        # use setters to configure loggers\n        result.logger_file = self.logger_file\n        result.debug = self.debug\n        return result\n\n    def __setattr__(self, name, value):\n        object.__setattr__(self, name, value)\n        if name == 'disabled_client_side_validations':\n            s = set(filter(None, value.split(',')))\n            for v in s:\n                if v not in JSON_SCHEMA_VALIDATION_KEYWORDS:\n                    raise ApiValueError(\n                        \"Invalid keyword: '{0}''\".format(v))\n            self._disabled_client_side_validations = s\n\n    @classmethod\n    def set_default(cls, default):\n        \"\"\"Set default instance of configuration.\n\n        It stores default configuration, which can be\n        returned by get_default_copy method.\n\n        :param default: object of Configuration\n        \"\"\"\n        cls._default = copy.deepcopy(default)\n\n    @classmethod\n    def get_default_copy(cls):\n        \"\"\"Return new instance of configuration.\n\n        This method returns newly created, based on default constructor,\n        object of Configuration class or returns a copy of default\n        configuration passed by the set_default method.\n\n        :return: The configuration object.\n        \"\"\"\n        if cls._default is not None:\n            return copy.deepcopy(cls._default)\n        return Configuration()\n\n    @property\n    def logger_file(self):\n        \"\"\"The logger file.\n\n        If the logger_file is None, then add stream handler and remove file\n        handler. Otherwise, add file handler and remove stream handler.\n\n        :param value: The logger_file path.\n        :type: str\n        \"\"\"\n        return self.__logger_file\n\n    @logger_file.setter\n    def logger_file(self, value):\n        \"\"\"The logger file.\n\n        If the logger_file is None, then add stream handler and remove file\n        handler. Otherwise, add file handler and remove stream handler.\n\n        :param value: The logger_file path.\n        :type: str\n        \"\"\"\n        self.__logger_file = value\n        if self.__logger_file:\n            # If set logging file,\n            # then add file handler and remove stream handler.\n            self.logger_file_handler = logging.FileHandler(self.__logger_file)\n            self.logger_file_handler.setFormatter(self.logger_formatter)\n            for _, logger in self.logger.items():\n                logger.addHandler(self.logger_file_handler)\n\n    @property\n    def debug(self):\n        \"\"\"Debug status\n\n        :param value: The debug status, True or False.\n        :type: bool\n        \"\"\"\n        return self.__debug\n\n    @debug.setter\n    def debug(self, value):\n        \"\"\"Debug status\n\n        :param value: The debug status, True or False.\n        :type: bool\n        \"\"\"\n        self.__debug = value\n        if self.__debug:\n            # if debug status is True, turn on debug logging\n            for _, logger in self.logger.items():\n                logger.setLevel(logging.DEBUG)\n            # turn on http_client debug\n            http_client.HTTPConnection.debuglevel = 1\n        else:\n            # if debug status is False, turn off debug logging,\n            # setting log level to default `logging.WARNING`\n            for _, logger in self.logger.items():\n                logger.setLevel(logging.WARNING)\n            # turn off http_client debug\n            http_client.HTTPConnection.debuglevel = 0\n\n    @property\n    def logger_format(self):\n        \"\"\"The logger format.\n\n        The logger_formatter will be updated when sets logger_format.\n\n        :param value: The format string.\n        :type: str\n        \"\"\"\n        return self.__logger_format\n\n    @logger_format.setter\n    def logger_format(self, value):\n        \"\"\"The logger format.\n\n        The logger_formatter will be updated when sets logger_format.\n\n        :param value: The format string.\n        :type: str\n        \"\"\"\n        self.__logger_format = value\n        self.logger_formatter = logging.Formatter(self.__logger_format)\n\n    def get_api_key_with_prefix(self, identifier, alias=None):\n        \"\"\"Gets API key (with prefix if set).\n\n        :param identifier: The identifier of apiKey.\n        :param alias: The alternative identifier of apiKey.\n        :return: The token for api key authentication.\n        \"\"\"\n        if self.refresh_api_key_hook is not None:\n            self.refresh_api_key_hook(self)\n        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)\n        if key:\n            prefix = self.api_key_prefix.get(identifier)\n            if prefix:\n                return \"%s %s\" % (prefix, key)\n            else:\n                return key\n\n    def get_basic_auth_token(self):\n        \"\"\"Gets HTTP basic authentication header (string).\n\n        :return: The token for basic HTTP authentication.\n        \"\"\"\n        username = \"\"\n        if self.username is not None:\n            username = self.username\n        password = \"\"\n        if self.password is not None:\n            password = self.password\n        return urllib3.util.make_headers(\n            basic_auth=username + ':' + password\n        ).get('authorization')\n\n    def auth_settings(self):\n        \"\"\"Gets Auth Settings dict for api client.\n\n        :return: The Auth Settings information dict.\n        \"\"\"\n        auth = {}\n        return auth\n\n    def to_debug_report(self):\n        \"\"\"Gets the essential information for debugging.\n\n        :return: The report for debugging.\n        \"\"\"\n        return \"Python SDK Debug Report:\\n\"\\\n               \"OS: {env}\\n\"\\\n               \"Python Version: {pyversion}\\n\"\\\n               \"Version of the API: 1.70.0\\n\"\\\n               \"SDK Package Version: 7.0.0\".\\\n               format(env=sys.platform, pyversion=sys.version)\n\n    def get_host_settings(self):\n        \"\"\"Gets an array of host settings\n\n        :return: An array of host settings\n        \"\"\"\n        return [\n            {\n                'url': \"https://api.xendit.co\",\n                'description': \"Xendit API Server\",\n            }\n        ]\n\n    def get_host_from_settings(self, index, variables=None, servers=None):\n        \"\"\"Gets host URL based on the index and variables\n        :param index: array index of the host settings\n        :param variables: hash of variable and the corresponding value\n        :param servers: an array of host settings or None\n        :return: URL based on host settings\n        \"\"\"\n        if index is None:\n            return self._base_path\n\n        variables = {} if variables is None else variables\n        servers = self.get_host_settings() if servers is None else servers\n\n        try:\n            server = servers[index]\n        except IndexError:\n            raise ValueError(\n                \"Invalid index {0} when selecting the host settings. \"\n                \"Must be less than {1}\".format(index, len(servers)))\n\n        url = server['url']\n\n        # go through variables and replace placeholders\n        for variable_name, variable in server.get('variables', {}).items():\n            used_value = variables.get(\n                variable_name, variable['default_value'])\n\n            if 'enum_values' in variable \\\n                    and used_value not in variable['enum_values']:\n                raise ValueError(\n                    \"The variable `{0}` in the host URL has invalid value \"\n                    \"{1}. Must be {2}.\".format(\n                        variable_name, variables[variable_name],\n                        variable['enum_values']))\n\n            url = url.replace(\"{\" + variable_name + \"}\", used_value)\n\n        return url\n\n    @property\n    def host(self):\n        \"\"\"Return generated host.\"\"\"\n        return self.get_host_from_settings(self.server_index, variables=self.server_variables)\n\n    @host.setter\n    def host(self, value):\n        \"\"\"Fix base path.\"\"\"\n        self._base_path = value\n        self.server_index = None\n",
    "uncovered_lines": [
      20,
      21,
      22,
      107,
      186,
      187,
      188,
      189,
      190,
      191,
      193,
      195,
      196,
      197,
      204,
      205,
      218,
      230,
      231,
      232,
      244,
      260,
      261,
      262,
      263,
      272,
      284,
      285,
      287,
      305,
      326,
      327,
      328,
      329,
      330,
      331,
      332,
      334,
      341,
      342,
      343,
      344,
      345,
      346,
      347,
      356,
      357,
      364,
      391,
      398,
      399,
      407,
      410,
      412,
      418,
      425,
      430,
      431
    ]
  },
  {
    "file_path": "xendit/exceptions.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\nimport json\n\nclass OpenApiException(Exception):\n    \"\"\"The base exception class for all OpenAPIExceptions\"\"\"\n\n\nclass ApiTypeError(OpenApiException, TypeError):\n    def __init__(self, msg, path_to_item=None, valid_classes=None,\n                 key_type=None):\n        \"\"\" Raises an exception for TypeErrors\n\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (list): a list of keys an indices to get to the\n                                 current_item\n                                 None if unset\n            valid_classes (tuple): the primitive classes that current item\n                                   should be an instance of\n                                   None if unset\n            key_type (bool): False if our value is a value in a dict\n                             True if it is a key in a dict\n                             False if our item is an item in a list\n                             None if unset\n        \"\"\"\n        self.path_to_item = path_to_item\n        self.valid_classes = valid_classes\n        self.key_type = key_type\n        full_msg = msg\n        if path_to_item:\n            full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n        super(ApiTypeError, self).__init__(full_msg)\n\n\nclass ApiValueError(OpenApiException, ValueError):\n    def __init__(self, msg, path_to_item=None):\n        \"\"\"\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (list) the path to the exception in the\n                received_data dict. None if unset\n        \"\"\"\n\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n        super(ApiValueError, self).__init__(full_msg)\n\n\nclass ApiAttributeError(OpenApiException, AttributeError):\n    def __init__(self, msg, path_to_item=None):\n        \"\"\"\n        Raised when an attribute reference or assignment fails.\n\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (None/list) the path to the exception in the\n                received_data dict\n        \"\"\"\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n        super(ApiAttributeError, self).__init__(full_msg)\n\n\nclass ApiKeyError(OpenApiException, KeyError):\n    def __init__(self, msg, path_to_item=None):\n        \"\"\"\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (None/list) the path to the exception in the\n                received_data dict\n        \"\"\"\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n        super(ApiKeyError, self).__init__(full_msg)\n\n\nclass XenditSdkException(OpenApiException):\n    def __init__(self, raw_response=None, param_status=None, param_status_text=None):\n        if raw_response is None:\n            self.rawResponse = raw_response\n            self.status = param_status or \"\"\n            self.errorCode = \"\"\n            self.errorMessage = param_status_text or \"\"\n        else:\n            raw_response = json.loads(raw_response.decode(encoding=\"utf-8\")) if isinstance(raw_response, bytes) else raw_response\n            self.rawResponse = raw_response\n\n            self.status = param_status or \"\"\n            if self.status == \"\" and \"status\" in raw_response and raw_response[\"status\"] is not None:\n                self.status = raw_response[\"status\"]\n            elif self.status == \"\" and \"status_code\" in raw_response and raw_response[\"status_code\"] is not None:\n                self.status = raw_response[\"status_code\"]\n            elif self.status == \"\" and \"statusCode\" in raw_response and raw_response[\"statusCode\"] is not None:\n                self.status = raw_response[\"statusCode\"]\n\n\n            if \"error\" in raw_response and raw_response[\"error\"] is not None:\n                self.errorCode = raw_response[\"error\"]\n            elif \"error_code\" in raw_response and raw_response[\"error_code\"] is not None:\n                self.errorCode = raw_response[\"error_code\"]\n            elif \"errorCode\" in raw_response and raw_response[\"errorCode\"] is not None:\n                self.errorCode = raw_response[\"errorCode\"]\n            else:\n                self.errorCode = \"\"\n\n            if \"message\" in raw_response and raw_response[\"message\"] is not None:\n                self.errorMessage = raw_response[\"message\"]\n            elif \"error_message\" in raw_response and raw_response[\"error_message\"] is not None:\n                self.errorMessage = raw_response[\"error_message\"]\n            elif \"errorMessage\" in raw_response and raw_response[\"errorMessage\"] is not None:\n                self.errorMessage = raw_response[\"errorMessage\"]\n            else:\n                self.errorMessage = param_status_text or \"\"\n\n    def __str__(self):\n        \"\"\"Custom error messages for exception\"\"\"\n        error_message = \"Status Code: {0}\\n\"\\\n                        \"Error Code: {1}\\n\"\\\n                        \"Error Message: {2}\\n\"\\\n                        \"Raw Response: {3}\\n\".format(self.status, self.errorCode, self.errorMessage, self.rawResponse)\n        return error_message\n\ndef render_path(path_to_item):\n    \"\"\"Returns a string representation of a path\"\"\"\n    result = \"\"\n    for pth in path_to_item:\n        if isinstance(pth, int):\n            result += \"[{0}]\".format(pth)\n        else:\n            result += \"['{0}']\".format(pth)\n    return result\n",
    "uncovered_lines": [
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      70,
      71,
      72,
      73,
      74,
      87,
      88,
      89,
      90,
      91,
      96,
      97,
      98,
      99,
      100,
      102,
      103,
      105,
      106,
      107,
      108,
      109,
      110,
      111,
      114,
      115,
      116,
      117,
      118,
      119,
      121,
      123,
      124,
      125,
      126,
      127,
      128,
      130,
      134,
      138,
      145
    ]
  },
  {
    "file_path": "xendit/model_utils.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nfrom datetime import date, datetime  # noqa: F401\nfrom copy import deepcopy\nimport inspect\nimport io\nimport os\nimport pprint\nimport re\nimport tempfile\nimport uuid\n\nfrom dateutil.parser import parse\n\nfrom xendit.exceptions import (\n    ApiKeyError,\n    ApiAttributeError,\n    ApiTypeError,\n    ApiValueError,\n)\n\nnone_type = type(None)\nfile_type = io.IOBase\n\n\ndef convert_js_args_to_python_args(fn):\n    from functools import wraps\n    @wraps(fn)\n    def wrapped_init(_self, *args, **kwargs):\n        \"\"\"\n        An attribute named `self` received from the api will conflicts with the reserved `self`\n        parameter of a class method. During generation, `self` attributes are mapped\n        to `_self` in models. Here, we name `_self` instead of `self` to avoid conflicts.\n        \"\"\"\n        spec_property_naming = kwargs.get('_spec_property_naming', False)\n        if spec_property_naming:\n            kwargs = change_keys_js_to_python(\n                kwargs, _self if isinstance(\n                    _self, type) else _self.__class__)\n        return fn(_self, *args, **kwargs)\n    return wrapped_init\n\n\nclass cached_property(object):\n    # this caches the result of the function call for fn with no inputs\n    # use this as a decorator on function methods that you want converted\n    # into cached properties\n    result_key = '_results'\n\n    def __init__(self, fn):\n        self._fn = fn\n\n    def __get__(self, instance, cls=None):\n        if self.result_key in vars(self):\n            return vars(self)[self.result_key]\n        else:\n            result = self._fn()\n            setattr(self, self.result_key, result)\n            return result\n\n\nPRIMITIVE_TYPES = (list, float, int, bool, datetime, date, str, file_type)\n\n\ndef allows_single_value_input(cls):\n    \"\"\"\n    This function returns True if the input composed schema model or any\n    descendant model allows a value only input\n    This is true for cases where oneOf contains items like:\n    oneOf:\n      - float\n      - NumberWithValidation\n      - StringEnum\n      - ArrayModel\n      - null\n    TODO: lru_cache this\n    \"\"\"\n    if (\n        issubclass(cls, ModelSimple) or\n        cls in PRIMITIVE_TYPES\n    ):\n        return True\n    elif issubclass(cls, ModelComposed):\n        if not cls._composed_schemas['oneOf']:\n            return False\n        return any(allows_single_value_input(c) for c in cls._composed_schemas['oneOf'])\n    return False\n\n\ndef composed_model_input_classes(cls):\n    \"\"\"\n    This function returns a list of the possible models that can be accepted as\n    inputs.\n    TODO: lru_cache this\n    \"\"\"\n    if issubclass(cls, ModelSimple) or cls in PRIMITIVE_TYPES:\n        return [cls]\n    elif issubclass(cls, ModelNormal):\n        if cls.discriminator is None:\n            return [cls]\n        else:\n            return get_discriminated_classes(cls)\n    elif issubclass(cls, ModelComposed):\n        if not cls._composed_schemas['oneOf']:\n            return []\n        if cls.discriminator is None:\n            input_classes = []\n            for c in cls._composed_schemas['oneOf']:\n                input_classes.extend(composed_model_input_classes(c))\n            return input_classes\n        else:\n            return get_discriminated_classes(cls)\n    return []\n\n\nclass OpenApiModel(object):\n    \"\"\"The base class for all OpenAPIModels\"\"\"\n\n    def set_attribute(self, name, value):\n        # this is only used to set properties on self\n\n        path_to_item = []\n        if self._path_to_item:\n            path_to_item.extend(self._path_to_item)\n        path_to_item.append(name)\n\n        if name in self.openapi_types:\n            required_types_mixed = self.openapi_types[name]\n        elif self.additional_properties_type is None:\n            raise ApiAttributeError(\n                \"{0} has no attribute '{1}'\".format(\n                    type(self).__name__, name),\n                path_to_item\n            )\n        elif self.additional_properties_type is not None:\n            required_types_mixed = self.additional_properties_type\n\n        if get_simple_class(name) != str:\n            error_msg = type_error_message(\n                var_name=name,\n                var_value=name,\n                valid_classes=(str,),\n                key_type=True\n            )\n            raise ApiTypeError(\n                error_msg,\n                path_to_item=path_to_item,\n                valid_classes=(str,),\n                key_type=True\n            )\n\n        if self._check_type:\n            value = validate_and_convert_types(\n                value, required_types_mixed, path_to_item, self._spec_property_naming,\n                self._check_type, configuration=self._configuration)\n        if (name,) in self.allowed_values:\n            check_allowed_values(\n                self.allowed_values,\n                (name,),\n                value\n            )\n        if (name,) in self.validations:\n            check_validations(\n                self.validations,\n                (name,),\n                value,\n                self._configuration\n            )\n        self.__dict__['_data_store'][name] = value\n\n    def __repr__(self):\n        \"\"\"For `print` and `pprint`\"\"\"\n        return self.to_str()\n\n    def __ne__(self, other):\n        \"\"\"Returns true if both objects are not equal\"\"\"\n        return not self == other\n\n    def __setattr__(self, attr, value):\n        \"\"\"set the value of an attribute using dot notation: `instance.attr = val`\"\"\"\n        self[attr] = value\n\n    def __getattr__(self, attr):\n        \"\"\"get the value of an attribute using dot notation: `instance.attr`\"\"\"\n        return self.__getitem__(attr)\n\n    def __copy__(self):\n        cls = self.__class__\n        if self.get(\"_spec_property_naming\", False):\n            return cls._new_from_openapi_data(**self.__dict__)\n        else:\n            return cls.__new__(cls, **self.__dict__)\n\n    def __deepcopy__(self, memo):\n        cls = self.__class__\n\n        if self.get(\"_spec_property_naming\", False):\n            new_inst = cls._new_from_openapi_data()\n        else:\n            new_inst = cls.__new__(cls, **self.__dict__)\n\n        for k, v in self.__dict__.items():\n            setattr(new_inst, k, deepcopy(v, memo))\n        return new_inst\n\n\n    def __new__(cls, *args, **kwargs):\n        # this function uses the discriminator to\n        # pick a new schema/class to instantiate because a discriminator\n        # propertyName value was passed in\n\n        if len(args) == 1:\n            arg = args[0]\n            if arg is None and is_type_nullable(cls):\n                # The input data is the 'null' value and the type is nullable.\n                return None\n\n            if issubclass(cls, ModelComposed) and allows_single_value_input(cls):\n                model_kwargs = {}\n                oneof_instance = get_oneof_instance(cls, model_kwargs, kwargs, model_arg=arg)\n                return oneof_instance\n\n        visited_composed_classes = kwargs.get('_visited_composed_classes', ())\n        if (\n            cls.discriminator is None or\n            cls in visited_composed_classes\n        ):\n            # Use case 1: this openapi schema (cls) does not have a discriminator\n            # Use case 2: we have already visited this class before and are sure that we\n            # want to instantiate it this time. We have visited this class deserializing\n            # a payload with a discriminator. During that process we traveled through\n            # this class but did not make an instance of it. Now we are making an\n            # instance of a composed class which contains cls in it, so this time make an instance of cls.\n            #\n            # Here's an example of use case 2: If Animal has a discriminator\n            # petType and we pass in \"Dog\", and the class Dog\n            # allOf includes Animal, we move through Animal\n            # once using the discriminator, and pick Dog.\n            # Then in the composed schema dog Dog, we will make an instance of the\n            # Animal class (because Dal has allOf: Animal) but this time we won't travel\n            # through Animal's discriminator because we passed in\n            # _visited_composed_classes = (Animal,)\n\n            return super(OpenApiModel, cls).__new__(cls)\n\n        # Get the name and value of the discriminator property.\n        # The discriminator name is obtained from the discriminator meta-data\n        # and the discriminator value is obtained from the input data.\n        discr_propertyname_py = list(cls.discriminator.keys())[0]\n        discr_propertyname_js = cls.attribute_map[discr_propertyname_py]\n        if discr_propertyname_js in kwargs:\n            discr_value = kwargs[discr_propertyname_js]\n        elif discr_propertyname_py in kwargs:\n            discr_value = kwargs[discr_propertyname_py]\n        else:\n            # The input data does not contain the discriminator property.\n            path_to_item = kwargs.get('_path_to_item', ())\n            raise ApiValueError(\n                \"Cannot deserialize input data due to missing discriminator. \"\n                \"The discriminator property '%s' is missing at path: %s\" %\n                (discr_propertyname_js, path_to_item)\n            )\n\n        # Implementation note: the last argument to get_discriminator_class\n        # is a list of visited classes. get_discriminator_class may recursively\n        # call itself and update the list of visited classes, and the initial\n        # value must be an empty list. Hence not using 'visited_composed_classes'\n        new_cls = get_discriminator_class(\n            cls, discr_propertyname_py, discr_value, [])\n        if new_cls is None:\n            path_to_item = kwargs.get('_path_to_item', ())\n            disc_prop_value = kwargs.get(\n                discr_propertyname_js, kwargs.get(discr_propertyname_py))\n            raise ApiValueError(\n                \"Cannot deserialize input data due to invalid discriminator \"\n                \"value. The OpenAPI document has no mapping for discriminator \"\n                \"property '%s'='%s' at path: %s\" %\n                (discr_propertyname_js, disc_prop_value, path_to_item)\n            )\n\n        if new_cls in visited_composed_classes:\n            # if we are making an instance of a composed schema Descendent\n            # which allOf includes Ancestor, then Ancestor contains\n            # a discriminator that includes Descendent.\n            # So if we make an instance of Descendent, we have to make an\n            # instance of Ancestor to hold the allOf properties.\n            # This code detects that use case and makes the instance of Ancestor\n            # For example:\n            # When making an instance of Dog, _visited_composed_classes = (Dog,)\n            # then we make an instance of Animal to include in dog._composed_instances\n            # so when we are here, cls is Animal\n            # cls.discriminator != None\n            # cls not in _visited_composed_classes\n            # new_cls = Dog\n            # but we know we know that we already have Dog\n            # because it is in visited_composed_classes\n            # so make Animal here\n            return super(OpenApiModel, cls).__new__(cls)\n\n        # Build a list containing all oneOf and anyOf descendants.\n        oneof_anyof_classes = None\n        if cls._composed_schemas is not None:\n            oneof_anyof_classes = (\n                cls._composed_schemas.get('oneOf', ()) +\n                cls._composed_schemas.get('anyOf', ()))\n        oneof_anyof_child = new_cls in oneof_anyof_classes\n        kwargs['_visited_composed_classes'] = visited_composed_classes + (cls,)\n\n        if cls._composed_schemas.get('allOf') and oneof_anyof_child:\n            # Validate that we can make self because when we make the\n            # new_cls it will not include the allOf validations in self\n            self_inst = super(OpenApiModel, cls).__new__(cls)\n            self_inst.__init__(*args, **kwargs)\n\n        if kwargs.get(\"_spec_property_naming\", False):\n            # when true, implies new is from deserialization\n            new_inst = new_cls._new_from_openapi_data(*args, **kwargs)\n        else:\n            new_inst = new_cls.__new__(new_cls, *args, **kwargs)\n            new_inst.__init__(*args, **kwargs)\n\n        return new_inst\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _new_from_openapi_data(cls, *args, **kwargs):\n        # this function uses the discriminator to\n        # pick a new schema/class to instantiate because a discriminator\n        # propertyName value was passed in\n\n        if len(args) == 1:\n            arg = args[0]\n            if arg is None and is_type_nullable(cls):\n                # The input data is the 'null' value and the type is nullable.\n                return None\n\n            if issubclass(cls, ModelComposed) and allows_single_value_input(cls):\n                model_kwargs = {}\n                oneof_instance = get_oneof_instance(cls, model_kwargs, kwargs, model_arg=arg)\n                return oneof_instance\n\n        visited_composed_classes = kwargs.get('_visited_composed_classes', ())\n        if (\n            cls.discriminator is None or\n            cls in visited_composed_classes\n        ):\n            # Use case 1: this openapi schema (cls) does not have a discriminator\n            # Use case 2: we have already visited this class before and are sure that we\n            # want to instantiate it this time. We have visited this class deserializing\n            # a payload with a discriminator. During that process we traveled through\n            # this class but did not make an instance of it. Now we are making an\n            # instance of a composed class which contains cls in it, so this time make an instance of cls.\n            #\n            # Here's an example of use case 2: If Animal has a discriminator\n            # petType and we pass in \"Dog\", and the class Dog\n            # allOf includes Animal, we move through Animal\n            # once using the discriminator, and pick Dog.\n            # Then in the composed schema dog Dog, we will make an instance of the\n            # Animal class (because Dal has allOf: Animal) but this time we won't travel\n            # through Animal's discriminator because we passed in\n            # _visited_composed_classes = (Animal,)\n\n            return cls._from_openapi_data(*args, **kwargs)\n\n        # Get the name and value of the discriminator property.\n        # The discriminator name is obtained from the discriminator meta-data\n        # and the discriminator value is obtained from the input data.\n        discr_propertyname_py = list(cls.discriminator.keys())[0]\n        discr_propertyname_js = cls.attribute_map[discr_propertyname_py]\n        if discr_propertyname_js in kwargs:\n            discr_value = kwargs[discr_propertyname_js]\n        elif discr_propertyname_py in kwargs:\n            discr_value = kwargs[discr_propertyname_py]\n        else:\n            # The input data does not contain the discriminator property.\n            path_to_item = kwargs.get('_path_to_item', ())\n            raise ApiValueError(\n                \"Cannot deserialize input data due to missing discriminator. \"\n                \"The discriminator property '%s' is missing at path: %s\" %\n                (discr_propertyname_js, path_to_item)\n            )\n\n        # Implementation note: the last argument to get_discriminator_class\n        # is a list of visited classes. get_discriminator_class may recursively\n        # call itself and update the list of visited classes, and the initial\n        # value must be an empty list. Hence not using 'visited_composed_classes'\n        new_cls = get_discriminator_class(\n            cls, discr_propertyname_py, discr_value, [])\n        if new_cls is None:\n            path_to_item = kwargs.get('_path_to_item', ())\n            disc_prop_value = kwargs.get(\n                discr_propertyname_js, kwargs.get(discr_propertyname_py))\n            raise ApiValueError(\n                \"Cannot deserialize input data due to invalid discriminator \"\n                \"value. The OpenAPI document has no mapping for discriminator \"\n                \"property '%s'='%s' at path: %s\" %\n                (discr_propertyname_js, disc_prop_value, path_to_item)\n            )\n\n        if new_cls in visited_composed_classes:\n            # if we are making an instance of a composed schema Descendent\n            # which allOf includes Ancestor, then Ancestor contains\n            # a discriminator that includes Descendent.\n            # So if we make an instance of Descendent, we have to make an\n            # instance of Ancestor to hold the allOf properties.\n            # This code detects that use case and makes the instance of Ancestor\n            # For example:\n            # When making an instance of Dog, _visited_composed_classes = (Dog,)\n            # then we make an instance of Animal to include in dog._composed_instances\n            # so when we are here, cls is Animal\n            # cls.discriminator != None\n            # cls not in _visited_composed_classes\n            # new_cls = Dog\n            # but we know we know that we already have Dog\n            # because it is in visited_composed_classes\n            # so make Animal here\n            return cls._from_openapi_data(*args, **kwargs)\n\n        # Build a list containing all oneOf and anyOf descendants.\n        oneof_anyof_classes = None\n        if cls._composed_schemas is not None:\n            oneof_anyof_classes = (\n                cls._composed_schemas.get('oneOf', ()) +\n                cls._composed_schemas.get('anyOf', ()))\n        oneof_anyof_child = new_cls in oneof_anyof_classes\n        kwargs['_visited_composed_classes'] = visited_composed_classes + (cls,)\n\n        if cls._composed_schemas.get('allOf') and oneof_anyof_child:\n            # Validate that we can make self because when we make the\n            # new_cls it will not include the allOf validations in self\n            self_inst = cls._from_openapi_data(*args, **kwargs)\n\n        new_inst = new_cls._new_from_openapi_data(*args, **kwargs)\n        return new_inst\n\n\nclass ModelSimple(OpenApiModel):\n    \"\"\"the parent class of models whose type != object in their\n    swagger/openapi\"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        self.set_attribute(name, value)\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        return self.__dict__['_data_store'].get(name, default)\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        if name in self:\n            return self.get(name)\n\n        raise ApiAttributeError(\n            \"{0} has no attribute '{1}'\".format(\n                type(self).__name__, name),\n            [e for e in [self._path_to_item, name] if e]\n        )\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attribute value was set in an instance: `'attr' in instance`\"\"\"\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        return name in self.__dict__['_data_store']\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return str(self.value)\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        this_val = self._data_store['value']\n        that_val = other._data_store['value']\n        types = set()\n        types.add(this_val.__class__)\n        types.add(that_val.__class__)\n        vals_equal = this_val == that_val\n        return vals_equal\n\n\nclass ModelNormal(OpenApiModel):\n    \"\"\"the parent class of models whose type == object in their\n    swagger/openapi\"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        self.set_attribute(name, value)\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        return self.__dict__['_data_store'].get(name, default)\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        if name in self:\n            return self.get(name)\n\n        raise ApiAttributeError(\n            \"{0} has no attribute '{1}'\".format(\n                type(self).__name__, name),\n            [e for e in [self._path_to_item, name] if e]\n        )\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attribute value was set in an instance: `'attr' in instance`\"\"\"\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        return name in self.__dict__['_data_store']\n\n    def to_dict(self):\n        \"\"\"Returns the model properties as a dict\"\"\"\n        return model_to_dict(self, serialize=False)\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return pprint.pformat(self.to_dict())\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        if not set(self._data_store.keys()) == set(other._data_store.keys()):\n            return False\n        for _var_name, this_val in self._data_store.items():\n            that_val = other._data_store[_var_name]\n            types = set()\n            types.add(this_val.__class__)\n            types.add(that_val.__class__)\n            vals_equal = this_val == that_val\n            if not vals_equal:\n                return False\n        return True\n\n\nclass ModelComposed(OpenApiModel):\n    \"\"\"the parent class of models whose type == object in their\n    swagger/openapi and have oneOf/allOf/anyOf\n\n    When one sets a property we use var_name_to_model_instances to store the value in\n    the correct class instances + run any type checking + validation code.\n    When one gets a property we use var_name_to_model_instances to get the value\n    from the correct class instances.\n    This allows multiple composed schemas to contain the same property with additive\n    constraints on the value.\n\n    _composed_schemas (dict) stores the anyOf/allOf/oneOf classes\n    key (str): allOf/oneOf/anyOf\n    value (list): the classes in the XOf definition.\n        Note: none_type can be included when the openapi document version >= 3.1.0\n    _composed_instances (list): stores a list of instances of the composed schemas\n    defined in _composed_schemas. When properties are accessed in the self instance,\n    they are returned from the self._data_store or the data stores in the instances\n    in self._composed_schemas\n    _var_name_to_model_instances (dict): maps between a variable name on self and\n    the composed instances (self included) which contain that data\n    key (str): property name\n    value (list): list of class instances, self or instances in _composed_instances\n    which contain the value that the key is referring to.\n    \"\"\"\n\n    def __setitem__(self, name, value):\n        \"\"\"set the value of an attribute using square-bracket notation: `instance[attr] = val`\"\"\"\n        if name in self.required_properties:\n            self.__dict__[name] = value\n            return\n\n        \"\"\"\n        Use cases:\n        1. additional_properties_type is None (additionalProperties == False in spec)\n            Check for property presence in self.openapi_types\n            if not present then throw an error\n            if present set in self, set attribute\n            always set on composed schemas\n        2.  additional_properties_type exists\n            set attribute on self\n            always set on composed schemas\n        \"\"\"\n        if self.additional_properties_type is None:\n            \"\"\"\n            For an attribute to exist on a composed schema it must:\n            - fulfill schema_requirements in the self composed schema not considering oneOf/anyOf/allOf schemas AND\n            - fulfill schema_requirements in each oneOf/anyOf/allOf schemas\n\n            schema_requirements:\n            For an attribute to exist on a schema it must:\n            - be present in properties at the schema OR\n            - have additionalProperties unset (defaults additionalProperties = any type) OR\n            - have additionalProperties set\n            \"\"\"\n            if name not in self.openapi_types:\n                raise ApiAttributeError(\n                    \"{0} has no attribute '{1}'\".format(\n                        type(self).__name__, name),\n                    [e for e in [self._path_to_item, name] if e]\n                )\n        # attribute must be set on self and composed instances\n        self.set_attribute(name, value)\n        for model_instance in self._composed_instances:\n            setattr(model_instance, name, value)\n        if name not in self._var_name_to_model_instances:\n            # we assigned an additional property\n            self.__dict__['_var_name_to_model_instances'][name] = self._composed_instances + [self]\n        return None\n\n    __unset_attribute_value__ = object()\n\n    def get(self, name, default=None):\n        \"\"\"returns the value of an attribute or some default value if the attribute was not set\"\"\"\n        if name in self.required_properties:\n            return self.__dict__[name]\n\n        # get the attribute from the correct instance\n        model_instances = self._var_name_to_model_instances.get(name)\n        values = []\n        # A composed model stores self and child (oneof/anyOf/allOf) models under\n        # self._var_name_to_model_instances.\n        # Any property must exist in self and all model instances\n        # The value stored in all model instances must be the same\n        if model_instances:\n            for model_instance in model_instances:\n                if name in model_instance._data_store:\n                    v = model_instance._data_store[name]\n                    if v not in values:\n                        values.append(v)\n        len_values = len(values)\n        if len_values == 0:\n            return default\n        elif len_values == 1:\n            return values[0]\n        elif len_values > 1:\n            raise ApiValueError(\n                \"Values stored for property {0} in {1} differ when looking \"\n                \"at self and self's composed instances. All values must be \"\n                \"the same\".format(name, type(self).__name__),\n                [e for e in [self._path_to_item, name] if e]\n            )\n\n    def __getitem__(self, name):\n        \"\"\"get the value of an attribute using square-bracket notation: `instance[attr]`\"\"\"\n        value = self.get(name, self.__unset_attribute_value__)\n        if value is self.__unset_attribute_value__:\n            raise ApiAttributeError(\n                \"{0} has no attribute '{1}'\".format(\n                    type(self).__name__, name),\n                    [e for e in [self._path_to_item, name] if e]\n            )\n        return value\n\n    def __contains__(self, name):\n        \"\"\"used by `in` operator to check if an attribute value was set in an instance: `'attr' in instance`\"\"\"\n\n        if name in self.required_properties:\n            return name in self.__dict__\n\n        model_instances = self._var_name_to_model_instances.get(\n            name, self._additional_properties_model_instances)\n\n        if model_instances:\n            for model_instance in model_instances:\n                if name in model_instance._data_store:\n                    return True\n\n        return False\n\n    def to_dict(self):\n        \"\"\"Returns the model properties as a dict\"\"\"\n        return model_to_dict(self, serialize=False)\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return pprint.pformat(self.to_dict())\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n\n        if not set(self._data_store.keys()) == set(other._data_store.keys()):\n            return False\n        for _var_name, this_val in self._data_store.items():\n            that_val = other._data_store[_var_name]\n            types = set()\n            types.add(this_val.__class__)\n            types.add(that_val.__class__)\n            vals_equal = this_val == that_val\n            if not vals_equal:\n                return False\n        return True\n\n\nCOERCION_INDEX_BY_TYPE = {\n    ModelComposed: 0,\n    ModelNormal: 1,\n    ModelSimple: 2,\n    none_type: 3,    # The type of 'None'.\n    list: 4,\n    dict: 5,\n    float: 6,\n    int: 7,\n    bool: 8,\n    datetime: 9,\n    date: 10,\n    str: 11,\n    file_type: 12,   # 'file_type' is an alias for the built-in 'file' or 'io.IOBase' type.\n}\n\n# these are used to limit what type conversions we try to do\n# when we have a valid type already and we want to try converting\n# to another type\nUPCONVERSION_TYPE_PAIRS = (\n    (str, datetime),\n    (str, date),\n    # A float may be serialized as an integer, e.g. '3' is a valid serialized float.\n    (int, float),\n    (list, ModelComposed),\n    (dict, ModelComposed),\n    (str, ModelComposed),\n    (int, ModelComposed),\n    (float, ModelComposed),\n    (list, ModelComposed),\n    (list, ModelNormal),\n    (dict, ModelNormal),\n    (str, ModelSimple),\n    (int, ModelSimple),\n    (float, ModelSimple),\n    (list, ModelSimple),\n)\n\nCOERCIBLE_TYPE_PAIRS = {\n    False: (  # client instantiation of a model with client data\n        # (dict, ModelComposed),\n        # (list, ModelComposed),\n        # (dict, ModelNormal),\n        # (list, ModelNormal),\n        # (str, ModelSimple),\n        # (int, ModelSimple),\n        # (float, ModelSimple),\n        # (list, ModelSimple),\n        # (str, int),\n        # (str, float),\n        # (str, datetime),\n        # (str, date),\n        # (int, str),\n        # (float, str),\n    ),\n    True: (  # server -> client data\n        (dict, ModelComposed),\n        (list, ModelComposed),\n        (dict, ModelNormal),\n        (list, ModelNormal),\n        (str, ModelSimple),\n        (int, ModelSimple),\n        (float, ModelSimple),\n        (list, ModelSimple),\n        # (str, int),\n        # (str, float),\n        (str, datetime),\n        (str, date),\n        # (int, str),\n        # (float, str),\n        (str, file_type)\n    ),\n}\n\n\ndef get_simple_class(input_value):\n    \"\"\"Returns an input_value's simple class that we will use for type checking\n    Python2:\n    float and int will return int, where int is the python3 int backport\n    str and unicode will return str, where str is the python3 str backport\n    Note: float and int ARE both instances of int backport\n    Note: str_py2 and unicode_py2 are NOT both instances of str backport\n\n    Args:\n        input_value (class/class_instance): the item for which we will return\n                                            the simple class\n    \"\"\"\n    if isinstance(input_value, type):\n        # input_value is a class\n        return input_value\n    elif isinstance(input_value, tuple):\n        return tuple\n    elif isinstance(input_value, list):\n        return list\n    elif isinstance(input_value, dict):\n        return dict\n    elif isinstance(input_value, none_type):\n        return none_type\n    elif isinstance(input_value, file_type):\n        return file_type\n    elif isinstance(input_value, bool):\n        # this must be higher than the int check because\n        # isinstance(True, int) == True\n        return bool\n    elif isinstance(input_value, int):\n        return int\n    elif isinstance(input_value, datetime):\n        # this must be higher than the date check because\n        # isinstance(datetime_instance, date) == True\n        return datetime\n    elif isinstance(input_value, date):\n        return date\n    elif isinstance(input_value, str):\n        return str\n    return type(input_value)\n\n\ndef check_allowed_values(allowed_values, input_variable_path, input_values):\n    \"\"\"Raises an exception if the input_values are not allowed\n\n    Args:\n        allowed_values (dict): the allowed_values dict\n        input_variable_path (tuple): the path to the input variable\n        input_values (list/str/int/float/date/datetime): the values that we\n            are checking to see if they are in allowed_values\n    \"\"\"\n    these_allowed_values = list(allowed_values[input_variable_path].values())\n    if (isinstance(input_values, list)\n            and not set(input_values).issubset(\n                set(these_allowed_values))):\n        invalid_values = \", \".join(\n            map(str, set(input_values) - set(these_allowed_values))),\n        raise ApiValueError(\n            \"Invalid values for `%s` [%s], must be a subset of [%s]\" %\n            (\n                input_variable_path[0],\n                invalid_values,\n                \", \".join(map(str, these_allowed_values))\n            )\n        )\n    elif (isinstance(input_values, dict)\n            and not set(\n                input_values.keys()).issubset(set(these_allowed_values))):\n        invalid_values = \", \".join(\n            map(str, set(input_values.keys()) - set(these_allowed_values)))\n        raise ApiValueError(\n            \"Invalid keys in `%s` [%s], must be a subset of [%s]\" %\n            (\n                input_variable_path[0],\n                invalid_values,\n                \", \".join(map(str, these_allowed_values))\n            )\n        )\n    elif (not isinstance(input_values, (list, dict))\n            and input_values not in these_allowed_values):\n        raise ApiValueError(\n            \"Invalid value for `%s` (%s), must be one of %s\" %\n            (\n                input_variable_path[0],\n                input_values,\n                these_allowed_values\n            )\n        )\n\n\ndef is_json_validation_enabled(schema_keyword, configuration=None):\n    \"\"\"Returns true if JSON schema validation is enabled for the specified\n    validation keyword. This can be used to skip JSON schema structural validation\n    as requested in the configuration.\n\n    Args:\n        schema_keyword (string): the name of a JSON schema validation keyword.\n        configuration (Configuration): the configuration class.\n    \"\"\"\n\n    return (configuration is None or\n            not hasattr(configuration, '_disabled_client_side_validations') or\n            schema_keyword not in configuration._disabled_client_side_validations)\n\n\ndef check_validations(\n        validations, input_variable_path, input_values,\n        configuration=None):\n    \"\"\"Raises an exception if the input_values are invalid\n\n    Args:\n        validations (dict): the validation dictionary.\n        input_variable_path (tuple): the path to the input variable.\n        input_values (list/str/int/float/date/datetime): the values that we\n            are checking.\n        configuration (Configuration): the configuration class.\n    \"\"\"\n\n    if input_values is None:\n        return\n\n    current_validations = validations[input_variable_path]\n    if (is_json_validation_enabled('multipleOf', configuration) and\n            'multiple_of' in current_validations and\n            isinstance(input_values, (int, float)) and\n            not (float(input_values) / current_validations['multiple_of']).is_integer()):\n        # Note 'multipleOf' will be as good as the floating point arithmetic.\n        raise ApiValueError(\n            \"Invalid value for `%s`, value must be a multiple of \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['multiple_of']\n            )\n        )\n\n    if (is_json_validation_enabled('maxLength', configuration) and\n            'max_length' in current_validations and\n            len(input_values) > current_validations['max_length']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, length must be less than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['max_length']\n            )\n        )\n\n    if (is_json_validation_enabled('minLength', configuration) and\n            'min_length' in current_validations and\n            len(input_values) < current_validations['min_length']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, length must be greater than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['min_length']\n            )\n        )\n\n    if (is_json_validation_enabled('maxItems', configuration) and\n            'max_items' in current_validations and\n            len(input_values) > current_validations['max_items']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, number of items must be less than or \"\n            \"equal to `%s`\" % (\n                input_variable_path[0],\n                current_validations['max_items']\n            )\n        )\n\n    if (is_json_validation_enabled('minItems', configuration) and\n            'min_items' in current_validations and\n            len(input_values) < current_validations['min_items']):\n        raise ValueError(\n            \"Invalid value for `%s`, number of items must be greater than or \"\n            \"equal to `%s`\" % (\n                input_variable_path[0],\n                current_validations['min_items']\n            )\n        )\n\n    items = ('exclusive_maximum', 'inclusive_maximum', 'exclusive_minimum',\n             'inclusive_minimum')\n    if (any(item in current_validations for item in items)):\n        if isinstance(input_values, list):\n            max_val = max(input_values)\n            min_val = min(input_values)\n        elif isinstance(input_values, dict):\n            max_val = max(input_values.values())\n            min_val = min(input_values.values())\n        else:\n            max_val = input_values\n            min_val = input_values\n\n    if (is_json_validation_enabled('exclusiveMaximum', configuration) and\n            'exclusive_maximum' in current_validations and\n            max_val >= current_validations['exclusive_maximum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value less than `%s`\" % (\n                input_variable_path[0],\n                current_validations['exclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('maximum', configuration) and\n            'inclusive_maximum' in current_validations and\n            max_val > current_validations['inclusive_maximum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value less than or equal to \"\n            \"`%s`\" % (\n                input_variable_path[0],\n                current_validations['inclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('exclusiveMinimum', configuration) and\n            'exclusive_minimum' in current_validations and\n            min_val <= current_validations['exclusive_minimum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value greater than `%s`\" %\n            (\n                input_variable_path[0],\n                current_validations['exclusive_maximum']\n            )\n        )\n\n    if (is_json_validation_enabled('minimum', configuration) and\n            'inclusive_minimum' in current_validations and\n            min_val < current_validations['inclusive_minimum']):\n        raise ApiValueError(\n            \"Invalid value for `%s`, must be a value greater than or equal \"\n            \"to `%s`\" % (\n                input_variable_path[0],\n                current_validations['inclusive_minimum']\n            )\n        )\n    flags = current_validations.get('regex', {}).get('flags', 0)\n    if (is_json_validation_enabled('pattern', configuration) and\n            'regex' in current_validations and\n            not re.search(current_validations['regex']['pattern'],\n                          input_values, flags=flags)):\n        err_msg = r\"Invalid value for `%s`, must match regular expression `%s`\" % (\n            input_variable_path[0],\n            current_validations['regex']['pattern']\n        )\n        if flags != 0:\n            # Don't print the regex flags if the flags are not\n            # specified in the OAS document.\n            err_msg = r\"%s with flags=`%s`\" % (err_msg, flags)\n        raise ApiValueError(err_msg)\n\n\ndef order_response_types(required_types):\n    \"\"\"Returns the required types sorted in coercion order\n\n    Args:\n        required_types (list/tuple): collection of classes or instance of\n            list or dict with class information inside it.\n\n    Returns:\n        (list): coercion order sorted collection of classes or instance\n            of list or dict with class information inside it.\n    \"\"\"\n\n    def index_getter(class_or_instance):\n        if isinstance(class_or_instance, list):\n            return COERCION_INDEX_BY_TYPE[list]\n        elif isinstance(class_or_instance, dict):\n            return COERCION_INDEX_BY_TYPE[dict]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelComposed)):\n            return COERCION_INDEX_BY_TYPE[ModelComposed]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelNormal)):\n            return COERCION_INDEX_BY_TYPE[ModelNormal]\n        elif (inspect.isclass(class_or_instance)\n                and issubclass(class_or_instance, ModelSimple)):\n            return COERCION_INDEX_BY_TYPE[ModelSimple]\n        elif class_or_instance in COERCION_INDEX_BY_TYPE:\n            return COERCION_INDEX_BY_TYPE[class_or_instance]\n        raise ApiValueError(\"Unsupported type: %s\" % class_or_instance)\n\n    sorted_types = sorted(\n        required_types,\n        key=lambda class_or_instance: index_getter(class_or_instance)\n    )\n    return sorted_types\n\n\ndef remove_uncoercible(required_types_classes, current_item, spec_property_naming,\n                       must_convert=True):\n    \"\"\"Only keeps the type conversions that are possible\n\n    Args:\n        required_types_classes (tuple): tuple of classes that are required\n                          these should be ordered by COERCION_INDEX_BY_TYPE\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        current_item (any): the current item (input data) to be converted\n\n    Keyword Args:\n        must_convert (bool): if True the item to convert is of the wrong\n                          type and we want a big list of coercibles\n                          if False, we want a limited list of coercibles\n\n    Returns:\n        (list): the remaining coercible required types, classes only\n    \"\"\"\n    current_type_simple = get_simple_class(current_item)\n\n    results_classes = []\n    for required_type_class in required_types_classes:\n        # convert our models to OpenApiModel\n        required_type_class_simplified = required_type_class\n        if isinstance(required_type_class_simplified, type):\n            if issubclass(required_type_class_simplified, ModelComposed):\n                required_type_class_simplified = ModelComposed\n            elif issubclass(required_type_class_simplified, ModelNormal):\n                required_type_class_simplified = ModelNormal\n            elif issubclass(required_type_class_simplified, ModelSimple):\n                required_type_class_simplified = ModelSimple\n\n        if required_type_class_simplified == current_type_simple:\n            # don't consider converting to one's own class\n            continue\n\n        class_pair = (current_type_simple, required_type_class_simplified)\n        if must_convert and class_pair in COERCIBLE_TYPE_PAIRS[spec_property_naming]:\n            results_classes.append(required_type_class)\n        elif class_pair in UPCONVERSION_TYPE_PAIRS:\n            results_classes.append(required_type_class)\n    return results_classes\n\n\ndef get_discriminated_classes(cls):\n    \"\"\"\n    Returns all the classes that a discriminator converts to\n    TODO: lru_cache this\n    \"\"\"\n    possible_classes = []\n    key = list(cls.discriminator.keys())[0]\n    if is_type_nullable(cls):\n        possible_classes.append(cls)\n    for discr_cls in cls.discriminator[key].values():\n        if hasattr(discr_cls, 'discriminator') and discr_cls.discriminator is not None:\n            possible_classes.extend(get_discriminated_classes(discr_cls))\n        else:\n            possible_classes.append(discr_cls)\n    return possible_classes\n\n\ndef get_possible_classes(cls, from_server_context):\n    # TODO: lru_cache this\n    possible_classes = [cls]\n    if from_server_context:\n        return possible_classes\n    if hasattr(cls, 'discriminator') and cls.discriminator is not None:\n        possible_classes = []\n        possible_classes.extend(get_discriminated_classes(cls))\n    elif issubclass(cls, ModelComposed):\n        possible_classes.extend(composed_model_input_classes(cls))\n    return possible_classes\n\n\ndef get_required_type_classes(required_types_mixed, spec_property_naming):\n    \"\"\"Converts the tuple required_types into a tuple and a dict described\n    below\n\n    Args:\n        required_types_mixed (tuple/list): will contain either classes or\n            instance of list or dict\n        spec_property_naming (bool): if True these values came from the\n            server, and we use the data types in our endpoints.\n            If False, we are client side and we need to include\n            oneOf and discriminator classes inside the data types in our endpoints\n\n    Returns:\n        (valid_classes, dict_valid_class_to_child_types_mixed):\n            valid_classes (tuple): the valid classes that the current item\n                                   should be\n            dict_valid_class_to_child_types_mixed (dict):\n                valid_class (class): this is the key\n                child_types_mixed (list/dict/tuple): describes the valid child\n                    types\n    \"\"\"\n    valid_classes = []\n    child_req_types_by_current_type = {}\n    for required_type in required_types_mixed:\n        if isinstance(required_type, list):\n            valid_classes.append(list)\n            child_req_types_by_current_type[list] = required_type\n        elif isinstance(required_type, tuple):\n            valid_classes.append(tuple)\n            child_req_types_by_current_type[tuple] = required_type\n        elif isinstance(required_type, dict):\n            valid_classes.append(dict)\n            child_req_types_by_current_type[dict] = required_type[str]\n        else:\n            valid_classes.extend(get_possible_classes(required_type, spec_property_naming))\n    return tuple(valid_classes), child_req_types_by_current_type\n\n\ndef change_keys_js_to_python(input_dict, model_class):\n    \"\"\"\n    Converts from javascript_key keys in the input_dict to python_keys in\n    the output dict using the mapping in model_class.\n    If the input_dict contains a key which does not declared in the model_class,\n    the key is added to the output dict as is. The assumption is the model_class\n    may have undeclared properties (additionalProperties attribute in the OAS\n    document).\n    \"\"\"\n\n    if getattr(model_class, 'attribute_map', None) is None:\n        return input_dict\n    output_dict = {}\n    reversed_attr_map = {value: key for key, value in\n                         model_class.attribute_map.items()}\n    for javascript_key, value in input_dict.items():\n        python_key = reversed_attr_map.get(javascript_key)\n        if python_key is None:\n            # if the key is unknown, it is in error or it is an\n            # additionalProperties variable\n            python_key = javascript_key\n        output_dict[python_key] = value\n    return output_dict\n\n\ndef get_type_error(var_value, path_to_item, valid_classes, key_type=False):\n    error_msg = type_error_message(\n        var_name=path_to_item[-1],\n        var_value=var_value,\n        valid_classes=valid_classes,\n        key_type=key_type\n    )\n    return ApiTypeError(\n        error_msg,\n        path_to_item=path_to_item,\n        valid_classes=valid_classes,\n        key_type=key_type\n    )\n\n\ndef deserialize_primitive(data, klass, path_to_item):\n    \"\"\"Deserializes string to primitive type.\n\n    :param data: str/int/float\n    :param klass: str/class the class to convert to\n\n    :return: int, float, str, bool, date, datetime\n    \"\"\"\n    additional_message = \"\"\n    try:\n        if klass in {datetime, date}:\n            additional_message = (\n                \"If you need your parameter to have a fallback \"\n                \"string value, please set its type as `type: {}` in your \"\n                \"spec. That allows the value to be any type. \"\n            )\n            if klass == datetime:\n                if len(data) < 8:\n                    raise ValueError(\"This is not a datetime\")\n                # The string should be in iso8601 datetime format.\n                parsed_datetime = parse(data)\n                date_only = (\n                    parsed_datetime.hour == 0 and\n                    parsed_datetime.minute == 0 and\n                    parsed_datetime.second == 0 and\n                    parsed_datetime.tzinfo is None and\n                    8 <= len(data) <= 10\n                )\n                if date_only:\n                    raise ValueError(\"This is a date, not a datetime\")\n                return parsed_datetime\n            elif klass == date:\n                if len(data) < 8:\n                    raise ValueError(\"This is not a date\")\n                return parse(data).date()\n        else:\n            converted_value = klass(data)\n            if isinstance(data, str) and klass == float:\n                if str(converted_value) != data:\n                    # '7' -> 7.0 -> '7.0' != '7'\n                    raise ValueError('This is not a float')\n            return converted_value\n    except (OverflowError, ValueError) as ex:\n        # parse can raise OverflowError\n        raise ApiValueError(\n            \"{0}Failed to parse {1} as {2}\".format(\n                additional_message, repr(data), klass.__name__\n            ),\n            path_to_item=path_to_item\n        ) from ex\n\n\ndef get_discriminator_class(model_class,\n                            discr_name,\n                            discr_value, cls_visited):\n    \"\"\"Returns the child class specified by the discriminator.\n\n    Args:\n        model_class (OpenApiModel): the model class.\n        discr_name (string): the name of the discriminator property.\n        discr_value (any): the discriminator value.\n        cls_visited (list): list of model classes that have been visited.\n            Used to determine the discriminator class without\n            visiting circular references indefinitely.\n\n    Returns:\n        used_model_class (class/None): the chosen child class that will be used\n            to deserialize the data, for example dog.Dog.\n            If a class is not found, None is returned.\n    \"\"\"\n\n    if model_class in cls_visited:\n        # The class has already been visited and no suitable class was found.\n        return None\n    cls_visited.append(model_class)\n    used_model_class = None\n    if discr_name in model_class.discriminator:\n        class_name_to_discr_class = model_class.discriminator[discr_name]\n        used_model_class = class_name_to_discr_class.get(discr_value)\n    if used_model_class is None:\n        # We didn't find a discriminated class in class_name_to_discr_class.\n        # So look in the ancestor or descendant discriminators\n        # The discriminator mapping may exist in a descendant (anyOf, oneOf)\n        # or ancestor (allOf).\n        # Ancestor example: in the GrandparentAnimal -> ParentPet -> ChildCat\n        #   hierarchy, the discriminator mappings may be defined at any level\n        #   in the hierarchy.\n        # Descendant example:  mammal -> whale/zebra/Pig -> BasquePig/DanishPig\n        #   if we try to make BasquePig from mammal, we need to travel through\n        #   the oneOf descendant discriminators to find BasquePig\n        descendant_classes = model_class._composed_schemas.get('oneOf', ()) + \\\n            model_class._composed_schemas.get('anyOf', ())\n        ancestor_classes = model_class._composed_schemas.get('allOf', ())\n        possible_classes = descendant_classes + ancestor_classes\n        for cls in possible_classes:\n            # Check if the schema has inherited discriminators.\n            if hasattr(cls, 'discriminator') and cls.discriminator is not None:\n                used_model_class = get_discriminator_class(\n                    cls, discr_name, discr_value, cls_visited)\n                if used_model_class is not None:\n                    return used_model_class\n    return used_model_class\n\n\ndef deserialize_model(model_data, model_class, path_to_item, check_type,\n                      configuration, spec_property_naming):\n    \"\"\"Deserializes model_data to model instance.\n\n    Args:\n        model_data (int/str/float/bool/none_type/list/dict): data to instantiate the model\n        model_class (OpenApiModel): the model class\n        path_to_item (list): path to the model in the received data\n        check_type (bool): whether to check the data tupe for the values in\n            the model\n        configuration (Configuration): the instance to use to convert files\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n\n    Returns:\n        model instance\n\n    Raise:\n        ApiTypeError\n        ApiValueError\n        ApiKeyError\n    \"\"\"\n\n    kw_args = dict(_check_type=check_type,\n                   _path_to_item=path_to_item,\n                   _configuration=configuration,\n                   _spec_property_naming=spec_property_naming)\n\n    if issubclass(model_class, ModelSimple):\n        return model_class._new_from_openapi_data(model_data, **kw_args)\n    elif isinstance(model_data, list):\n        return model_class._new_from_openapi_data(*model_data, **kw_args)\n    if isinstance(model_data, dict):\n        kw_args.update(model_data)\n        return model_class._new_from_openapi_data(**kw_args)\n    elif isinstance(model_data, PRIMITIVE_TYPES):\n        return model_class._new_from_openapi_data(model_data, **kw_args)\n\n\ndef deserialize_file(response_data, configuration, content_disposition=None):\n    \"\"\"Deserializes body to file\n\n    Saves response body into a file in a temporary folder,\n    using the filename from the `Content-Disposition` header if provided.\n\n    Args:\n        param response_data (str):  the file data to write\n        configuration (Configuration): the instance to use to convert files\n\n    Keyword Args:\n        content_disposition (str):  the value of the Content-Disposition\n            header\n\n    Returns:\n        (file_type): the deserialized file which is open\n            The user is responsible for closing and reading the file\n    \"\"\"\n    fd, path = tempfile.mkstemp(dir=configuration.temp_folder_path)\n    os.close(fd)\n    os.remove(path)\n\n    if content_disposition:\n        filename = re.search(r'filename=[\\'\"]?([^\\'\"\\s]+)[\\'\"]?',\n                             content_disposition,\n                             flags=re.I)\n        if filename is not None:\n            filename = filename.group(1)\n        else:\n            filename = \"default_\" + str(uuid.uuid4())\n\n        path = os.path.join(os.path.dirname(path), filename)\n\n    with open(path, \"wb\") as f:\n        if isinstance(response_data, str):\n            # change str to bytes so we can write it\n            response_data = response_data.encode('utf-8')\n        f.write(response_data)\n\n    f = open(path, \"rb\")\n    return f\n\n\ndef attempt_convert_item(input_value, valid_classes, path_to_item,\n                         configuration, spec_property_naming, key_type=False,\n                         must_convert=False, check_type=True):\n    \"\"\"\n    Args:\n        input_value (any): the data to convert\n        valid_classes (any): the classes that are valid\n        path_to_item (list): the path to the item to convert\n        configuration (Configuration): the instance to use to convert files\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        key_type (bool): if True we need to convert a key type (not supported)\n        must_convert (bool): if True we must convert\n        check_type (bool): if True we check the type or the returned data in\n            ModelComposed/ModelNormal/ModelSimple instances\n\n    Returns:\n        instance (any) the fixed item\n\n    Raises:\n        ApiTypeError\n        ApiValueError\n        ApiKeyError\n    \"\"\"\n    valid_classes_ordered = order_response_types(valid_classes)\n    valid_classes_coercible = remove_uncoercible(\n        valid_classes_ordered, input_value, spec_property_naming)\n    if not valid_classes_coercible or key_type:\n        # we do not handle keytype errors, json will take care\n        # of this for us\n        if configuration is None or not configuration.discard_unknown_keys:\n            raise get_type_error(input_value, path_to_item, valid_classes,\n                                 key_type=key_type)\n    for valid_class in valid_classes_coercible:\n        try:\n            if issubclass(valid_class, OpenApiModel):\n                return deserialize_model(input_value, valid_class,\n                                         path_to_item, check_type,\n                                         configuration, spec_property_naming)\n            elif valid_class == file_type:\n                return deserialize_file(input_value, configuration)\n            return deserialize_primitive(input_value, valid_class,\n                                         path_to_item)\n        except (ApiTypeError, ApiValueError, ApiKeyError) as conversion_exc:\n            if must_convert:\n                raise conversion_exc\n            # if we have conversion errors when must_convert == False\n            # we ignore the exception and move on to the next class\n            continue\n    # we were unable to convert, must_convert == False\n    return input_value\n\n\ndef is_type_nullable(input_type):\n    \"\"\"\n    Returns true if None is an allowed value for the specified input_type.\n\n    A type is nullable if at least one of the following conditions is true:\n    1. The OAS 'nullable' attribute has been specified,\n    1. The type is the 'null' type,\n    1. The type is a anyOf/oneOf composed schema, and a child schema is\n       the 'null' type.\n    Args:\n        input_type (type): the class of the input_value that we are\n            checking\n    Returns:\n        bool\n    \"\"\"\n    if input_type is none_type:\n        return True\n    if issubclass(input_type, OpenApiModel) and input_type._nullable:\n        return True\n    if issubclass(input_type, ModelComposed):\n        # If oneOf/anyOf, check if the 'null' type is one of the allowed types.\n        for t in input_type._composed_schemas.get('oneOf', ()):\n            if is_type_nullable(t):\n                return True\n        for t in input_type._composed_schemas.get('anyOf', ()):\n            if is_type_nullable(t):\n                return True\n    return False\n\n\ndef is_valid_type(input_class_simple, valid_classes):\n    \"\"\"\n    Args:\n        input_class_simple (class): the class of the input_value that we are\n            checking\n        valid_classes (tuple): the valid classes that the current item\n            should be\n    Returns:\n        bool\n    \"\"\"\n    if issubclass(input_class_simple, OpenApiModel) and \\\n            valid_classes == (bool, date, datetime, dict, float, int, list, str, none_type,):\n        return True\n    valid_type = input_class_simple in valid_classes\n    if not valid_type and (\n            issubclass(input_class_simple, OpenApiModel) or\n            input_class_simple is none_type):\n        for valid_class in valid_classes:\n            if input_class_simple is none_type and is_type_nullable(valid_class):\n                # Schema is oneOf/anyOf and the 'null' type is one of the allowed types.\n                return True\n            if not (issubclass(valid_class, OpenApiModel) and valid_class.discriminator):\n                continue\n            discr_propertyname_py = list(valid_class.discriminator.keys())[0]\n            discriminator_classes = (\n                valid_class.discriminator[discr_propertyname_py].values()\n            )\n            valid_type = is_valid_type(input_class_simple, discriminator_classes)\n            if valid_type:\n                return True\n    return valid_type\n\n\ndef validate_and_convert_types(input_value, required_types_mixed, path_to_item,\n                               spec_property_naming, _check_type, configuration=None):\n    \"\"\"Raises a TypeError is there is a problem, otherwise returns value\n\n    Args:\n        input_value (any): the data to validate/convert\n        required_types_mixed (list/dict/tuple): A list of\n            valid classes, or a list tuples of valid classes, or a dict where\n            the value is a tuple of value classes\n        path_to_item: (list) the path to the data being validated\n            this stores a list of keys or indices to get to the data being\n            validated\n        spec_property_naming (bool): True if the variable names in the input\n            data are serialized names as specified in the OpenAPI document.\n            False if the variables names in the input data are python\n            variable names in PEP-8 snake case.\n        _check_type: (boolean) if true, type will be checked and conversion\n            will be attempted.\n        configuration: (Configuration): the configuration class to use\n            when converting file_type items.\n            If passed, conversion will be attempted when possible\n            If not passed, no conversions will be attempted and\n            exceptions will be raised\n\n    Returns:\n        the correctly typed value\n\n    Raises:\n        ApiTypeError\n    \"\"\"\n    results = get_required_type_classes(required_types_mixed, spec_property_naming)\n    valid_classes, child_req_types_by_current_type = results\n\n    input_class_simple = get_simple_class(input_value)\n    valid_type = is_valid_type(input_class_simple, valid_classes)\n    if not valid_type:\n        if (configuration\n                or (input_class_simple == dict\n                    and dict not in valid_classes)):\n            # if input_value is not valid_type try to convert it\n            converted_instance = attempt_convert_item(\n                input_value,\n                valid_classes,\n                path_to_item,\n                configuration,\n                spec_property_naming,\n                key_type=False,\n                must_convert=True,\n                check_type=_check_type\n            )\n            return converted_instance\n        else:\n            raise get_type_error(input_value, path_to_item, valid_classes,\n                                 key_type=False)\n\n    # input_value's type is in valid_classes\n    if len(valid_classes) > 1 and configuration:\n        # there are valid classes which are not the current class\n        valid_classes_coercible = remove_uncoercible(\n            valid_classes, input_value, spec_property_naming, must_convert=False)\n        if valid_classes_coercible:\n            converted_instance = attempt_convert_item(\n                input_value,\n                valid_classes_coercible,\n                path_to_item,\n                configuration,\n                spec_property_naming,\n                key_type=False,\n                must_convert=False,\n                check_type=_check_type\n            )\n            return converted_instance\n\n    if child_req_types_by_current_type == {}:\n        # all types are of the required types and there are no more inner\n        # variables left to look at\n        return input_value\n    inner_required_types = child_req_types_by_current_type.get(\n        type(input_value)\n    )\n    if inner_required_types is None:\n        # for this type, there are not more inner variables left to look at\n        return input_value\n    if isinstance(input_value, list):\n        if input_value == []:\n            # allow an empty list\n            return input_value\n        for index, inner_value in enumerate(input_value):\n            inner_path = list(path_to_item)\n            inner_path.append(index)\n            input_value[index] = validate_and_convert_types(\n                inner_value,\n                inner_required_types,\n                inner_path,\n                spec_property_naming,\n                _check_type,\n                configuration=configuration\n            )\n    elif isinstance(input_value, dict):\n        if input_value == {}:\n            # allow an empty dict\n            return input_value\n        for inner_key, inner_val in input_value.items():\n            inner_path = list(path_to_item)\n            inner_path.append(inner_key)\n            if get_simple_class(inner_key) != str:\n                raise get_type_error(inner_key, inner_path, valid_classes,\n                                     key_type=True)\n            input_value[inner_key] = validate_and_convert_types(\n                inner_val,\n                inner_required_types,\n                inner_path,\n                spec_property_naming,\n                _check_type,\n                configuration=configuration\n            )\n    return input_value\n\n\ndef model_to_dict(model_instance, serialize=True):\n    \"\"\"Returns the model properties as a dict\n\n    Args:\n        model_instance (one of your model instances): the model instance that\n            will be converted to a dict.\n\n    Keyword Args:\n        serialize (bool): if True, the keys in the dict will be values from\n            attribute_map\n    \"\"\"\n    result = {}\n\n    def extract_item(item): return (\n        item[0], model_to_dict(\n            item[1], serialize=serialize)) if hasattr(\n        item[1], '_data_store') else item\n\n    model_instances = [model_instance]\n    if model_instance._composed_schemas:\n        model_instances.extend(model_instance._composed_instances)\n    seen_json_attribute_names = set()\n    used_fallback_python_attribute_names = set()\n    py_to_json_map = {}\n    for model_instance in model_instances:\n        for attr, value in model_instance._data_store.items():\n            if serialize:\n                # we use get here because additional property key names do not\n                # exist in attribute_map\n                try:\n                    attr = model_instance.attribute_map[attr]\n                    py_to_json_map.update(model_instance.attribute_map)\n                    seen_json_attribute_names.add(attr)\n                except KeyError:\n                    used_fallback_python_attribute_names.add(attr)\n            if isinstance(value, list):\n                if not value:\n                    # empty list or None\n                    result[attr] = value\n                else:\n                    res = []\n                    for v in value:\n                        if isinstance(v, PRIMITIVE_TYPES) or v is None:\n                            res.append(v)\n                        elif isinstance(v, ModelSimple):\n                            res.append(v.value)\n                        elif isinstance(v, dict):\n                            res.append(dict(map(\n                                extract_item,\n                                v.items()\n                            )))\n                        else:\n                            res.append(model_to_dict(v, serialize=serialize))\n                    result[attr] = res\n            elif isinstance(value, dict):\n                result[attr] = dict(map(\n                    extract_item,\n                    value.items()\n                ))\n            elif isinstance(value, ModelSimple):\n                result[attr] = value.value\n            elif hasattr(value, '_data_store'):\n                result[attr] = model_to_dict(value, serialize=serialize)\n            else:\n                result[attr] = value\n    if serialize:\n        for python_key in used_fallback_python_attribute_names:\n            json_key = py_to_json_map.get(python_key)\n            if json_key is None:\n                continue\n            if python_key == json_key:\n                continue\n            json_key_assigned_no_need_for_python_key = json_key in seen_json_attribute_names\n            if json_key_assigned_no_need_for_python_key:\n                del result[python_key]\n\n    return result\n\n\ndef type_error_message(var_value=None, var_name=None, valid_classes=None,\n                       key_type=None):\n    \"\"\"\n    Keyword Args:\n        var_value (any): the variable which has the type_error\n        var_name (str): the name of the variable which has the typ error\n        valid_classes (tuple): the accepted classes for current_item's\n                                  value\n        key_type (bool): False if our value is a value in a dict\n                         True if it is a key in a dict\n                         False if our item is an item in a list\n    \"\"\"\n    key_or_value = 'value'\n    if key_type:\n        key_or_value = 'key'\n    valid_classes_phrase = get_valid_classes_phrase(valid_classes)\n    msg = (\n        \"Invalid type for variable '{0}'. Required {1} type {2} and \"\n        \"passed type was {3}\".format(\n            var_name,\n            key_or_value,\n            valid_classes_phrase,\n            type(var_value).__name__,\n        )\n    )\n    return msg\n\n\ndef get_valid_classes_phrase(input_classes):\n    \"\"\"Returns a string phrase describing what types are allowed\n    \"\"\"\n    all_classes = list(input_classes)\n    all_classes = sorted(all_classes, key=lambda cls: cls.__name__)\n    all_class_names = [cls.__name__ for cls in all_classes]\n    if len(all_class_names) == 1:\n        return 'is {0}'.format(all_class_names[0])\n    return \"is one of [{0}]\".format(\", \".join(all_class_names))\n\n\ndef get_allof_instances(self, model_args, constant_args):\n    \"\"\"\n    Args:\n        self: the class we are handling\n        model_args (dict): var_name to var_value\n            used to make instances\n        constant_args (dict):\n            metadata arguments:\n            _check_type\n            _path_to_item\n            _spec_property_naming\n            _configuration\n            _visited_composed_classes\n\n    Returns\n        composed_instances (list)\n    \"\"\"\n    composed_instances = []\n    for allof_class in self._composed_schemas['allOf']:\n\n        try:\n            if constant_args.get('_spec_property_naming'):\n                allof_instance = allof_class._from_openapi_data(**model_args, **constant_args)\n            else:\n                allof_instance = allof_class(**model_args, **constant_args)\n            composed_instances.append(allof_instance)\n        except Exception as ex:\n            raise ApiValueError(\n                \"Invalid inputs given to generate an instance of '%s'. The \"\n                \"input data was invalid for the allOf schema '%s' in the composed \"\n                \"schema '%s'. Error=%s\" % (\n                    allof_class.__name__,\n                    allof_class.__name__,\n                    self.__class__.__name__,\n                    str(ex)\n                )\n            ) from ex\n    return composed_instances\n\n\ndef get_oneof_instance(cls, model_kwargs, constant_kwargs, model_arg=None):\n    \"\"\"\n    Find the oneOf schema that matches the input data (e.g. payload).\n    If exactly one schema matches the input data, an instance of that schema\n    is returned.\n    If zero or more than one schema match the input data, an exception is raised.\n    In OAS 3.x, the payload MUST, by validation, match exactly one of the\n    schemas described by oneOf.\n\n    Args:\n        cls: the class we are handling\n        model_kwargs (dict): var_name to var_value\n            The input data, e.g. the payload that must match a oneOf schema\n            in the OpenAPI document.\n        constant_kwargs (dict): var_name to var_value\n            args that every model requires, including configuration, server\n            and path to item.\n\n    Kwargs:\n        model_arg: (int, float, bool, str, date, datetime, ModelSimple, None):\n            the value to assign to a primitive class or ModelSimple class\n            Notes:\n            - this is only passed in when oneOf includes types which are not object\n            - None is used to suppress handling of model_arg, nullable models are handled in __new__\n\n    Returns\n        oneof_instance (instance)\n    \"\"\"\n    if len(cls._composed_schemas['oneOf']) == 0:\n        return None\n\n    oneof_instances = []\n    # Iterate over each oneOf schema and determine if the input data\n    # matches the oneOf schemas.\n    for oneof_class in cls._composed_schemas['oneOf']:\n        # The composed oneOf schema allows the 'null' type and the input data\n        # is the null value. This is a OAS >= 3.1 feature.\n        if oneof_class is none_type:\n            # skip none_types because we are deserializing dict data.\n            # none_type deserialization is handled in the __new__ method\n            continue\n\n        single_value_input = allows_single_value_input(oneof_class)\n\n        try:\n            if not single_value_input:\n                if constant_kwargs.get('_spec_property_naming'):\n                    oneof_instance = oneof_class._from_openapi_data(\n                        **model_kwargs, **constant_kwargs)\n                else:\n                    oneof_instance = oneof_class(**model_kwargs, **constant_kwargs)\n            else:\n                if issubclass(oneof_class, ModelSimple):\n                    if constant_kwargs.get('_spec_property_naming'):\n                        oneof_instance = oneof_class._from_openapi_data(\n                            model_arg, **constant_kwargs)\n                    else:\n                        oneof_instance = oneof_class(model_arg, **constant_kwargs)\n                elif oneof_class in PRIMITIVE_TYPES:\n                    oneof_instance = validate_and_convert_types(\n                        model_arg,\n                        (oneof_class,),\n                        constant_kwargs['_path_to_item'],\n                        constant_kwargs['_spec_property_naming'],\n                        constant_kwargs['_check_type'],\n                        configuration=constant_kwargs['_configuration']\n                    )\n            oneof_instances.append(oneof_instance)\n        except Exception:\n            pass\n    if len(oneof_instances) == 0:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. None \"\n            \"of the oneOf schemas matched the input data.\" %\n            cls.__name__\n        )\n    elif len(oneof_instances) > 1:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. Multiple \"\n            \"oneOf schemas matched the inputs, but a max of one is allowed.\" %\n            cls.__name__\n        )\n    return oneof_instances[0]\n\n\ndef get_anyof_instances(self, model_args, constant_args):\n    \"\"\"\n    Args:\n        self: the class we are handling\n        model_args (dict): var_name to var_value\n            The input data, e.g. the payload that must match at least one\n            anyOf child schema in the OpenAPI document.\n        constant_args (dict): var_name to var_value\n            args that every model requires, including configuration, server\n            and path to item.\n\n    Returns\n        anyof_instances (list)\n    \"\"\"\n    anyof_instances = []\n    if len(self._composed_schemas['anyOf']) == 0:\n        return anyof_instances\n\n    for anyof_class in self._composed_schemas['anyOf']:\n        # The composed oneOf schema allows the 'null' type and the input data\n        # is the null value. This is a OAS >= 3.1 feature.\n        if anyof_class is none_type:\n            # skip none_types because we are deserializing dict data.\n            # none_type deserialization is handled in the __new__ method\n            continue\n\n        try:\n            if constant_args.get('_spec_property_naming'):\n                anyof_instance = anyof_class._from_openapi_data(**model_args, **constant_args)\n            else:\n                anyof_instance = anyof_class(**model_args, **constant_args)\n            anyof_instances.append(anyof_instance)\n        except Exception:\n            pass\n    if len(anyof_instances) == 0:\n        raise ApiValueError(\n            \"Invalid inputs given to generate an instance of %s. None of the \"\n            \"anyOf schemas matched the inputs.\" %\n            self.__class__.__name__\n        )\n    return anyof_instances\n\n\ndef get_discarded_args(self, composed_instances, model_args):\n    \"\"\"\n    Gathers the args that were discarded by configuration.discard_unknown_keys\n    \"\"\"\n    model_arg_keys = model_args.keys()\n    discarded_args = set()\n    # arguments passed to self were already converted to python names\n    # before __init__ was called\n    for instance in composed_instances:\n        if instance.__class__ in self._composed_schemas['allOf']:\n            try:\n                keys = instance.to_dict().keys()\n                discarded_keys = model_args - keys\n                discarded_args.update(discarded_keys)\n            except Exception:\n                # allOf integer schema will throw exception\n                pass\n        else:\n            try:\n                all_keys = set(model_to_dict(instance, serialize=False).keys())\n                js_keys = model_to_dict(instance, serialize=True).keys()\n                all_keys.update(js_keys)\n                discarded_keys = model_arg_keys - all_keys\n                discarded_args.update(discarded_keys)\n            except Exception:\n                # allOf integer schema will throw exception\n                pass\n    return discarded_args\n\n\ndef validate_get_composed_info(constant_args, model_args, self):\n    \"\"\"\n    For composed schemas, generate schema instances for\n    all schemas in the oneOf/anyOf/allOf definition. If additional\n    properties are allowed, also assign those properties on\n    all matched schemas that contain additionalProperties.\n    Openapi schemas are python classes.\n\n    Exceptions are raised if:\n    - 0 or > 1 oneOf schema matches the model_args input data\n    - no anyOf schema matches the model_args input data\n    - any of the allOf schemas do not match the model_args input data\n\n    Args:\n        constant_args (dict): these are the args that every model requires\n        model_args (dict): these are the required and optional spec args that\n            were passed in to make this model\n        self (class): the class that we are instantiating\n            This class contains self._composed_schemas\n\n    Returns:\n        composed_info (list): length three\n            composed_instances (list): the composed instances which are not\n                self\n            var_name_to_model_instances (dict): a dict going from var_name\n                to the model_instance which holds that var_name\n                the model_instance may be self or an instance of one of the\n                classes in self.composed_instances()\n            additional_properties_model_instances (list): a list of the\n                model instances which have the property\n                additional_properties_type. This list can include self\n    \"\"\"\n    # create composed_instances\n    composed_instances = []\n    allof_instances = get_allof_instances(self, model_args, constant_args)\n    composed_instances.extend(allof_instances)\n    oneof_instance = get_oneof_instance(self.__class__, model_args, constant_args)\n    if oneof_instance is not None:\n        composed_instances.append(oneof_instance)\n    anyof_instances = get_anyof_instances(self, model_args, constant_args)\n    composed_instances.extend(anyof_instances)\n    \"\"\"\n    set additional_properties_model_instances\n    additional properties must be evaluated at the schema level\n    so self's additional properties are most important\n    If self is a composed schema with:\n    - no properties defined in self\n    - additionalProperties: False\n    Then for object payloads every property is an additional property\n    and they are not allowed, so only empty dict is allowed\n\n    Properties must be set on all matching schemas\n    so when a property is assigned toa composed instance, it must be set on all\n    composed instances regardless of additionalProperties presence\n    keeping it to prevent breaking changes in v5.0.1\n    TODO remove cls._additional_properties_model_instances in 6.0.0\n    \"\"\"\n    additional_properties_model_instances = []\n    if self.additional_properties_type is not None:\n        additional_properties_model_instances = [self]\n\n    \"\"\"\n    no need to set properties on self in here, they will be set in __init__\n    By here all composed schema oneOf/anyOf/allOf instances have their properties set using\n    model_args\n    \"\"\"\n    discarded_args = get_discarded_args(self, composed_instances, model_args)\n\n    # map variable names to composed_instances\n    var_name_to_model_instances = {}\n    for prop_name in model_args:\n        if prop_name not in discarded_args:\n            var_name_to_model_instances[prop_name] = [self] + list(\n                filter(\n                    lambda x: prop_name in x.openapi_types, composed_instances))\n\n    return [\n        composed_instances,\n        var_name_to_model_instances,\n        additional_properties_model_instances,\n        discarded_args\n    ]\n",
    "uncovered_lines": [
      40,
      81,
      85,
      86,
      87,
      88,
      89,
      90,
      99,
      100,
      101,
      102,
      103,
      105,
      106,
      107,
      108,
      109,
      110,
      111,
      112,
      113,
      115,
      116,
      133,
      142,
      148,
      176,
      191,
      192,
      193,
      195,
      198,
      200,
      201,
      203,
      205,
      206,
      207,
      215,
      216,
      217,
      219,
      221,
      222,
      223,
      224,
      226,
      227,
      247,
      252,
      253,
      254,
      255,
      256,
      257,
      260,
      261,
      271,
      273,
      274,
      275,
      277,
      284,
      301,
      304,
      305,
      306,
      309,
      310,
      312,
      315,
      316,
      318,
      320,
      322,
      323,
      325,
      338,
      341,
      342,
      343,
      371,
      372,
      373,
      374,
      375,
      376,
      379,
      380,
      390,
      392,
      393,
      394,
      396,
      403,
      420,
      423,
      424,
      425,
      428,
      429,
      431,
      434,
      436,
      437,
      455,
      464,
      473,
      479,
      483,
      484,
      486,
      487,
      488,
      489,
      490,
      491,
      492,
      509,
      510,
      512,
      516,
      517,
      519,
      527,
      528,
      530,
      534,
      538,
      545,
      546,
      547,
      548,
      549,
      550,
      551,
      552,
      553,
      554,
      555,
      586,
      587,
      588,
      601,
      613,
      614,
      620,
      621,
      622,
      623,
      625,
      626,
      632,
      633,
      636,
      637,
      642,
      643,
      644,
      645,
      646,
      647,
      648,
      649,
      650,
      651,
      652,
      653,
      654,
      663,
      664,
      665,
      670,
      675,
      676,
      678,
      681,
      682,
      683,
      684,
      686,
      690,
      694,
      698,
      699,
      701,
      702,
      703,
      704,
      705,
      706,
      707,
      708,
      709,
      710,
      711,
      803,
      805,
      807,
      813,
      823,
      825,
      828,
      844,
      846,
      857,
      859,
      869,
      908,
      916,
      927,
      938,
      949,
      960,
      971,
      972,
      973,
      974,
      975,
      976,
      978,
      979,
      984,
      994,
      1005,
      1016,
      1028,
      1032,
      1035,
      1036,
      1053,
      1055,
      1058,
      1067,
      1105,
      1117,
      1128,
      1129,
      1130,
      1131,
      1132,
      1133,
      1134,
      1136,
      1137,
      1144,
      1146,
      1147,
      1149,
      1201,
      1202,
      1203,
      1204,
      1206,
      1207,
      1208,
      1211,
      1212,
      1213,
      1217,
      1223,
      1252,
      1259,
      1260,
      1261,
      1269,
      1271,
      1302,
      1304,
      1305,
      1306,
      1307,
      1308,
      1309,
      1310,
      1321,
      1323,
      1324,
      1325,
      1327,
      1328,
      1330,
      1331,
      1332,
      1368,
      1372,
      1373,
      1394,
      1395,
      1396,
      1398,
      1399,
      1402,
      1403,
      1405,
      1407,
      1409,
      1410,
      1412,
      1413,
      1415,
      1416,
      1451,
      1452,
      1461,
      1466,
      1489,
      1490,
      1491,
      1492,
      1493,
      1495,
      1496,
      1497,
      1498,
      1499,
      1500,
      1501,
      1516,
      1521,
      1522,
      1524,
      1525,
      1526,
      1527,
      1528,
      1531,
      1532,
      1533,
      1589,
      1621,
      1623,
      1624,
      1625,
      1626,
      1627,
      1638,
      1643,
      1676,
      1692,
      1694,
      1696,
      1697,
      1698,
      1699,
      1700,
      1701,
      1702,
      1703,
      1708,
      1709,
      1726,
      1727,
      1728,
      1729,
      1730,
      1747,
      1748,
      1749,
      1750,
      1751,
      1760,
      1766,
      1767,
      1768,
      1769,
      1770,
      1771,
      1791,
      1792,
      1794,
      1795,
      1796,
      1798,
      1799,
      1800,
      1801,
      1811,
      1842,
      1843,
      1845,
      1848,
      1851,
      1854,
      1856,
      1858,
      1859,
      1860,
      1861,
      1864,
      1866,
      1867,
      1868,
      1871,
      1872,
      1873,
      1881,
      1882,
      1884,
      1885,
      1890,
      1891,
      1896,
      1913,
      1914,
      1915,
      1917,
      1920,
      1923,
      1925,
      1926,
      1927,
      1929,
      1930,
      1931,
      1933,
      1934,
      1939,
      1946,
      1947,
      1950,
      1951,
      1952,
      1953,
      1954,
      1955,
      1956,
      1960,
      1961,
      1962,
      1963,
      1964,
      1965,
      1966,
      1969,
      2005,
      2006,
      2007,
      2008,
      2009,
      2010,
      2011,
      2012,
      2029,
      2030,
      2031,
      2038,
      2041,
      2042,
      2043,
      2044,
      2048
    ]
  },
  {
    "file_path": "xendit/rest.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport io\nimport json\nimport logging\nimport re\nimport ssl\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlparse\nfrom urllib.request import proxy_bypass_environment\nimport urllib3\nimport ipaddress\n\nfrom xendit.exceptions import ApiValueError, XenditSdkException\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass RESTResponse(io.IOBase):\n\n    def __init__(self, resp):\n        self.urllib3_response = resp\n        self.status = resp.status\n        self.reason = resp.reason\n        self.data = resp.data\n\n    def getheaders(self):\n        \"\"\"Returns a dictionary of the response headers.\"\"\"\n        return self.urllib3_response.getheaders()\n\n    def getheader(self, name, default=None):\n        \"\"\"Returns a given response header.\"\"\"\n        return self.urllib3_response.getheader(name, default)\n\n\nclass RESTClientObject(object):\n\n    def __init__(self, configuration, pools_size=4, maxsize=None):\n        # urllib3.PoolManager will pass all kw parameters to connectionpool\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501\n        # maxsize is the number of requests to host that are allowed in parallel  # noqa: E501\n        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501\n\n        self.configuration = configuration\n\n        # cert_reqs\n        if configuration.verify_ssl:\n            cert_reqs = ssl.CERT_REQUIRED\n        else:\n            cert_reqs = ssl.CERT_NONE\n\n        addition_pool_args = {}\n        if configuration.assert_hostname is not None:\n            addition_pool_args['assert_hostname'] = configuration.assert_hostname  # noqa: E501\n\n        if configuration.retries is not None:\n            addition_pool_args['retries'] = configuration.retries\n\n        if configuration.tls_server_name:\n            addition_pool_args['server_hostname'] = configuration.tls_server_name\n\n\n        if configuration.socket_options is not None:\n            addition_pool_args['socket_options'] = configuration.socket_options\n\n        if maxsize is None:\n            if configuration.connection_pool_maxsize is not None:\n                maxsize = configuration.connection_pool_maxsize\n            else:\n                maxsize = 4\n\n        # https pool manager\n        if configuration.proxy and not should_bypass_proxies(\n                configuration.host, no_proxy=configuration.no_proxy or ''):\n            self.pool_manager = urllib3.ProxyManager(\n                num_pools=pools_size,\n                maxsize=maxsize,\n                cert_reqs=cert_reqs,\n                ca_certs=configuration.ssl_ca_cert,\n                cert_file=configuration.cert_file,\n                key_file=configuration.key_file,\n                proxy_url=configuration.proxy,\n                proxy_headers=configuration.proxy_headers,\n                **addition_pool_args\n            )\n        else:\n            self.pool_manager = urllib3.PoolManager(\n                num_pools=pools_size,\n                maxsize=maxsize,\n                cert_reqs=cert_reqs,\n                ca_certs=configuration.ssl_ca_cert,\n                cert_file=configuration.cert_file,\n                key_file=configuration.key_file,\n                **addition_pool_args\n            )\n\n    def request(self, method, url, query_params=None, headers=None,\n                body=None, post_params=None, _preload_content=True,\n                _request_timeout=None):\n        \"\"\"Perform requests.\n\n        :param method: http request method\n        :param url: http request url\n        :param query_params: query parameters in the url\n        :param headers: http request headers\n        :param body: request json body, for `application/json`\n        :param post_params: request post parameters,\n                            `application/x-www-form-urlencoded`\n                            and `multipart/form-data`\n        :param _preload_content: if False, the urllib3.HTTPResponse object will\n                                 be returned without reading/decoding response\n                                 data. Default is True.\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        \"\"\"\n        method = method.upper()\n        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT',\n                          'PATCH', 'OPTIONS']\n\n        if post_params and body:\n            raise ApiValueError(\n                \"body parameter cannot be used with post_params parameter.\"\n            )\n\n        post_params = post_params or {}\n        headers = headers or {}\n\n        timeout = None\n        if _request_timeout:\n            if isinstance(_request_timeout, (int, float)):  # noqa: E501,F821\n                timeout = urllib3.Timeout(total=_request_timeout)\n            elif (isinstance(_request_timeout, tuple) and\n                  len(_request_timeout) == 2):\n                timeout = urllib3.Timeout(\n                    connect=_request_timeout[0], read=_request_timeout[1])\n\n        try:\n            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`\n            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:\n                # Only set a default Content-Type for POST, PUT, PATCH and OPTIONS requests\n                if (method != 'DELETE') and ('Content-Type' not in headers):\n                    headers['Content-Type'] = 'application/json'\n                if query_params:\n                    url += '?' + urlencode(query_params)\n                if ('Content-Type' not in headers) or (re.search('json',\n                                                                 headers['Content-Type'], re.IGNORECASE)):\n                    request_body = None\n                    if body is not None:\n                        request_body = json.dumps(body)\n                    r = self.pool_manager.request(\n                        method, url,\n                        body=request_body,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501\n                    r = self.pool_manager.request(\n                        method, url,\n                        fields=post_params,\n                        encode_multipart=False,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                elif headers['Content-Type'] == 'multipart/form-data':\n                    # must del headers['Content-Type'], or the correct\n                    # Content-Type which generated by urllib3 will be\n                    # overwritten.\n                    del headers['Content-Type']\n                    r = self.pool_manager.request(\n                        method, url,\n                        fields=post_params,\n                        encode_multipart=True,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                # Pass a `string` parameter directly in the body to support\n                # other content types than Json when `body` argument is\n                # provided in serialized form\n                elif isinstance(body, str) or isinstance(body, bytes):\n                    request_body = body\n                    r = self.pool_manager.request(\n                        method, url,\n                        body=request_body,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                else:\n                    # Cannot generate the request from given parameters\n                    msg = \"\"\"Cannot prepare a request message for provided\n                             arguments. Please check that your arguments match\n                             declared content type.\"\"\"\n                    raise XenditSdkException(\n                        param_status=\"0\",\n                        param_status_text=msg\n                    )\n            # For `GET`, `HEAD`\n            else:\n                r = self.pool_manager.request(method, url,\n                                              fields=query_params,\n                                              preload_content=_preload_content,\n                                              timeout=timeout,\n                                              headers=headers)\n        except urllib3.exceptions.SSLError as e:\n            msg = \"{0}\\n{1}\".format(type(e).__name__, str(e))\n            raise XenditSdkException(\n                param_status=\"0\",\n                param_status_text=msg\n            )\n\n        if _preload_content:\n            r = RESTResponse(r)\n\n            # log response body\n            logger.debug(\"response body: %s\", r.data)\n\n        if not 200 <= r.status <= 299:\n            raise XenditSdkException(\n                raw_response=r.data,\n                param_status=str(r.status),\n                param_status_text=r.reason,\n            )\n        return r\n\n    def GET(self, url, headers=None, query_params=None, _preload_content=True,\n            _request_timeout=None):\n        return self.request(\"GET\", url,\n                            headers=headers,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            query_params=query_params)\n\n    def HEAD(self, url, headers=None, query_params=None, _preload_content=True,\n             _request_timeout=None):\n        return self.request(\"HEAD\", url,\n                            headers=headers,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            query_params=query_params)\n\n    def OPTIONS(self, url, headers=None, query_params=None, post_params=None,\n                body=None, _preload_content=True, _request_timeout=None):\n        return self.request(\"OPTIONS\", url,\n                            headers=headers,\n                            query_params=query_params,\n                            post_params=post_params,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            body=body)\n\n    def DELETE(self, url, headers=None, query_params=None, body=None,\n               _preload_content=True, _request_timeout=None):\n        return self.request(\"DELETE\", url,\n                            headers=headers,\n                            query_params=query_params,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            body=body)\n\n    def POST(self, url, headers=None, query_params=None, post_params=None,\n             body=None, _preload_content=True, _request_timeout=None):\n        return self.request(\"POST\", url,\n                            headers=headers,\n                            query_params=query_params,\n                            post_params=post_params,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            body=body)\n\n    def PUT(self, url, headers=None, query_params=None, post_params=None,\n            body=None, _preload_content=True, _request_timeout=None):\n        return self.request(\"PUT\", url,\n                            headers=headers,\n                            query_params=query_params,\n                            post_params=post_params,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            body=body)\n\n    def PATCH(self, url, headers=None, query_params=None, post_params=None,\n              body=None, _preload_content=True, _request_timeout=None):\n        return self.request(\"PATCH\", url,\n                            headers=headers,\n                            query_params=query_params,\n                            post_params=post_params,\n                            _preload_content=_preload_content,\n                            _request_timeout=_request_timeout,\n                            body=body)\n\n# end of class RESTClientObject\n\n\ndef is_ipv4(target):\n    \"\"\" Test if IPv4 address or not\n    \"\"\"\n    try:\n        chk = ipaddress.IPv4Address(target)\n        return True\n    except ipaddress.AddressValueError:\n        return False\n\n\ndef in_ipv4net(target, net):\n    \"\"\" Test if target belongs to given IPv4 network\n    \"\"\"\n    try:\n        nw = ipaddress.IPv4Network(net)\n        ip = ipaddress.IPv4Address(target)\n        if ip in nw:\n            return True\n        return False\n    except ipaddress.AddressValueError:\n        return False\n    except ipaddress.NetmaskValueError:\n        return False\n\n\ndef should_bypass_proxies(url, no_proxy=None):\n    \"\"\" Yet another requests.should_bypass_proxies\n    Test if proxies should not be used for a particular url.\n    \"\"\"\n\n    parsed = urlparse(url)\n\n    # special cases\n    if parsed.hostname in [None, '']:\n        return True\n\n    # special cases\n    if no_proxy in [None, '']:\n        return False\n    if no_proxy == '*':\n        return True\n\n    no_proxy = no_proxy.lower().replace(' ', '');\n    entries = (\n        host for host in no_proxy.split(',') if host\n    )\n\n    if is_ipv4(parsed.hostname):\n        for item in entries:\n            if in_ipv4net(parsed.hostname, item):\n                return True\n    return proxy_bypass_environment(parsed.hostname, {'no': no_proxy})\n",
    "uncovered_lines": [
      26,
      27,
      28,
      29,
      33,
      37,
      55,
      59,
      62,
      65,
      69,
      75,
      80,
      123,
      124,
      127,
      128,
      132,
      133,
      135,
      136,
      137,
      138,
      139,
      141,
      144,
      146,
      148,
      149,
      150,
      151,
      152,
      154,
      155,
      156,
      157,
      163,
      164,
      171,
      175,
      176,
      186,
      187,
      188,
      196,
      199,
      205,
      210,
      211,
      212,
      217,
      218,
      221,
      223,
      224,
      229,
      233,
      241,
      249,
      259,
      268,
      278,
      288,
      302,
      303,
      304,
      305,
      306,
      312,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      329,
      332,
      333,
      336,
      337,
      338,
      339,
      341,
      342,
      346,
      347,
      348,
      349,
      350
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/balance_api.py",
    "code": "\"\"\"\n    Transaction Service V4 API\n\n    # Introduction This specification describes how to use the Transaction Service V4 API.   **Transaction Service** is the service that records the customer transactions and is responsible to calculate their balance.  All products that move customer money around whether it is money-in, money-out, or transfer will interact with the Transaction Service on its flow. Transaction Service is the source of truth of Xendit and Customer regarding how much money that customer has that is stored in Xendit. Transaction Service is the source that is used for both our internal and customer financial reconciliation. Internally, the Transaction Service data structure is similar to how double-entry accounting works.  ## How Xendit teams/services do integrate with Transaction Service V4   **Channel product team/service** They interact with the Transaction Service when they want to record the transactions. This transaction can be money-in (balance added), money-out (balance deducted), transfer, refund/void/reversal, or other kind of transaction that affects customer balance. Product team also interacts with the Transaction Service for getting information about the transaction or balance.  **Billing/Fee team/service** They interact with Transaction Service either as the dependency of Transaction Service for getting the correct fee calculation/settings. Or using Transaction Service for getting the transaction/fee information to calculate the bill for the customer.  **NUX team/service** They interact with the Transaction Service to set up the customer ledger_account that is used to record their transactions.  **Finance team/service** They interact with the Transaction Service to get the transaction and balance data for each customer to do reconciliation.  **Dashboard/API team/service** They interact with the Transaction Service as a proxy to show the data to the Customer.  ## Prerequisites  Before staring to use **Transaction Service API** you need to complete a few things: 1. Find out **Base URL** for the API. Every endpoint definition in this document contains list of available servers (local, staging, production) 2. Set up ledger accounts using business id and currency. **Ledger Account** represents the account of the customer that will be used to associate with ledger lines. Each business may have at least 1 ledger account group (a group consists of a few accounts of types such as cash, liability, holding), and the money movement of their ledger will revolve around those ledger accounts. **Ledger Lines** that show a debit or credit transaction for a ledger account. Were using the double-entry principle in accounting where we should post 2 lines every time we make a transaction, 1 to debit an account and 1 to credit another account. See how to call <a href=\\\"#operation/setupLedgerAccounts\\\">Create cash, liability, holding, and tax account for a business (api/ledger-accounts/setup)</a> section of this document 3. To be able to create payments with fee/VAT the Product rate settings and VAT rate settings should be created using Transaction Fee Service. See <a href=\\\"https://docs.google.com/document/d/1HrrA4GhWD1DaJS5dn0dh9VyMhLR6TOUMW1qhRUZ9d_k/edit?pli=1#heading=h.518me3lwf8rb\\\">Fee Service Documentation</a> for details about how to create Product/VAT rate settings.   ## Transaction flows  To integrate with the Transaction Service you should decide what types of transaction flows your integration will be using. Transaction flow is set by the transaction `type` during transaction creation  1. Money In flows     1. Payment from credit card           `type: CREDIT_CARD_PAYMENT`           3. Payment from other sources without fee/VAT           `type: DEPOSIT, FOREX_DEPOSIT, ISSUING_FUNDING_REFUND, BNPL_PARTNER_SETTLEMENT_CREDIT, PROMO_FEE_CASHBACK, PROMO_VAT_CASHBACK, BATCH_VA_PAYMENT`           4. Payment from other sources with fee/VAT           `type: VA_PAYMENT, IM_ESCROW_VA_PAYMENT, IM_DEPOSIT, RO_PAYMENT, EWALLET_PAYMENT, CARDLESS_CREDIT_PAYMENT, IM_REMITTANCE_VA_PAYMENT, PAYLATER_PAYMENT, INVOICE, QR_CODE_PAYMENT, DIRECT_DEBIT_PAYMENT, DIRECT_BANK_TRANSFER, ACH_PAYMENT, CRYPTO_PAYMENT`           5. Billing deposit from cash           `type: BILLING_DEPOSIT`           6. Billing deposit from other sources           `type: BILLING_DIRECT_DEPOSIT, BILLING_VA_DIRECT_DEPOSIT`       2. Money out flows     1. Instant payment           `type: simple money out types`              `status: COMPLETED`           2. Simple payment without fee/VAT           `type: CHARGEBACK_DEDUCTION, FRAUD_DEDUCTION, LOAN_REPAYMENT, FOREX_DEDUCTION, BNPL_PARTNER_SETTLEMENT_DEBIT, WITHDRAWAL`       3. Simple payment with fee/VAT           `type: ISSUING_FUNDING, BATCH_DISBURSEMENT, CASH_DISBURSEMENT, DISBURSEMENT, REMITTANCE, REMITTANCE_PAYOUT, TAX_DISBURSEMENT`           4. Billing withdraw to cash           `type: BILLING_WITHDRAWAL`           4. Billing withdraw to other destinations           `type: BILL_PAYMENT`       3. Reversal flow      Some of transactions could be reversed. See <a href=\\\"#section/Introduction/Reversible-non-reversible-transaction-types\\\">Reversible / non reversible transaction types</a> section of this document. To reverse transaction you should call <a href=\\\"#operation/updateTransaction\\\">Update transaction (/api/transactions/:id)</a>  endpoint with the transaction status `REVERSED`.    4. Void/Cancellation Flow      Transaction in the `PENDING_SETTLEMENT` status could be canceled. To do that you should call <a href=\\\"#operation/updateTransaction\\\">Update transaction (/api/transactions/:id)</a>  endpoint with the transaction status `VOIDED`.       5. Switcher flow      Switchers are transactions that do not affect the customer balance. These are transactions that goes directly to the customers account and simply passes through Xendit. Therefore, it will not impact the customer balance and we will only charge Fee and VAT. To create switcher flow you should set `is_switcher_payment` field to `true`.       ## Instant/non instant settlement  Transactions can be performed instantly (instant settlement) or with delay (non instant settlement).  Some of the transaction types are only instantly processed, some of them support both instant and non instant settlement and some of them have only non instant settlement. If settlement is instant than balance will be changed instantly. In opposite case the transaction status has to be set into PENDING_SETTLEMENT and settlement date should be provided.   1. Instant settlement Money In transaction types      `DEPOSIT, BATCH_VA_PAYMENT, FOREX_DEPOSIT, IM_DEPOSIT, CARDLESS_CREDIT_PAYMENT, ISSUING_FUNDING_REFUND, BNPL_PARTNER_SETTLEMENT_CREDIT, PROMO_FEE_CASHBACK, PROMO_VAT_CASHBACK, REMITTANCE_VA_PAYMENT_CLAIM`    2. Both instant and non instant Money In transaction types      `DIRECT_DEBIT_PAYMENT, DIRECT_BANK_TRANSFER, ACH_PAYMENT, RO_PAYMENT, EWALLET_PAYMENT, QR_CODE_PAYMENT, VA_PAYMENT, INVOICE, PAYLATER_PAYMENT`  3. Non Instant settlement Money In transaction types      `CREDIT_CARD_PAYMENT`    4. Instant settlement Money Out transaction types      `LOAN_REPAYMENT, FOREX_DEDUCTION, BILL_PAYMENT, ISSUING_FUNDING, BNPL_PARTNER_SETTLEMENT_DEBIT, FRAUD_DEDUCTION`  5. Both instant and non instant settlement supported Money Out transaction types      `CHARGEBACK_DEDUCTION`  6. Non Instant settlement Money Out transaction types      All other money out types are non instant settlement  ## Reversible / non reversible transaction types  Some transactions can be reversed. Here are the list of transaction types that could be reversed:   `CASH_DISBURSEMENT, DISBURSEMENT, BATCH_DISBURSEMENT, REMITTANCE, REMITTANCE_PAYOUT, TAX_DISBURSEMENT, WITHDRAWAL, DEPOSIT, FOREX_DEPOSIT, FOREX_DEDUCTION, VA_PAYMENT, BATCH_VA_PAYMENT, IM_REMITTANCE_VA_PAYMENT, IM_ESCROW_VA_PAYMENT, IM_DEPOSIT, REMITTANCE_VA_PAYMENT, REMITTANCE_VA_PAYMENT_CLAIM, RO_PAYMENT, CARDLESS_CREDIT_PAYMENT, PAYLATER_PAYMENT, INVOICE, QR_CODE_PAYMENT, CREDIT_CARD_PAYMENT, EWALLET_PAYMENT, DIRECT_DEBIT_PAYMENT, DIRECT_BANK_TRANSFER, ACH_PAYMENT, CHARGEBACK_DEDUCTION, FRAUD_DEDUCTION, LOAN_REPAYMENT, ISSUING_FUNDING, ISSUING_FUNDING_REFUND, BNPL_PARTNER_SETTLEMENT_DEBIT, BNPL_PARTNER_SETTLEMENT_CREDIT, BILLING_DEPOSIT, BILLING_DIRECT_DEPOSIT, BILLING_VA_DIRECT_DEPOSIT, BILLING_WITHDRAWAL, BILL_PAYMENT, PROMO_FEE_CASHBACK, PROMO_VAT_CASHBACK`       ## How to create transaction  After you created or already have the `BUSINESS_CASH` ledger account ID (See <a href=\\\"#section/Introduction/Prerequisites\\\">Prerequisites</a> section) and you know what transaction flows are going to be used  you can create the new transaction using POST request to the  <a href=\\\"#operation/createTransaction\\\">Create a new transaction (/api/transactions)</a>  endpoint  ## How to update transaction  To update transaction you should do  PATCH request to the  <a href=\\\"#operation/updateTransaction\\\">Update transaction (/api/transactions/::id)</a>  endpoint     # noqa: E501\n\n    The version of the OpenAPI document: 5.4.0\n\"\"\"\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\n\nfrom xendit.api_client import ApiClient, Endpoint as _Endpoint\nfrom xendit.model_utils import (  # noqa: F401\n    check_allowed_values,\n    check_validations,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_and_convert_types\n)\nfrom typing import Optional, List # noqa: F401\n\nfrom xendit.balance_and_transaction.model import *  # noqa: F401,E501\n\nclass BalanceApi(object):\n    \"\"\"NOTE: This class is auto generated by the OpenAPI Generator.\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None):\n        if api_client is None:\n            api_client = ApiClient()\n        self.api_client = api_client\n        self.get_balance_endpoint = _Endpoint(\n            settings={\n                'response_type': (Balance,),\n                'auth': [],\n                'endpoint_path': '/balance',\n                'operation_id': 'get_balance',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'account_type',\n                    'currency',\n                    'at_timestamp',\n                    'for_user_id',\n                ],\n                'required': [],\n                'nullable': [\n                ],\n                'enum': [\n                    'account_type',\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                    ('account_type',): {\n\n                        \"CASH\": \"CASH\",\n                        \"HOLDING\": \"HOLDING\",\n                        \"TAX\": \"TAX\"\n                    },\n                },\n                'openapi_types': {\n                    'account_type':\n                        (str,),\n                    'currency':\n                        (str,),\n                    'at_timestamp':\n                        (datetime,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'account_type': 'account_type',\n                    'currency': 'currency',\n                    'at_timestamp': 'at_timestamp',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'account_type': 'query',\n                    'currency': 'query',\n                    'at_timestamp': 'query',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n\n    def get_balance(\n        self,\n        account_type: Optional[str] = \"CASH\",\n        currency: Optional[str] = None,\n        at_timestamp: Optional[datetime] = None,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> Balance:\n        \"\"\"Retrieves balances for a business, default to CASH type  # noqa: E501\n\n        Retrieves balance for your business, defaults to CASH type  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_balance(currency, at_timestamp, for_user_id, account_type=\"CASH\", async_req=True)\n        >>> result = thread.get()\n\n\n        Keyword Args:\n            account_type (str): The selected balance type. [optional] if omitted the server will use the default value of \"CASH\"\n            currency (str): Currency for filter for customers with multi currency accounts. [optional]\n            at_timestamp (datetime): The timestamp you want to use as the limit for balance retrieval. [optional]\n            for_user_id (str): The sub-account user-id that you want to make this transaction for. This header is only used if you have access to xenPlatform. See xenPlatform for more information. [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            Balance\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        if account_type is not None:\n            kwargs['account_type'] = account_type\n        if currency is not None:\n            kwargs['currency'] = currency\n        if at_timestamp is not None:\n            kwargs['at_timestamp'] = at_timestamp\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.get_balance_endpoint.call_with_http_info(**kwargs)\n\n",
    "uncovered_lines": [
      32,
      33,
      34,
      35,
      164,
      167,
      170,
      173,
      176,
      179,
      182,
      185,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/transaction_api.py",
    "code": "\"\"\"\n    Transaction Service V4 API\n\n    # Introduction This specification describes how to use the Transaction Service V4 API.   **Transaction Service** is the service that records the customer transactions and is responsible to calculate their balance.  All products that move customer money around whether it is money-in, money-out, or transfer will interact with the Transaction Service on its flow. Transaction Service is the source of truth of Xendit and Customer regarding how much money that customer has that is stored in Xendit. Transaction Service is the source that is used for both our internal and customer financial reconciliation. Internally, the Transaction Service data structure is similar to how double-entry accounting works.  ## How Xendit teams/services do integrate with Transaction Service V4   **Channel product team/service** They interact with the Transaction Service when they want to record the transactions. This transaction can be money-in (balance added), money-out (balance deducted), transfer, refund/void/reversal, or other kind of transaction that affects customer balance. Product team also interacts with the Transaction Service for getting information about the transaction or balance.  **Billing/Fee team/service** They interact with Transaction Service either as the dependency of Transaction Service for getting the correct fee calculation/settings. Or using Transaction Service for getting the transaction/fee information to calculate the bill for the customer.  **NUX team/service** They interact with the Transaction Service to set up the customer ledger_account that is used to record their transactions.  **Finance team/service** They interact with the Transaction Service to get the transaction and balance data for each customer to do reconciliation.  **Dashboard/API team/service** They interact with the Transaction Service as a proxy to show the data to the Customer.  ## Prerequisites  Before staring to use **Transaction Service API** you need to complete a few things: 1. Find out **Base URL** for the API. Every endpoint definition in this document contains list of available servers (local, staging, production) 2. Set up ledger accounts using business id and currency. **Ledger Account** represents the account of the customer that will be used to associate with ledger lines. Each business may have at least 1 ledger account group (a group consists of a few accounts of types such as cash, liability, holding), and the money movement of their ledger will revolve around those ledger accounts. **Ledger Lines** that show a debit or credit transaction for a ledger account. Were using the double-entry principle in accounting where we should post 2 lines every time we make a transaction, 1 to debit an account and 1 to credit another account. See how to call <a href=\\\"#operation/setupLedgerAccounts\\\">Create cash, liability, holding, and tax account for a business (api/ledger-accounts/setup)</a> section of this document 3. To be able to create payments with fee/VAT the Product rate settings and VAT rate settings should be created using Transaction Fee Service. See <a href=\\\"https://docs.google.com/document/d/1HrrA4GhWD1DaJS5dn0dh9VyMhLR6TOUMW1qhRUZ9d_k/edit?pli=1#heading=h.518me3lwf8rb\\\">Fee Service Documentation</a> for details about how to create Product/VAT rate settings.   ## Transaction flows  To integrate with the Transaction Service you should decide what types of transaction flows your integration will be using. Transaction flow is set by the transaction `type` during transaction creation  1. Money In flows     1. Payment from credit card           `type: CREDIT_CARD_PAYMENT`           3. Payment from other sources without fee/VAT           `type: DEPOSIT, FOREX_DEPOSIT, ISSUING_FUNDING_REFUND, BNPL_PARTNER_SETTLEMENT_CREDIT, PROMO_FEE_CASHBACK, PROMO_VAT_CASHBACK, BATCH_VA_PAYMENT`           4. Payment from other sources with fee/VAT           `type: VA_PAYMENT, IM_ESCROW_VA_PAYMENT, IM_DEPOSIT, RO_PAYMENT, EWALLET_PAYMENT, CARDLESS_CREDIT_PAYMENT, IM_REMITTANCE_VA_PAYMENT, PAYLATER_PAYMENT, INVOICE, QR_CODE_PAYMENT, DIRECT_DEBIT_PAYMENT, DIRECT_BANK_TRANSFER, ACH_PAYMENT, CRYPTO_PAYMENT`           5. Billing deposit from cash           `type: BILLING_DEPOSIT`           6. Billing deposit from other sources           `type: BILLING_DIRECT_DEPOSIT, BILLING_VA_DIRECT_DEPOSIT`       2. Money out flows     1. Instant payment           `type: simple money out types`              `status: COMPLETED`           2. Simple payment without fee/VAT           `type: CHARGEBACK_DEDUCTION, FRAUD_DEDUCTION, LOAN_REPAYMENT, FOREX_DEDUCTION, BNPL_PARTNER_SETTLEMENT_DEBIT, WITHDRAWAL`       3. Simple payment with fee/VAT           `type: ISSUING_FUNDING, BATCH_DISBURSEMENT, CASH_DISBURSEMENT, DISBURSEMENT, REMITTANCE, REMITTANCE_PAYOUT, TAX_DISBURSEMENT`           4. Billing withdraw to cash           `type: BILLING_WITHDRAWAL`           4. Billing withdraw to other destinations           `type: BILL_PAYMENT`       3. Reversal flow      Some of transactions could be reversed. See <a href=\\\"#section/Introduction/Reversible-non-reversible-transaction-types\\\">Reversible / non reversible transaction types</a> section of this document. To reverse transaction you should call <a href=\\\"#operation/updateTransaction\\\">Update transaction (/api/transactions/:id)</a>  endpoint with the transaction status `REVERSED`.    4. Void/Cancellation Flow      Transaction in the `PENDING_SETTLEMENT` status could be canceled. To do that you should call <a href=\\\"#operation/updateTransaction\\\">Update transaction (/api/transactions/:id)</a>  endpoint with the transaction status `VOIDED`.       5. Switcher flow      Switchers are transactions that do not affect the customer balance. These are transactions that goes directly to the customers account and simply passes through Xendit. Therefore, it will not impact the customer balance and we will only charge Fee and VAT. To create switcher flow you should set `is_switcher_payment` field to `true`.       ## Instant/non instant settlement  Transactions can be performed instantly (instant settlement) or with delay (non instant settlement).  Some of the transaction types are only instantly processed, some of them support both instant and non instant settlement and some of them have only non instant settlement. If settlement is instant than balance will be changed instantly. In opposite case the transaction status has to be set into PENDING_SETTLEMENT and settlement date should be provided.   1. Instant settlement Money In transaction types      `DEPOSIT, BATCH_VA_PAYMENT, FOREX_DEPOSIT, IM_DEPOSIT, CARDLESS_CREDIT_PAYMENT, ISSUING_FUNDING_REFUND, BNPL_PARTNER_SETTLEMENT_CREDIT, PROMO_FEE_CASHBACK, PROMO_VAT_CASHBACK, REMITTANCE_VA_PAYMENT_CLAIM`    2. Both instant and non instant Money In transaction types      `DIRECT_DEBIT_PAYMENT, DIRECT_BANK_TRANSFER, ACH_PAYMENT, RO_PAYMENT, EWALLET_PAYMENT, QR_CODE_PAYMENT, VA_PAYMENT, INVOICE, PAYLATER_PAYMENT`  3. Non Instant settlement Money In transaction types      `CREDIT_CARD_PAYMENT`    4. Instant settlement Money Out transaction types      `LOAN_REPAYMENT, FOREX_DEDUCTION, BILL_PAYMENT, ISSUING_FUNDING, BNPL_PARTNER_SETTLEMENT_DEBIT, FRAUD_DEDUCTION`  5. Both instant and non instant settlement supported Money Out transaction types      `CHARGEBACK_DEDUCTION`  6. Non Instant settlement Money Out transaction types      All other money out types are non instant settlement  ## Reversible / non reversible transaction types  Some transactions can be reversed. Here are the list of transaction types that could be reversed:   `CASH_DISBURSEMENT, DISBURSEMENT, BATCH_DISBURSEMENT, REMITTANCE, REMITTANCE_PAYOUT, TAX_DISBURSEMENT, WITHDRAWAL, DEPOSIT, FOREX_DEPOSIT, FOREX_DEDUCTION, VA_PAYMENT, BATCH_VA_PAYMENT, IM_REMITTANCE_VA_PAYMENT, IM_ESCROW_VA_PAYMENT, IM_DEPOSIT, REMITTANCE_VA_PAYMENT, REMITTANCE_VA_PAYMENT_CLAIM, RO_PAYMENT, CARDLESS_CREDIT_PAYMENT, PAYLATER_PAYMENT, INVOICE, QR_CODE_PAYMENT, CREDIT_CARD_PAYMENT, EWALLET_PAYMENT, DIRECT_DEBIT_PAYMENT, DIRECT_BANK_TRANSFER, ACH_PAYMENT, CHARGEBACK_DEDUCTION, FRAUD_DEDUCTION, LOAN_REPAYMENT, ISSUING_FUNDING, ISSUING_FUNDING_REFUND, BNPL_PARTNER_SETTLEMENT_DEBIT, BNPL_PARTNER_SETTLEMENT_CREDIT, BILLING_DEPOSIT, BILLING_DIRECT_DEPOSIT, BILLING_VA_DIRECT_DEPOSIT, BILLING_WITHDRAWAL, BILL_PAYMENT, PROMO_FEE_CASHBACK, PROMO_VAT_CASHBACK`       ## How to create transaction  After you created or already have the `BUSINESS_CASH` ledger account ID (See <a href=\\\"#section/Introduction/Prerequisites\\\">Prerequisites</a> section) and you know what transaction flows are going to be used  you can create the new transaction using POST request to the  <a href=\\\"#operation/createTransaction\\\">Create a new transaction (/api/transactions)</a>  endpoint  ## How to update transaction  To update transaction you should do  PATCH request to the  <a href=\\\"#operation/updateTransaction\\\">Update transaction (/api/transactions/::id)</a>  endpoint     # noqa: E501\n\n    The version of the OpenAPI document: 5.4.0\n\"\"\"\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\n\nfrom xendit.api_client import ApiClient, Endpoint as _Endpoint\nfrom xendit.model_utils import (  # noqa: F401\n    check_allowed_values,\n    check_validations,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_and_convert_types\n)\nfrom typing import Optional, List # noqa: F401\n\nfrom xendit.balance_and_transaction.model import *  # noqa: F401,E501\n\nclass TransactionApi(object):\n    \"\"\"NOTE: This class is auto generated by the OpenAPI Generator.\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None):\n        if api_client is None:\n            api_client = ApiClient()\n        self.api_client = api_client\n        self.get_transaction_by_id_endpoint = _Endpoint(\n            settings={\n                'response_type': (TransactionResponse,),\n                'auth': [],\n                'endpoint_path': '/transactions/{id}',\n                'operation_id': 'get_transaction_by_id',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'id',\n                    'for_user_id',\n                ],\n                'required': [\n                    'id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                    'id',\n                ]\n            },\n            root_map={\n                'validations': {\n                    ('id',): {\n\n                        'regex': {\n                            'pattern': r'^txn_[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$',  # noqa: E501\n                        },\n                    },\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'id':\n                        (TransactionId,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'id': 'id',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'id': 'path',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.get_all_transactions_endpoint = _Endpoint(\n            settings={\n                'response_type': (TransactionsResponse,),\n                'auth': [],\n                'endpoint_path': '/transactions',\n                'operation_id': 'get_all_transactions',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'for_user_id',\n                    'types',\n                    'statuses',\n                    'channel_categories',\n                    'reference_id',\n                    'product_id',\n                    'account_identifier',\n                    'amount',\n                    'currency',\n                    'created',\n                    'updated',\n                    'limit',\n                    'after_id',\n                    'before_id',\n                ],\n                'required': [],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                    'limit',\n                    'after_id',\n                    'before_id',\n                ]\n            },\n            root_map={\n                'validations': {\n                    ('limit',): {\n\n                        'inclusive_maximum': 50,\n                    },\n                    ('after_id',): {\n\n                        'regex': {\n                            'pattern': r'^txn_[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$',  # noqa: E501\n                        },\n                    },\n                    ('before_id',): {\n\n                        'regex': {\n                            'pattern': r'^txn_[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$',  # noqa: E501\n                        },\n                    },\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'for_user_id':\n                        (str,),\n                    'types':\n                        ([TransactionTypes],),\n                    'statuses':\n                        ([TransactionStatuses],),\n                    'channel_categories':\n                        ([ChannelsCategories],),\n                    'reference_id':\n                        (str,),\n                    'product_id':\n                        (str,),\n                    'account_identifier':\n                        (str,),\n                    'amount':\n                        (float,),\n                    'currency':\n                        (Currency,),\n                    'created':\n                        (DateRangeFilter,),\n                    'updated':\n                        (DateRangeFilter,),\n                    'limit':\n                        (float,),\n                    'after_id':\n                        (TransactionId,),\n                    'before_id':\n                        (TransactionId,),\n                },\n                'attribute_map': {\n                    'for_user_id': 'for-user-id',\n                    'types': 'types',\n                    'statuses': 'statuses',\n                    'channel_categories': 'channel_categories',\n                    'reference_id': 'reference_id',\n                    'product_id': 'product_id',\n                    'account_identifier': 'account_identifier',\n                    'amount': 'amount',\n                    'currency': 'currency',\n                    'created': 'created',\n                    'updated': 'updated',\n                    'limit': 'limit',\n                    'after_id': 'after_id',\n                    'before_id': 'before_id',\n                },\n                'location_map': {\n                    'for_user_id': 'header',\n                    'types': 'query',\n                    'statuses': 'query',\n                    'channel_categories': 'query',\n                    'reference_id': 'query',\n                    'product_id': 'query',\n                    'account_identifier': 'query',\n                    'amount': 'query',\n                    'currency': 'query',\n                    'created': 'query',\n                    'updated': 'query',\n                    'limit': 'query',\n                    'after_id': 'query',\n                    'before_id': 'query',\n                },\n                'collection_format_map': {\n                    'types': 'multi',\n                    'statuses': 'multi',\n                    'channel_categories': 'multi',\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n\n    def get_transaction_by_id(\n        self,\n        id: TransactionId,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> TransactionResponse:\n        \"\"\"Get a transaction based on its id  # noqa: E501\n\n        Get single specific transaction by transaction id.  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_transaction_by_id(id, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            id (TransactionId):\n\n        Keyword Args:\n            for_user_id (str): The sub-account user-id that you want to make this transaction for. This header is only used if you have access to xenPlatform. See xenPlatform for more information. [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            TransactionResponse\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['id'] = id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.get_transaction_by_id_endpoint.call_with_http_info(**kwargs)\n\n    def get_all_transactions(\n        self,\n        for_user_id: Optional[str] = None,\n        types: Optional[List[TransactionTypes]] = None,\n        statuses: Optional[List[TransactionStatuses]] = None,\n        channel_categories: Optional[List[ChannelsCategories]] = None,\n        reference_id: Optional[str] = None,\n        product_id: Optional[str] = None,\n        account_identifier: Optional[str] = None,\n        amount: Optional[float] = None,\n        currency: Optional[Currency] = None,\n        created: Optional[DateRangeFilter] = None,\n        updated: Optional[DateRangeFilter] = None,\n        limit: Optional[float] = 10,\n        after_id: Optional[TransactionId] = None,\n        before_id: Optional[TransactionId] = None,\n        **kwargs\n    ) -> TransactionsResponse:\n        \"\"\"Get a list of transactions  # noqa: E501\n\n        Get a list of all transactions based on filter and search parameters.  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_all_transactions(for_user_id, types, statuses, channel_categories, reference_id, product_id, account_identifier, amount, currency, created, updated, after_id, before_id, limit=10, async_req=True)\n        >>> result = thread.get()\n\n\n        Keyword Args:\n            for_user_id (str): The sub-account user-id that you want to make this transaction for. This header is only used if you have access to xenPlatform. See xenPlatform for more information. [optional]\n            types ([TransactionTypes]): Transaction types that will be included in the result. Default is to include all transaction types. [optional]\n            statuses ([TransactionStatuses]): Status of the transaction. Default is to include all status.. [optional]\n            channel_categories ([ChannelsCategories]): Payment channels in which the transaction is carried out. Default is to include all channels.. [optional]\n            reference_id (str): To filter the result for transactions with matching reference given (case sensitive). [optional]\n            product_id (str): To filter the result for transactions with matching product_id (a.k.a payment_id) given (case sensitive). [optional]\n            account_identifier (str): Account identifier of transaction. The format will be different from each channel. For example, on `BANK` channel it will be account number and on `CARD` it will be masked card number.. [optional]\n            amount (float): Specific transaction amount to search for. [optional]\n            currency (Currency): [optional]\n            created (DateRangeFilter): Filter time of transaction by created date. If not specified will list all dates.. [optional]\n            updated (DateRangeFilter): Filter time of transaction by updated date. If not specified will list all dates.. [optional]\n            limit (float): number of items in the result per page. Another name for \\\"results_per_page\\\". [optional] if omitted the server will use the default value of 10\n            after_id (TransactionId): [optional]\n            before_id (TransactionId): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            TransactionsResponse\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if types is not None:\n            kwargs['types'] = types\n        if statuses is not None:\n            kwargs['statuses'] = statuses\n        if channel_categories is not None:\n            kwargs['channel_categories'] = channel_categories\n        if reference_id is not None:\n            kwargs['reference_id'] = reference_id\n        if product_id is not None:\n            kwargs['product_id'] = product_id\n        if account_identifier is not None:\n            kwargs['account_identifier'] = account_identifier\n        if amount is not None:\n            kwargs['amount'] = amount\n        if currency is not None:\n            kwargs['currency'] = currency\n        if created is not None:\n            kwargs['created'] = created\n        if updated is not None:\n            kwargs['updated'] = updated\n        if limit is not None:\n            kwargs['limit'] = limit\n        if after_id is not None:\n            kwargs['after_id'] = after_id\n        if before_id is not None:\n            kwargs['before_id'] = before_id\n        return self.get_all_transactions_endpoint.call_with_http_info(**kwargs)\n\n",
    "uncovered_lines": [
      32,
      33,
      34,
      35,
      96,
      287,
      290,
      293,
      296,
      299,
      302,
      305,
      308,
      310,
      311,
      312,
      313,
      314,
      315,
      396,
      399,
      402,
      405,
      408,
      411,
      414,
      417,
      419,
      420,
      421,
      422,
      423,
      424,
      425,
      426,
      427,
      428,
      429,
      430,
      431,
      432,
      433,
      434,
      435,
      436,
      437,
      438,
      439,
      440,
      441,
      442,
      443,
      444,
      445,
      446,
      447,
      448,
      449
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/balance.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass Balance(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'balance': (float,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'balance': 'balance',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, balance, *args, **kwargs):  # noqa: E501\n        \"\"\"Balance - a model defined in OpenAPI\n\n        Args:\n            balance (float):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.balance = balance\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        balance: float,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Balance - a model defined in OpenAPI\n\n        Args:\n            balance (float):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.balance = balance\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      87,
      140,
      141,
      142,
      143,
      144,
      146,
      148,
      149,
      150,
      151,
      152,
      153,
      155,
      164,
      165,
      166,
      167,
      168,
      169,
      171,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      271,
      272,
      273,
      274
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/channels_categories.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ChannelsCategories(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BANK': \"BANK\",\n            'CARDLESS_CREDIT': \"CARDLESS_CREDIT\",\n            'PAYLATER': \"PAYLATER\",\n            'CARDS': \"CARDS\",\n            'CASH': \"CASH\",\n            'DIRECT_DEBIT': \"DIRECT_DEBIT\",\n            'EWALLET': \"EWALLET\",\n            'INVOICE': \"INVOICE\",\n            'QR_CODE': \"QR_CODE\",\n            'RETAIL_OUTLET': \"RETAIL_OUTLET\",\n            'VIRTUAL_ACCOUNT': \"VIRTUAL_ACCOUNT\",\n            'XENPLATFORM': \"XENPLATFORM\",\n            'DIRECT_BANK_TRANSFER': \"DIRECT_BANK_TRANSFER\",\n            'OTHER': \"OTHER\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"ChannelsCategories - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"BANK\", \"CARDLESS_CREDIT\", \"PAYLATER\", \"CARDS\", \"CASH\", \"DIRECT_DEBIT\", \"EWALLET\", \"INVOICE\", \"QR_CODE\", \"RETAIL_OUTLET\", \"VIRTUAL_ACCOUNT\", \"XENPLATFORM\", \"DIRECT_BANK_TRANSFER\", \"OTHER\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"BANK\", \"CARDLESS_CREDIT\", \"PAYLATER\", \"CARDS\", \"CASH\", \"DIRECT_DEBIT\", \"EWALLET\", \"INVOICE\", \"QR_CODE\", \"RETAIL_OUTLET\", \"VIRTUAL_ACCOUNT\", \"XENPLATFORM\", \"DIRECT_BANK_TRANSFER\", \"OTHER\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"ChannelsCategories - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"BANK\", \"CARDLESS_CREDIT\", \"PAYLATER\", \"CARDS\", \"CASH\", \"DIRECT_DEBIT\", \"EWALLET\", \"INVOICE\", \"QR_CODE\", \"RETAIL_OUTLET\", \"VIRTUAL_ACCOUNT\", \"XENPLATFORM\", \"DIRECT_BANK_TRANSFER\", \"OTHER\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"BANK\", \"CARDLESS_CREDIT\", \"PAYLATER\", \"CARDS\", \"CASH\", \"DIRECT_DEBIT\", \"EWALLET\", \"INVOICE\", \"QR_CODE\", \"RETAIL_OUTLET\", \"VIRTUAL_ACCOUNT\", \"XENPLATFORM\", \"DIRECT_BANK_TRANSFER\", \"OTHER\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      88,
      94,
      155,
      157,
      158,
      159,
      160,
      161,
      163,
      169,
      170,
      171,
      172,
      174,
      175,
      176,
      177,
      178,
      179,
      181,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      251,
      253,
      255,
      256,
      257,
      258,
      259,
      261,
      267,
      268,
      269,
      270,
      272,
      273,
      274,
      275,
      276,
      277,
      279,
      288,
      289,
      290,
      291,
      292,
      293,
      294,
      295,
      296,
      297,
      298,
      299,
      308
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/currency.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass Currency(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'IDR': \"IDR\",\n            'PHP': \"PHP\",\n            'USD': \"USD\",\n            'JPY': \"JPY\",\n            'VND': \"VND\",\n            'SGD': \"SGD\",\n            'AED': \"AED\",\n            'AFN': \"AFN\",\n            'ALL': \"ALL\",\n            'AMD': \"AMD\",\n            'ANG': \"ANG\",\n            'AOA': \"AOA\",\n            'ARS': \"ARS\",\n            'AUD': \"AUD\",\n            'AWG': \"AWG\",\n            'AZN': \"AZN\",\n            'BAM': \"BAM\",\n            'BBD': \"BBD\",\n            'BDT': \"BDT\",\n            'BGN': \"BGN\",\n            'BHD': \"BHD\",\n            'BIF': \"BIF\",\n            'BMD': \"BMD\",\n            'BND': \"BND\",\n            'BOB': \"BOB\",\n            'BRL': \"BRL\",\n            'BSD': \"BSD\",\n            'BTN': \"BTN\",\n            'BWP': \"BWP\",\n            'BYN': \"BYN\",\n            'BZD': \"BZD\",\n            'CAD': \"CAD\",\n            'CDF': \"CDF\",\n            'CHF': \"CHF\",\n            'CLP': \"CLP\",\n            'CNY': \"CNY\",\n            'COP': \"COP\",\n            'CRC': \"CRC\",\n            'CUC': \"CUC\",\n            'CUP': \"CUP\",\n            'CVE': \"CVE\",\n            'CZK': \"CZK\",\n            'DJF': \"DJF\",\n            'DKK': \"DKK\",\n            'DOP': \"DOP\",\n            'DZD': \"DZD\",\n            'EGP': \"EGP\",\n            'ERN': \"ERN\",\n            'ETB': \"ETB\",\n            'EUR': \"EUR\",\n            'FJD': \"FJD\",\n            'FKP': \"FKP\",\n            'GBP': \"GBP\",\n            'GEL': \"GEL\",\n            'GGP': \"GGP\",\n            'GHS': \"GHS\",\n            'GIP': \"GIP\",\n            'GMD': \"GMD\",\n            'GNF': \"GNF\",\n            'GTQ': \"GTQ\",\n            'GYD': \"GYD\",\n            'HKD': \"HKD\",\n            'HNL': \"HNL\",\n            'HRK': \"HRK\",\n            'HTG': \"HTG\",\n            'HUF': \"HUF\",\n            'ILS': \"ILS\",\n            'IMP': \"IMP\",\n            'INR': \"INR\",\n            'IQD': \"IQD\",\n            'IRR': \"IRR\",\n            'ISK': \"ISK\",\n            'JEP': \"JEP\",\n            'JMD': \"JMD\",\n            'JOD': \"JOD\",\n            'KES': \"KES\",\n            'KGS': \"KGS\",\n            'KHR': \"KHR\",\n            'KMF': \"KMF\",\n            'KPW': \"KPW\",\n            'KRW': \"KRW\",\n            'KWD': \"KWD\",\n            'KYD': \"KYD\",\n            'KZT': \"KZT\",\n            'LAK': \"LAK\",\n            'LBP': \"LBP\",\n            'LKR': \"LKR\",\n            'LRD': \"LRD\",\n            'LSL': \"LSL\",\n            'LYD': \"LYD\",\n            'MAD': \"MAD\",\n            'MDL': \"MDL\",\n            'MGA': \"MGA\",\n            'MKD': \"MKD\",\n            'MMK': \"MMK\",\n            'MNT': \"MNT\",\n            'MOP': \"MOP\",\n            'MRU': \"MRU\",\n            'MUR': \"MUR\",\n            'MVR': \"MVR\",\n            'MWK': \"MWK\",\n            'MXN': \"MXN\",\n            'MYR': \"MYR\",\n            'MZN': \"MZN\",\n            'NAD': \"NAD\",\n            'NGN': \"NGN\",\n            'NIO': \"NIO\",\n            'NOK': \"NOK\",\n            'NPR': \"NPR\",\n            'NZD': \"NZD\",\n            'OMR': \"OMR\",\n            'PAB': \"PAB\",\n            'PEN': \"PEN\",\n            'PGK': \"PGK\",\n            'PKR': \"PKR\",\n            'PLN': \"PLN\",\n            'PYG': \"PYG\",\n            'QAR': \"QAR\",\n            'RON': \"RON\",\n            'RSD': \"RSD\",\n            'RUB': \"RUB\",\n            'RWF': \"RWF\",\n            'SAR': \"SAR\",\n            'SBD': \"SBD\",\n            'SCR': \"SCR\",\n            'SDG': \"SDG\",\n            'SEK': \"SEK\",\n            'SHP': \"SHP\",\n            'SLL': \"SLL\",\n            'SOS': \"SOS\",\n            'SPL': \"SPL\",\n            'SRD': \"SRD\",\n            'STN': \"STN\",\n            'SVC': \"SVC\",\n            'SYP': \"SYP\",\n            'SZL': \"SZL\",\n            'THB': \"THB\",\n            'TJS': \"TJS\",\n            'TMT': \"TMT\",\n            'TND': \"TND\",\n            'TOP': \"TOP\",\n            'TRY': \"TRY\",\n            'TTD': \"TTD\",\n            'TVD': \"TVD\",\n            'TWD': \"TWD\",\n            'TZS': \"TZS\",\n            'UAH': \"UAH\",\n            'UGX': \"UGX\",\n            'UYU': \"UYU\",\n            'UZS': \"UZS\",\n            'VEF': \"VEF\",\n            'VUV': \"VUV\",\n            'WST': \"WST\",\n            'XAF': \"XAF\",\n            'XCD': \"XCD\",\n            'XDR': \"XDR\",\n            'XOF': \"XOF\",\n            'XPF': \"XPF\",\n            'YER': \"YER\",\n            'ZAR': \"ZAR\",\n            'ZMW': \"ZMW\",\n            'ZWD': \"ZWD\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"Currency - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"IDR\", \"PHP\", \"USD\", \"JPY\", \"VND\", \"SGD\", \"AED\", \"AFN\", \"ALL\", \"AMD\", \"ANG\", \"AOA\", \"ARS\", \"AUD\", \"AWG\", \"AZN\", \"BAM\", \"BBD\", \"BDT\", \"BGN\", \"BHD\", \"BIF\", \"BMD\", \"BND\", \"BOB\", \"BRL\", \"BSD\", \"BTN\", \"BWP\", \"BYN\", \"BZD\", \"CAD\", \"CDF\", \"CHF\", \"CLP\", \"CNY\", \"COP\", \"CRC\", \"CUC\", \"CUP\", \"CVE\", \"CZK\", \"DJF\", \"DKK\", \"DOP\", \"DZD\", \"EGP\", \"ERN\", \"ETB\", \"EUR\", \"FJD\", \"FKP\", \"GBP\", \"GEL\", \"GGP\", \"GHS\", \"GIP\", \"GMD\", \"GNF\", \"GTQ\", \"GYD\", \"HKD\", \"HNL\", \"HRK\", \"HTG\", \"HUF\", \"ILS\", \"IMP\", \"INR\", \"IQD\", \"IRR\", \"ISK\", \"JEP\", \"JMD\", \"JOD\", \"KES\", \"KGS\", \"KHR\", \"KMF\", \"KPW\", \"KRW\", \"KWD\", \"KYD\", \"KZT\", \"LAK\", \"LBP\", \"LKR\", \"LRD\", \"LSL\", \"LYD\", \"MAD\", \"MDL\", \"MGA\", \"MKD\", \"MMK\", \"MNT\", \"MOP\", \"MRU\", \"MUR\", \"MVR\", \"MWK\", \"MXN\", \"MYR\", \"MZN\", \"NAD\", \"NGN\", \"NIO\", \"NOK\", \"NPR\", \"NZD\", \"OMR\", \"PAB\", \"PEN\", \"PGK\", \"PKR\", \"PLN\", \"PYG\", \"QAR\", \"RON\", \"RSD\", \"RUB\", \"RWF\", \"SAR\", \"SBD\", \"SCR\", \"SDG\", \"SEK\", \"SHP\", \"SLL\", \"SOS\", \"SPL\", \"SRD\", \"STN\", \"SVC\", \"SYP\", \"SZL\", \"THB\", \"TJS\", \"TMT\", \"TND\", \"TOP\", \"TRY\", \"TTD\", \"TVD\", \"TWD\", \"TZS\", \"UAH\", \"UGX\", \"UYU\", \"UZS\", \"VEF\", \"VUV\", \"WST\", \"XAF\", \"XCD\", \"XDR\", \"XOF\", \"XPF\", \"YER\", \"ZAR\", \"ZMW\", \"ZWD\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"IDR\", \"PHP\", \"USD\", \"JPY\", \"VND\", \"SGD\", \"AED\", \"AFN\", \"ALL\", \"AMD\", \"ANG\", \"AOA\", \"ARS\", \"AUD\", \"AWG\", \"AZN\", \"BAM\", \"BBD\", \"BDT\", \"BGN\", \"BHD\", \"BIF\", \"BMD\", \"BND\", \"BOB\", \"BRL\", \"BSD\", \"BTN\", \"BWP\", \"BYN\", \"BZD\", \"CAD\", \"CDF\", \"CHF\", \"CLP\", \"CNY\", \"COP\", \"CRC\", \"CUC\", \"CUP\", \"CVE\", \"CZK\", \"DJF\", \"DKK\", \"DOP\", \"DZD\", \"EGP\", \"ERN\", \"ETB\", \"EUR\", \"FJD\", \"FKP\", \"GBP\", \"GEL\", \"GGP\", \"GHS\", \"GIP\", \"GMD\", \"GNF\", \"GTQ\", \"GYD\", \"HKD\", \"HNL\", \"HRK\", \"HTG\", \"HUF\", \"ILS\", \"IMP\", \"INR\", \"IQD\", \"IRR\", \"ISK\", \"JEP\", \"JMD\", \"JOD\", \"KES\", \"KGS\", \"KHR\", \"KMF\", \"KPW\", \"KRW\", \"KWD\", \"KYD\", \"KZT\", \"LAK\", \"LBP\", \"LKR\", \"LRD\", \"LSL\", \"LYD\", \"MAD\", \"MDL\", \"MGA\", \"MKD\", \"MMK\", \"MNT\", \"MOP\", \"MRU\", \"MUR\", \"MVR\", \"MWK\", \"MXN\", \"MYR\", \"MZN\", \"NAD\", \"NGN\", \"NIO\", \"NOK\", \"NPR\", \"NZD\", \"OMR\", \"PAB\", \"PEN\", \"PGK\", \"PKR\", \"PLN\", \"PYG\", \"QAR\", \"RON\", \"RSD\", \"RUB\", \"RWF\", \"SAR\", \"SBD\", \"SCR\", \"SDG\", \"SEK\", \"SHP\", \"SLL\", \"SOS\", \"SPL\", \"SRD\", \"STN\", \"SVC\", \"SYP\", \"SZL\", \"THB\", \"TJS\", \"TMT\", \"TND\", \"TOP\", \"TRY\", \"TTD\", \"TVD\", \"TWD\", \"TZS\", \"UAH\", \"UGX\", \"UYU\", \"UZS\", \"VEF\", \"VUV\", \"WST\", \"XAF\", \"XCD\", \"XDR\", \"XOF\", \"XPF\", \"YER\", \"ZAR\", \"ZMW\", \"ZWD\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"Currency - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"IDR\", \"PHP\", \"USD\", \"JPY\", \"VND\", \"SGD\", \"AED\", \"AFN\", \"ALL\", \"AMD\", \"ANG\", \"AOA\", \"ARS\", \"AUD\", \"AWG\", \"AZN\", \"BAM\", \"BBD\", \"BDT\", \"BGN\", \"BHD\", \"BIF\", \"BMD\", \"BND\", \"BOB\", \"BRL\", \"BSD\", \"BTN\", \"BWP\", \"BYN\", \"BZD\", \"CAD\", \"CDF\", \"CHF\", \"CLP\", \"CNY\", \"COP\", \"CRC\", \"CUC\", \"CUP\", \"CVE\", \"CZK\", \"DJF\", \"DKK\", \"DOP\", \"DZD\", \"EGP\", \"ERN\", \"ETB\", \"EUR\", \"FJD\", \"FKP\", \"GBP\", \"GEL\", \"GGP\", \"GHS\", \"GIP\", \"GMD\", \"GNF\", \"GTQ\", \"GYD\", \"HKD\", \"HNL\", \"HRK\", \"HTG\", \"HUF\", \"ILS\", \"IMP\", \"INR\", \"IQD\", \"IRR\", \"ISK\", \"JEP\", \"JMD\", \"JOD\", \"KES\", \"KGS\", \"KHR\", \"KMF\", \"KPW\", \"KRW\", \"KWD\", \"KYD\", \"KZT\", \"LAK\", \"LBP\", \"LKR\", \"LRD\", \"LSL\", \"LYD\", \"MAD\", \"MDL\", \"MGA\", \"MKD\", \"MMK\", \"MNT\", \"MOP\", \"MRU\", \"MUR\", \"MVR\", \"MWK\", \"MXN\", \"MYR\", \"MZN\", \"NAD\", \"NGN\", \"NIO\", \"NOK\", \"NPR\", \"NZD\", \"OMR\", \"PAB\", \"PEN\", \"PGK\", \"PKR\", \"PLN\", \"PYG\", \"QAR\", \"RON\", \"RSD\", \"RUB\", \"RWF\", \"SAR\", \"SBD\", \"SCR\", \"SDG\", \"SEK\", \"SHP\", \"SLL\", \"SOS\", \"SPL\", \"SRD\", \"STN\", \"SVC\", \"SYP\", \"SZL\", \"THB\", \"TJS\", \"TMT\", \"TND\", \"TOP\", \"TRY\", \"TTD\", \"TVD\", \"TWD\", \"TZS\", \"UAH\", \"UGX\", \"UYU\", \"UZS\", \"VEF\", \"VUV\", \"WST\", \"XAF\", \"XCD\", \"XDR\", \"XOF\", \"XPF\", \"YER\", \"ZAR\", \"ZMW\", \"ZWD\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"IDR\", \"PHP\", \"USD\", \"JPY\", \"VND\", \"SGD\", \"AED\", \"AFN\", \"ALL\", \"AMD\", \"ANG\", \"AOA\", \"ARS\", \"AUD\", \"AWG\", \"AZN\", \"BAM\", \"BBD\", \"BDT\", \"BGN\", \"BHD\", \"BIF\", \"BMD\", \"BND\", \"BOB\", \"BRL\", \"BSD\", \"BTN\", \"BWP\", \"BYN\", \"BZD\", \"CAD\", \"CDF\", \"CHF\", \"CLP\", \"CNY\", \"COP\", \"CRC\", \"CUC\", \"CUP\", \"CVE\", \"CZK\", \"DJF\", \"DKK\", \"DOP\", \"DZD\", \"EGP\", \"ERN\", \"ETB\", \"EUR\", \"FJD\", \"FKP\", \"GBP\", \"GEL\", \"GGP\", \"GHS\", \"GIP\", \"GMD\", \"GNF\", \"GTQ\", \"GYD\", \"HKD\", \"HNL\", \"HRK\", \"HTG\", \"HUF\", \"ILS\", \"IMP\", \"INR\", \"IQD\", \"IRR\", \"ISK\", \"JEP\", \"JMD\", \"JOD\", \"KES\", \"KGS\", \"KHR\", \"KMF\", \"KPW\", \"KRW\", \"KWD\", \"KYD\", \"KZT\", \"LAK\", \"LBP\", \"LKR\", \"LRD\", \"LSL\", \"LYD\", \"MAD\", \"MDL\", \"MGA\", \"MKD\", \"MMK\", \"MNT\", \"MOP\", \"MRU\", \"MUR\", \"MVR\", \"MWK\", \"MXN\", \"MYR\", \"MZN\", \"NAD\", \"NGN\", \"NIO\", \"NOK\", \"NPR\", \"NZD\", \"OMR\", \"PAB\", \"PEN\", \"PGK\", \"PKR\", \"PLN\", \"PYG\", \"QAR\", \"RON\", \"RSD\", \"RUB\", \"RWF\", \"SAR\", \"SBD\", \"SCR\", \"SDG\", \"SEK\", \"SHP\", \"SLL\", \"SOS\", \"SPL\", \"SRD\", \"STN\", \"SVC\", \"SYP\", \"SZL\", \"THB\", \"TJS\", \"TMT\", \"TND\", \"TOP\", \"TRY\", \"TTD\", \"TVD\", \"TWD\", \"TZS\", \"UAH\", \"UGX\", \"UYU\", \"UZS\", \"VEF\", \"VUV\", \"WST\", \"XAF\", \"XCD\", \"XDR\", \"XOF\", \"XPF\", \"YER\", \"ZAR\", \"ZMW\", \"ZWD\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      236,
      242,
      303,
      305,
      306,
      307,
      308,
      309,
      311,
      317,
      318,
      319,
      320,
      322,
      323,
      324,
      325,
      326,
      327,
      329,
      338,
      339,
      340,
      341,
      342,
      343,
      344,
      345,
      346,
      399,
      401,
      403,
      404,
      405,
      406,
      407,
      409,
      415,
      416,
      417,
      418,
      420,
      421,
      422,
      423,
      424,
      425,
      427,
      436,
      437,
      438,
      439,
      440,
      441,
      442,
      443,
      444,
      445,
      446,
      447,
      456
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/date_range_filter.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DateRangeFilter(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'gte': (datetime, none_type),  # noqa: E501\n            'lte': (datetime, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'gte': 'gte',  # noqa: E501\n        'lte': 'lte',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DateRangeFilter - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            gte (datetime): Start time of transaction. If not specified will list all dates.. [optional]  # noqa: E501\n            lte (datetime): End time of transaction. If not specified will list all dates.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        gte: datetime | None = None,\n        lte: datetime | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DateRangeFilter - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            gte (datetime): Start time of transaction. If not specified will list all dates.. [optional]  # noqa: E501\n            lte (datetime): End time of transaction. If not specified will list all dates.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if gte is not None:\n            self.gte = gte\n        if lte is not None:\n            self.lte = lte\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/fee_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass FeeResponse(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('status',): {\n            'PENDING': \"PENDING\",\n            'COMPLETED': \"COMPLETED\",\n            'CANCELED': \"CANCELED\",\n            'REVERSED': \"REVERSED\",\n            'NOT_APPLICABLE': \"NOT_APPLICABLE\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'xendit_fee': (float,),  # noqa: E501\n            'value_added_tax': (float,),  # noqa: E501\n            'xendit_withholding_tax': (float, none_type),  # noqa: E501\n            'third_party_withholding_tax': (float, none_type),  # noqa: E501\n            'status': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'xendit_fee': 'xendit_fee',  # noqa: E501\n        'value_added_tax': 'value_added_tax',  # noqa: E501\n        'xendit_withholding_tax': 'xendit_withholding_tax',  # noqa: E501\n        'third_party_withholding_tax': 'third_party_withholding_tax',  # noqa: E501\n        'status': 'status',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, xendit_fee, value_added_tax, *args, **kwargs):  # noqa: E501\n        \"\"\"FeeResponse - a model defined in OpenAPI\n\n        Args:\n            xendit_fee (float): Amount of the Xendit fee for this transaction.\n            value_added_tax (float): Amount of the VAT for this transaction.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            xendit_withholding_tax (float): Amount of the Xendit Withholding Tax for this transaction if applicable. See [Tax Documentation](https://docs.xendit.co/fees-and-vat#vat) for more information.. [optional]  # noqa: E501\n            third_party_withholding_tax (float): Amount of the 3rd Party Withholding Tax for this transaction if applicable. 3rd party example: Bank . [optional]  # noqa: E501\n            status (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.xendit_fee = xendit_fee\n        self.value_added_tax = value_added_tax\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        xendit_fee: float,\n        value_added_tax: float,\n        xendit_withholding_tax: float | None = None,\n        third_party_withholding_tax: float | None = None,\n        status: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"FeeResponse - a model defined in OpenAPI\n\n        Args:\n            xendit_fee (float): Amount of the Xendit fee for this transaction.\n            value_added_tax (float): Amount of the VAT for this transaction.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            xendit_withholding_tax (float): Amount of the Xendit Withholding Tax for this transaction if applicable. See [Tax Documentation](https://docs.xendit.co/fees-and-vat#vat) for more information.. [optional]  # noqa: E501\n            third_party_withholding_tax (float): Amount of the 3rd Party Withholding Tax for this transaction if applicable. 3rd party example: Bank . [optional]  # noqa: E501\n            status (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.xendit_fee = xendit_fee\n        self.value_added_tax = value_added_tax\n        if xendit_withholding_tax is not None:\n            self.xendit_withholding_tax = xendit_withholding_tax\n        if third_party_withholding_tax is not None:\n            self.third_party_withholding_tax = third_party_withholding_tax\n        if status is not None:\n            self.status = status\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      74,
      88,
      98,
      159,
      160,
      161,
      162,
      163,
      165,
      167,
      168,
      169,
      170,
      171,
      172,
      174,
      183,
      184,
      185,
      186,
      187,
      188,
      190,
      191,
      192,
      193,
      198,
      199,
      200,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      276,
      285,
      286,
      287,
      288,
      289,
      290,
      292,
      293,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      301,
      306,
      307,
      308,
      309
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/link_item.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass LinkItem(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'href': (str,),  # noqa: E501\n            'rel': (str,),  # noqa: E501\n            'method': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'href': 'href',  # noqa: E501\n        'rel': 'rel',  # noqa: E501\n        'method': 'method',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, href, rel, method, *args, **kwargs):  # noqa: E501\n        \"\"\"LinkItem - a model defined in OpenAPI\n\n        Args:\n            href (str): URI of target, this will be to the next link.\n            rel (str): The relationship between source and target. The value will be `next`.\n            method (str): The HTTP method, the value will be `GET`.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.href = href\n        self.rel = rel\n        self.method = method\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        href: str,\n        rel: str,\n        method: str,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"LinkItem - a model defined in OpenAPI\n\n        Args:\n            href (str): URI of target, this will be to the next link.\n            rel (str): The relationship between source and target. The value will be `next`.\n            method (str): The HTTP method, the value will be `GET`.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.href = href\n        self.rel = rel\n        self.method = method\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      146,
      147,
      148,
      149,
      150,
      152,
      154,
      155,
      156,
      157,
      158,
      159,
      161,
      170,
      171,
      172,
      173,
      174,
      175,
      177,
      178,
      179,
      180,
      181,
      186,
      187,
      188,
      247,
      248,
      249,
      250,
      251,
      253,
      254,
      255,
      256,
      257,
      258,
      260,
      269,
      270,
      271,
      272,
      273,
      274,
      276,
      277,
      278,
      279,
      280,
      285,
      286,
      287,
      288
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/server_error.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ServerError(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'status_code': (float,),  # noqa: E501\n            'error': (str,),  # noqa: E501\n            'message': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'status_code': 'status_code',  # noqa: E501\n        'error': 'error',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, status_code, error, message, *args, **kwargs):  # noqa: E501\n        \"\"\"ServerError - a model defined in OpenAPI\n\n        Args:\n            status_code (float):\n            error (str):\n            message (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.status_code = status_code\n        self.error = error\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        status_code: float,\n        error: str,\n        message: str,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ServerError - a model defined in OpenAPI\n\n        Args:\n            status_code (float):\n            error (str):\n            message (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.status_code = status_code\n        self.error = error\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      146,
      147,
      148,
      149,
      150,
      152,
      154,
      155,
      156,
      157,
      158,
      159,
      161,
      170,
      171,
      172,
      173,
      174,
      175,
      177,
      178,
      179,
      180,
      181,
      186,
      187,
      188,
      247,
      248,
      249,
      250,
      251,
      253,
      254,
      255,
      256,
      257,
      258,
      260,
      269,
      270,
      271,
      272,
      273,
      274,
      276,
      277,
      278,
      279,
      280,
      285,
      286,
      287,
      288
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/transaction_id.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass TransactionId(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('value',): {\n            'regex': {\n                'pattern': r'',  # noqa: E501\n            },\n        },\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"TransactionId - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): The unique id of a transaction. It will have `txn_` as prefix.  # noqa: E501\n\n        Keyword Args:\n            value (str): The unique id of a transaction. It will have `txn_` as prefix.  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"TransactionId - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): The unique id of a transaction. It will have `txn_` as prefix.  # noqa: E501\n\n        Keyword Args:\n            value (str): The unique id of a transaction. It will have `txn_` as prefix.  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      76,
      82,
      143,
      145,
      146,
      147,
      148,
      149,
      151,
      157,
      158,
      159,
      160,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      239,
      241,
      243,
      244,
      245,
      246,
      247,
      249,
      255,
      256,
      257,
      258,
      260,
      261,
      262,
      263,
      264,
      265,
      267,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      293
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/transaction_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.balance_and_transaction.model.channels_categories import ChannelsCategories\nfrom xendit.balance_and_transaction.model.currency import Currency\nfrom xendit.balance_and_transaction.model.fee_response import FeeResponse\nfrom xendit.balance_and_transaction.model.transaction_id import TransactionId\nfrom xendit.balance_and_transaction.model.transaction_response_type import TransactionResponseType\nfrom xendit.balance_and_transaction.model.transaction_statuses import TransactionStatuses\nglobals()['ChannelsCategories'] = ChannelsCategories\nglobals()['Currency'] = Currency\nglobals()['FeeResponse'] = FeeResponse\nglobals()['TransactionId'] = TransactionId\nglobals()['TransactionResponseType'] = TransactionResponseType\nglobals()['TransactionStatuses'] = TransactionStatuses\n\ndef lazy_import():\n    pass\n\nclass TransactionResponse(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('cashflow',): {\n            'IN': \"MONEY_IN\",\n            'OUT': \"MONEY_OUT\",\n        },\n        ('settlement_status',): {\n            'None': None,\n            'PENDING': \"PENDING\",\n            'SETTLED': \"SETTLED\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'id': (TransactionId,),  # noqa: E501\n            'product_id': (str,),  # noqa: E501\n            'type': (TransactionResponseType,),  # noqa: E501\n            'status': (TransactionStatuses,),  # noqa: E501\n            'channel_category': (ChannelsCategories,),  # noqa: E501\n            'channel_code': (str, none_type,),  # noqa: E501\n            'account_identifier': (str, none_type,),  # noqa: E501\n            'reference_id': (str,),  # noqa: E501\n            'currency': (Currency,),  # noqa: E501\n            'amount': (float,),  # noqa: E501\n            'cashflow': (str,),  # noqa: E501\n            'business_id': (str,),  # noqa: E501\n            'fee': (FeeResponse,),  # noqa: E501\n            'created': (datetime,),  # noqa: E501\n            'updated': (datetime,),  # noqa: E501\n            'settlement_status': (str, none_type, none_type),  # noqa: E501\n            'estimated_settlement_time': (datetime, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'id': 'id',  # noqa: E501\n        'product_id': 'product_id',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'channel_category': 'channel_category',  # noqa: E501\n        'channel_code': 'channel_code',  # noqa: E501\n        'account_identifier': 'account_identifier',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'cashflow': 'cashflow',  # noqa: E501\n        'business_id': 'business_id',  # noqa: E501\n        'fee': 'fee',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'settlement_status': 'settlement_status',  # noqa: E501\n        'estimated_settlement_time': 'estimated_settlement_time',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, id, product_id, type, status, channel_category, channel_code, account_identifier, reference_id, currency, amount, cashflow, business_id, fee, created, updated, *args, **kwargs):  # noqa: E501\n        \"\"\"TransactionResponse - a model defined in OpenAPI\n\n        Args:\n            id (TransactionId):\n            product_id (str): The product_id of the transaction. Product id will have a different prefix for each product. You can use this id to match the transaction from this API to each product API.\n            type (TransactionResponseType):\n            status (TransactionStatuses):\n            channel_category (ChannelsCategories):\n            channel_code (str, none_type): The channel of the transaction that is used. See [channel codes](https://docs.xendit.co/xendisburse/channel-codes) for the list of available per channel categories.\n            account_identifier (str, none_type): Account identifier of transaction. The format will be different from each channel.\n            reference_id (str): customer supplied reference/external_id\n            currency (Currency):\n            amount (float): The transaction amount. The number of decimal places will be different for each currency according to ISO 4217.\n            cashflow (str): Representing whether the transaction is money in or money out For transfer, the transfer out side it will shows up as money out and on transfer in side in will shows up as money-in. Available values are `MONEY_IN` for money in and `MONEY_OUT` for money out.\n            business_id (str): The id of business where this transaction belong to\n            fee (FeeResponse):\n            created (datetime): Transaction created timestamp (UTC+0)\n            updated (datetime): Transaction updated timestamp (UTC+0)\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            settlement_status (str, none_type): The settlement status of the transaction. `PENDING` - Transaction amount has not been settled to merchant's balance. `SETTLED` - Transaction has been settled to merchant's balance. [optional]  # noqa: E501\n            estimated_settlement_time (datetime, none_type): Estimated settlement time will only apply to money-in transactions. For money-out transaction, the value will be `NULL`. Estimated settlement time in which transaction amount will be settled to merchant's balance.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.product_id = product_id\n        self.type = type\n        self.status = status\n        self.channel_category = channel_category\n        self.channel_code = channel_code\n        self.account_identifier = account_identifier\n        self.reference_id = reference_id\n        self.currency = currency\n        self.amount = amount\n        self.cashflow = cashflow\n        self.business_id = business_id\n        self.fee = fee\n        self.created = created\n        self.updated = updated\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        id: str,\n        product_id: str,\n        type: TransactionResponseType,\n        status: TransactionStatuses,\n        channel_category: ChannelsCategories,\n        channel_code: str | None,\n        account_identifier: str | None,\n        reference_id: str,\n        currency: Currency,\n        amount: float,\n        cashflow: str,\n        business_id: str,\n        fee: FeeResponse,\n        created: datetime,\n        updated: datetime,\n        settlement_status: str | None = None,\n        estimated_settlement_time: datetime | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"TransactionResponse - a model defined in OpenAPI\n\n        Args:\n            id (TransactionId):\n            product_id (str): The product_id of the transaction. Product id will have a different prefix for each product. You can use this id to match the transaction from this API to each product API.\n            type (TransactionResponseType):\n            status (TransactionStatuses):\n            channel_category (ChannelsCategories):\n            channel_code (str, none_type): The channel of the transaction that is used. See [channel codes](https://docs.xendit.co/xendisburse/channel-codes) for the list of available per channel categories.\n            account_identifier (str, none_type): Account identifier of transaction. The format will be different from each channel.\n            reference_id (str): customer supplied reference/external_id\n            currency (Currency):\n            amount (float): The transaction amount. The number of decimal places will be different for each currency according to ISO 4217.\n            cashflow (str): Representing whether the transaction is money in or money out For transfer, the transfer out side it will shows up as money out and on transfer in side in will shows up as money-in. Available values are `MONEY_IN` for money in and `MONEY_OUT` for money out.\n            business_id (str): The id of business where this transaction belong to\n            fee (FeeResponse):\n            created (datetime): Transaction created timestamp (UTC+0)\n            updated (datetime): Transaction updated timestamp (UTC+0)\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            settlement_status (str, none_type): The settlement status of the transaction. `PENDING` - Transaction amount has not been settled to merchant's balance. `SETTLED` - Transaction has been settled to merchant's balance. [optional]  # noqa: E501\n            estimated_settlement_time (datetime, none_type): Estimated settlement time will only apply to money-in transactions. For money-out transaction, the value will be `NULL`. Estimated settlement time in which transaction amount will be settled to merchant's balance.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.product_id = product_id\n        self.type = type\n        self.status = status\n        self.channel_category = channel_category\n        self.channel_code = channel_code\n        self.account_identifier = account_identifier\n        self.reference_id = reference_id\n        self.currency = currency\n        self.amount = amount\n        self.cashflow = cashflow\n        self.business_id = business_id\n        self.fee = fee\n        self.created = created\n        self.updated = updated\n        if settlement_status is not None:\n            self.settlement_status = settlement_status\n        if estimated_settlement_time is not None:\n            self.estimated_settlement_time = estimated_settlement_time\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      88,
      89,
      103,
      104,
      126,
      211,
      212,
      213,
      214,
      215,
      217,
      219,
      220,
      221,
      222,
      223,
      224,
      226,
      235,
      236,
      237,
      238,
      239,
      240,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255,
      256,
      257,
      258,
      263,
      264,
      265,
      352,
      353,
      354,
      355,
      356,
      358,
      359,
      360,
      361,
      362,
      363,
      365,
      374,
      375,
      376,
      377,
      378,
      379,
      381,
      382,
      383,
      384,
      385,
      386,
      387,
      388,
      389,
      390,
      391,
      392,
      393,
      394,
      395,
      396,
      397,
      398,
      399,
      400,
      401,
      406,
      407,
      408,
      409
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/transaction_response_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.balance_and_transaction.model.transaction_types import TransactionTypes\nglobals()['TransactionTypes'] = TransactionTypes\n\ndef lazy_import():\n    pass\n\nclass TransactionResponseType(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"TransactionResponseType - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"TransactionResponseType - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n              TransactionTypes,\n              str,\n          ],\n          'allOf': [\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      90,
      137,
      138,
      139,
      140,
      141,
      143,
      145,
      146,
      147,
      148,
      149,
      150,
      152,
      161,
      162,
      163,
      164,
      165,
      166,
      168,
      175,
      177,
      178,
      179,
      180,
      182,
      183,
      188,
      189,
      191,
      242,
      243,
      244,
      245,
      246,
      248,
      249,
      250,
      251,
      252,
      253,
      255,
      264,
      265,
      266,
      267,
      268,
      269,
      271,
      278,
      280,
      281,
      282,
      283,
      285,
      286,
      291,
      292,
      293,
      294,
      306,
      307
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/transaction_statuses.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass TransactionStatuses(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'SUCCESS': \"SUCCESS\",\n            'PENDING': \"PENDING\",\n            'FAILED': \"FAILED\",\n            'REVERSED': \"REVERSED\",\n            'VOIDED': \"VOIDED\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"TransactionStatuses - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"SUCCESS\", \"PENDING\", \"FAILED\", \"REVERSED\", \"VOIDED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"SUCCESS\", \"PENDING\", \"FAILED\", \"REVERSED\", \"VOIDED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"TransactionStatuses - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"SUCCESS\", \"PENDING\", \"FAILED\", \"REVERSED\", \"VOIDED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"SUCCESS\", \"PENDING\", \"FAILED\", \"REVERSED\", \"VOIDED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      79,
      85,
      146,
      148,
      149,
      150,
      151,
      152,
      154,
      160,
      161,
      162,
      163,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      242,
      244,
      246,
      247,
      248,
      249,
      250,
      252,
      258,
      259,
      260,
      261,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      299
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/transaction_types.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass TransactionTypes(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BATCH_DISBURSEMENT': \"BATCH_DISBURSEMENT\",\n            'DISBURSEMENT': \"DISBURSEMENT\",\n            'PAYMENT': \"PAYMENT\",\n            'REMITTANCE': \"REMITTANCE\",\n            'REMITTANCE_PAYOUT': \"REMITTANCE_PAYOUT\",\n            'REMITTANCE_COLLECTION': \"REMITTANCE_COLLECTION\",\n            'TRANSFER': \"TRANSFER\",\n            'PLATFORM_FEE': \"PLATFORM_FEE\",\n            'REFUND': \"REFUND\",\n            'CASHBACK': \"CASHBACK\",\n            'TOPUP': \"TOPUP\",\n            'WITHDRAWAL': \"WITHDRAWAL\",\n            'OTHER': \"OTHER\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"TransactionTypes - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"BATCH_DISBURSEMENT\", \"DISBURSEMENT\", \"PAYMENT\", \"REMITTANCE\", \"REMITTANCE_PAYOUT\", \"REMITTANCE_COLLECTION\", \"TRANSFER\", \"PLATFORM_FEE\", \"REFUND\", \"CASHBACK\", \"TOPUP\", \"WITHDRAWAL\", \"OTHER\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"BATCH_DISBURSEMENT\", \"DISBURSEMENT\", \"PAYMENT\", \"REMITTANCE\", \"REMITTANCE_PAYOUT\", \"REMITTANCE_COLLECTION\", \"TRANSFER\", \"PLATFORM_FEE\", \"REFUND\", \"CASHBACK\", \"TOPUP\", \"WITHDRAWAL\", \"OTHER\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"TransactionTypes - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"BATCH_DISBURSEMENT\", \"DISBURSEMENT\", \"PAYMENT\", \"REMITTANCE\", \"REMITTANCE_PAYOUT\", \"REMITTANCE_COLLECTION\", \"TRANSFER\", \"PLATFORM_FEE\", \"REFUND\", \"CASHBACK\", \"TOPUP\", \"WITHDRAWAL\", \"OTHER\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"BATCH_DISBURSEMENT\", \"DISBURSEMENT\", \"PAYMENT\", \"REMITTANCE\", \"REMITTANCE_PAYOUT\", \"REMITTANCE_COLLECTION\", \"TRANSFER\", \"PLATFORM_FEE\", \"REFUND\", \"CASHBACK\", \"TOPUP\", \"WITHDRAWAL\", \"OTHER\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      87,
      93,
      154,
      156,
      157,
      158,
      159,
      160,
      162,
      168,
      169,
      170,
      171,
      173,
      174,
      175,
      176,
      177,
      178,
      180,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      250,
      252,
      254,
      255,
      256,
      257,
      258,
      260,
      266,
      267,
      268,
      269,
      271,
      272,
      273,
      274,
      275,
      276,
      278,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      294,
      295,
      296,
      297,
      298,
      307
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/transactions_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.balance_and_transaction.model.link_item import LinkItem\nfrom xendit.balance_and_transaction.model.transaction_response import TransactionResponse\nglobals()['LinkItem'] = LinkItem\nglobals()['TransactionResponse'] = TransactionResponse\n\ndef lazy_import():\n    pass\n\nclass TransactionsResponse(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'has_more': (bool,),  # noqa: E501\n            'data': ([TransactionResponse],),  # noqa: E501\n            'links': ([LinkItem], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'has_more': 'has_more',  # noqa: E501\n        'data': 'data',  # noqa: E501\n        'links': 'links',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, has_more, data, *args, **kwargs):  # noqa: E501\n        \"\"\"TransactionsResponse - a model defined in OpenAPI\n\n        Args:\n            has_more (bool): Indicates whether there are more items to be queried with `after_id` of the last item from the current result. Use the `links` to follow to the next result.\n            data ([TransactionResponse]):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            links ([LinkItem]): The links to the next page based on LinkItem if there is next result.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.has_more = has_more\n        self.data = data\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        has_more: bool,\n        data: list,\n        links: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"TransactionsResponse - a model defined in OpenAPI\n\n        Args:\n            has_more (bool): Indicates whether there are more items to be queried with `after_id` of the last item from the current result. Use the `links` to follow to the next result.\n            data ([TransactionResponse]):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            links ([LinkItem]): The links to the next page based on LinkItem if there is next result.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.has_more = has_more\n        self.data = data\n        if links is not None:\n            self.links = links\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      86,
      87,
      95,
      152,
      153,
      154,
      155,
      156,
      158,
      160,
      161,
      162,
      163,
      164,
      165,
      167,
      176,
      177,
      178,
      179,
      180,
      181,
      183,
      184,
      185,
      186,
      191,
      192,
      193,
      252,
      253,
      254,
      255,
      256,
      258,
      259,
      260,
      261,
      262,
      263,
      265,
      274,
      275,
      276,
      277,
      278,
      279,
      281,
      282,
      283,
      284,
      285,
      286,
      291,
      292,
      293,
      294
    ]
  },
  {
    "file_path": "xendit/balance_and_transaction/model/validation_error.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 5.4.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ValidationError(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'status_code': (float,),  # noqa: E501\n            'error': (str,),  # noqa: E501\n            'message': (str,),  # noqa: E501\n            'validation': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'status_code': 'status_code',  # noqa: E501\n        'error': 'error',  # noqa: E501\n        'message': 'message',  # noqa: E501\n        'validation': 'validation',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, status_code, error, message, *args, **kwargs):  # noqa: E501\n        \"\"\"ValidationError - a model defined in OpenAPI\n\n        Args:\n            status_code (float):\n            error (str):\n            message (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            validation ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.status_code = status_code\n        self.error = error\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        status_code: float,\n        error: str,\n        message: str,\n        validation: dict | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ValidationError - a model defined in OpenAPI\n\n        Args:\n            status_code (float):\n            error (str):\n            message (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            validation ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.status_code = status_code\n        self.error = error\n        self.message = message\n        if validation is not None:\n            self.validation = validation\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      90,
      149,
      150,
      151,
      152,
      153,
      155,
      157,
      158,
      159,
      160,
      161,
      162,
      164,
      173,
      174,
      175,
      176,
      177,
      178,
      180,
      181,
      182,
      183,
      184,
      189,
      190,
      191,
      252,
      253,
      254,
      255,
      256,
      258,
      259,
      260,
      261,
      262,
      263,
      265,
      274,
      275,
      276,
      277,
      278,
      279,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      292,
      293,
      294,
      295
    ]
  },
  {
    "file_path": "xendit/customer/customer_api.py",
    "code": "\"\"\"\n    XENDIT SDK openapi spec\n\n    XENDIT SDK openapi spec  # noqa: E501\n\n    The version of the OpenAPI document: 1.0.0\n\"\"\"\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\n\nfrom xendit.api_client import ApiClient, Endpoint as _Endpoint\nfrom xendit.model_utils import (  # noqa: F401\n    check_allowed_values,\n    check_validations,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_and_convert_types\n)\nfrom typing import Optional, List # noqa: F401\n\nfrom xendit.customer.model import *  # noqa: F401,E501\n\nclass CustomerApi(object):\n    \"\"\"NOTE: This class is auto generated by the OpenAPI Generator.\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None):\n        if api_client is None:\n            api_client = ApiClient()\n        self.api_client = api_client\n        self.create_customer_endpoint = _Endpoint(\n            settings={\n                'response_type': (Customer,),\n                'auth': [],\n                'endpoint_path': '/customers',\n                'operation_id': 'create_customer',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'idempotency_key',\n                    'for_user_id',\n                    'customer_request',\n                ],\n                'required': [],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'idempotency_key':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'customer_request':\n                        (CustomerRequest,),\n                },\n                'attribute_map': {\n                    'idempotency_key': 'idempotency-key',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'idempotency_key': 'header',\n                    'for_user_id': 'header',\n                    'customer_request': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n        self.get_customer_endpoint = _Endpoint(\n            settings={\n                'response_type': (Customer,),\n                'auth': [],\n                'endpoint_path': '/customers/{id}',\n                'operation_id': 'get_customer',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'id',\n                    'for_user_id',\n                ],\n                'required': [\n                    'id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'id': 'id',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'id': 'path',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.get_customer_by_reference_id_endpoint = _Endpoint(\n            settings={\n                'response_type': (GetCustomerByReferenceID200Response,),\n                'auth': [],\n                'endpoint_path': '/customers',\n                'operation_id': 'get_customer_by_reference_id',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'reference_id',\n                    'for_user_id',\n                ],\n                'required': [\n                    'reference_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                    'reference_id',\n                ]\n            },\n            root_map={\n                'validations': {\n                    ('reference_id',): {\n                        'max_length': 255,\n                    },\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'reference_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'reference_id': 'reference_id',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'reference_id': 'query',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.update_customer_endpoint = _Endpoint(\n            settings={\n                'response_type': (Customer,),\n                'auth': [],\n                'endpoint_path': '/customers/{id}',\n                'operation_id': 'update_customer',\n                'http_method': 'PATCH',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'id',\n                    'for_user_id',\n                    'patch_customer',\n                ],\n                'required': [\n                    'id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'patch_customer':\n                        (PatchCustomer,),\n                },\n                'attribute_map': {\n                    'id': 'id',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'id': 'path',\n                    'for_user_id': 'header',\n                    'patch_customer': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n\n    def create_customer(\n        self,\n        idempotency_key: Optional[str] = None,\n        for_user_id: Optional[str] = None,\n        customer_request: Optional[CustomerRequest] = None,\n        **kwargs\n    ) -> Customer:\n        \"\"\"Create Customer  # noqa: E501\n\n        Function to create a customer that you may use in your Invoice or Payment Requests. For detail explanations, see this link: https://developers.xendit.co/api-reference/#create-customer  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.create_customer(idempotency_key, for_user_id, customer_request, async_req=True)\n        >>> result = thread.get()\n\n\n        Keyword Args:\n            idempotency_key (str): A unique key to prevent processing duplicate requests.. [optional]\n            for_user_id (str): The sub-account user-id that you want to make this transaction for.. [optional]\n            customer_request (CustomerRequest): Request object for end customer object. [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            Customer\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        if idempotency_key is not None:\n            kwargs['idempotency_key'] = idempotency_key\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if customer_request is not None:\n            kwargs['customer_request'] = customer_request\n        return self.create_customer_endpoint.call_with_http_info(**kwargs)\n\n    def get_customer(\n        self,\n        id: str,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> Customer:\n        \"\"\"Get Customer By ID  # noqa: E501\n\n        Retrieves a single customer object For detail explanations, see this link: https://developers.xendit.co/api-reference/#get-customer  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_customer(id, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            id (str): End customer resource id\n\n        Keyword Args:\n            for_user_id (str): The sub-account user-id that you want to make this transaction for.. [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            Customer\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['id'] = id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.get_customer_endpoint.call_with_http_info(**kwargs)\n\n    def get_customer_by_reference_id(\n        self,\n        reference_id: str,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> GetCustomerByReferenceID200Response:\n        \"\"\"GET customers by reference id  # noqa: E501\n\n        Retrieves an array with a customer object that matches the provided reference_id - the identifier provided by you For detail explanations, see this link: https://developers.xendit.co/api-reference/#get-customer-by-reference-id  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_customer_by_reference_id(reference_id, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            reference_id (str): Merchant's reference of end customer\n\n        Keyword Args:\n            for_user_id (str): The sub-account user-id that you want to make this transaction for.. [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            GetCustomerByReferenceID200Response\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['reference_id'] = reference_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.get_customer_by_reference_id_endpoint.call_with_http_info(**kwargs)\n\n    def update_customer(\n        self,\n        id: str,\n        for_user_id: Optional[str] = None,\n        patch_customer: Optional[PatchCustomer] = None,\n        **kwargs\n    ) -> Customer:\n        \"\"\"Update End Customer Resource  # noqa: E501\n\n        Function to update an existing customer. For a detailed explanation For detail explanations, see this link: https://developers.xendit.co/api-reference/#update-customer  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.update_customer(id, for_user_id, patch_customer, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            id (str): End customer resource id\n\n        Keyword Args:\n            for_user_id (str): The sub-account user-id that you want to make this transaction for.. [optional]\n            patch_customer (PatchCustomer): Update Request for end customer object. [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            Customer\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['id'] = id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if patch_customer is not None:\n            kwargs['patch_customer'] = patch_customer\n        return self.update_customer_endpoint.call_with_http_info(**kwargs)\n\n",
    "uncovered_lines": [
      32,
      33,
      34,
      35,
      93,
      147,
      205,
      323,
      326,
      329,
      332,
      335,
      338,
      341,
      344,
      346,
      347,
      348,
      349,
      350,
      351,
      352,
      353,
      354,
      412,
      415,
      418,
      421,
      424,
      427,
      430,
      433,
      435,
      436,
      437,
      438,
      439,
      440,
      498,
      501,
      504,
      507,
      510,
      513,
      516,
      519,
      521,
      522,
      523,
      524,
      525,
      526,
      586,
      589,
      592,
      595,
      598,
      601,
      604,
      607,
      609,
      610,
      611,
      612,
      613,
      614,
      615,
      616
    ]
  },
  {
    "file_path": "xendit/customer/model/account_bank.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass AccountBank(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'account_number': (str, none_type),  # noqa: E501\n            'account_holder_name': (str, none_type, none_type),  # noqa: E501\n            'swift_code': (str, none_type, none_type),  # noqa: E501\n            'account_type': (str, none_type, none_type),  # noqa: E501\n            'account_details': (str, none_type, none_type),  # noqa: E501\n            'currency': (bool, date, datetime, dict, float, int, list, str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'account_number': 'account_number',  # noqa: E501\n        'account_holder_name': 'account_holder_name',  # noqa: E501\n        'swift_code': 'swift_code',  # noqa: E501\n        'account_type': 'account_type',  # noqa: E501\n        'account_details': 'account_details',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"AccountBank - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_number (str): Unique account identifier as per the bank records.. [optional]  # noqa: E501\n            account_holder_name (str, none_type): Name of account holder as per the bank records. Needs to match the registered account name exactly. .. [optional]  # noqa: E501\n            swift_code (str, none_type): The SWIFT code for international payments. [optional]  # noqa: E501\n            account_type (str, none_type): Free text account type, e.g., Savings, Transaction, Virtual Account.. [optional]  # noqa: E501\n            account_details (str, none_type): Potentially masked account detail, for display purposes only.. [optional]  # noqa: E501\n            currency (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        account_number: str | None = None,\n        account_holder_name: str | None = None,\n        swift_code: str | None = None,\n        account_type: str | None = None,\n        account_details: str | None = None,\n        currency: object | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"AccountBank - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_number (str): Unique account identifier as per the bank records.. [optional]  # noqa: E501\n            account_holder_name (str, none_type): Name of account holder as per the bank records. Needs to match the registered account name exactly. .. [optional]  # noqa: E501\n            swift_code (str, none_type): The SWIFT code for international payments. [optional]  # noqa: E501\n            account_type (str, none_type): Free text account type, e.g., Savings, Transaction, Virtual Account.. [optional]  # noqa: E501\n            account_details (str, none_type): Potentially masked account detail, for display purposes only.. [optional]  # noqa: E501\n            currency (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if account_number is not None:\n            self.account_number = account_number\n        if account_holder_name is not None:\n            self.account_holder_name = account_holder_name\n        if swift_code is not None:\n            self.swift_code = swift_code\n        if account_type is not None:\n            self.account_type = account_type\n        if account_details is not None:\n            self.account_details = account_details\n        if currency is not None:\n            self.currency = currency\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      92,
      153,
      154,
      155,
      156,
      157,
      159,
      161,
      162,
      163,
      164,
      165,
      166,
      168,
      177,
      178,
      179,
      180,
      181,
      182,
      184,
      185,
      190,
      191,
      192,
      255,
      256,
      257,
      258,
      259,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      277,
      278,
      279,
      280,
      281,
      282,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      294,
      295,
      296,
      297,
      302,
      303,
      304,
      305
    ]
  },
  {
    "file_path": "xendit/customer/model/account_card.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass AccountCard(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'token_id': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'token_id': 'token_id',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"AccountCard - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            token_id (str): The token id returned in tokenisation. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        token_id: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"AccountCard - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            token_id (str): The token id returned in tokenisation. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if token_id is not None:\n            self.token_id = token_id\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      87,
      138,
      139,
      140,
      141,
      142,
      144,
      146,
      147,
      148,
      149,
      150,
      151,
      153,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      170,
      175,
      176,
      177,
      230,
      231,
      232,
      233,
      234,
      236,
      237,
      238,
      239,
      240,
      241,
      243,
      252,
      253,
      254,
      255,
      256,
      257,
      259,
      260,
      261,
      262,
      267,
      268,
      269,
      270
    ]
  },
  {
    "file_path": "xendit/customer/model/account_ewallet.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass AccountEwallet(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'account_number': (str, none_type),  # noqa: E501\n            'account_holder_name': (str, none_type, none_type),  # noqa: E501\n            'currency': (bool, date, datetime, dict, float, int, list, str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'account_number': 'account_number',  # noqa: E501\n        'account_holder_name': 'account_holder_name',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"AccountEwallet - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_number (str): Unique account identifier as per the bank records.. [optional]  # noqa: E501\n            account_holder_name (str, none_type): Name of account holder as per the bank records. Needs to match the registered account name exactly.. [optional]  # noqa: E501\n            currency (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        account_number: str | None = None,\n        account_holder_name: str | None = None,\n        currency: object | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"AccountEwallet - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_number (str): Unique account identifier as per the bank records.. [optional]  # noqa: E501\n            account_holder_name (str, none_type): Name of account holder as per the bank records. Needs to match the registered account name exactly.. [optional]  # noqa: E501\n            currency (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if account_number is not None:\n            self.account_number = account_number\n        if account_holder_name is not None:\n            self.account_holder_name = account_holder_name\n        if currency is not None:\n            self.currency = currency\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      181,
      182,
      183,
      240,
      241,
      242,
      243,
      244,
      246,
      247,
      248,
      249,
      250,
      251,
      253,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      275,
      276,
      281,
      282,
      283,
      284
    ]
  },
  {
    "file_path": "xendit/customer/model/account_otc.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass AccountOTC(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'payment_code': (str, none_type),  # noqa: E501\n            'expires_at': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'payment_code': 'payment_code',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"AccountOTC - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_code (str): Complete fixed payment code (including prefix). [optional]  # noqa: E501\n            expires_at (str, none_type): YYYY-MM-DD string with expiry date for the payment code. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        payment_code: str | None = None,\n        expires_at: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"AccountOTC - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_code (str): Complete fixed payment code (including prefix). [optional]  # noqa: E501\n            expires_at (str, none_type): YYYY-MM-DD string with expiry date for the payment code. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if payment_code is not None:\n            self.payment_code = payment_code\n        if expires_at is not None:\n            self.expires_at = expires_at\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/customer/model/account_pay_later.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass AccountPayLater(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'account_id': (str, none_type),  # noqa: E501\n            'account_holder_name': (str, none_type, none_type),  # noqa: E501\n            'currency': (bool, date, datetime, dict, float, int, list, str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'account_id': 'account_id',  # noqa: E501\n        'account_holder_name': 'account_holder_name',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"AccountPayLater - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_id (str): Alphanumeric string identifying this account. Usually an email address or phone number.. [optional]  # noqa: E501\n            account_holder_name (str, none_type): Name of account holder as per the cardless credit account.. [optional]  # noqa: E501\n            currency (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        account_id: str | None = None,\n        account_holder_name: str | None = None,\n        currency: object | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"AccountPayLater - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_id (str): Alphanumeric string identifying this account. Usually an email address or phone number.. [optional]  # noqa: E501\n            account_holder_name (str, none_type): Name of account holder as per the cardless credit account.. [optional]  # noqa: E501\n            currency (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if account_id is not None:\n            self.account_id = account_id\n        if account_holder_name is not None:\n            self.account_holder_name = account_holder_name\n        if currency is not None:\n            self.currency = currency\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      181,
      182,
      183,
      240,
      241,
      242,
      243,
      244,
      246,
      247,
      248,
      249,
      250,
      251,
      253,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      275,
      276,
      281,
      282,
      283,
      284
    ]
  },
  {
    "file_path": "xendit/customer/model/account_qr_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass AccountQRCode(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'qr_string': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'qr_string': 'qr_string',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"AccountQRCode - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            qr_string (str): String representation of the QR Code image. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        qr_string: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"AccountQRCode - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            qr_string (str): String representation of the QR Code image. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if qr_string is not None:\n            self.qr_string = qr_string\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      87,
      138,
      139,
      140,
      141,
      142,
      144,
      146,
      147,
      148,
      149,
      150,
      151,
      153,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      170,
      175,
      176,
      177,
      230,
      231,
      232,
      233,
      234,
      236,
      237,
      238,
      239,
      240,
      241,
      243,
      252,
      253,
      254,
      255,
      256,
      257,
      259,
      260,
      261,
      262,
      267,
      268,
      269,
      270
    ]
  },
  {
    "file_path": "xendit/customer/model/address.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.address_status import AddressStatus\nglobals()['AddressStatus'] = AddressStatus\n\ndef lazy_import():\n    pass\n\nclass Address(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('category',): {\n            'max_length': 255,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'category': (str, none_type,),  # noqa: E501\n            'country': (bool, date, datetime, dict, float, int, list, str, none_type,),  # noqa: E501\n            'province_state': (str, none_type,),  # noqa: E501\n            'city': (str, none_type,),  # noqa: E501\n            'postal_code': (str, none_type,),  # noqa: E501\n            'street_line1': (str, none_type,),  # noqa: E501\n            'street_line2': (str, none_type,),  # noqa: E501\n            'is_primary': (bool, none_type,),  # noqa: E501\n            'id': (str, none_type),  # noqa: E501\n            'status': (AddressStatus, none_type),  # noqa: E501\n            'meta': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n            'created': (datetime, none_type),  # noqa: E501\n            'updated': (datetime, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'category': 'category',  # noqa: E501\n        'country': 'country',  # noqa: E501\n        'province_state': 'province_state',  # noqa: E501\n        'city': 'city',  # noqa: E501\n        'postal_code': 'postal_code',  # noqa: E501\n        'street_line1': 'street_line1',  # noqa: E501\n        'street_line2': 'street_line2',  # noqa: E501\n        'is_primary': 'is_primary',  # noqa: E501\n        'id': 'id',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'meta': 'meta',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, category, country, province_state, city, postal_code, street_line1, street_line2, is_primary, *args, **kwargs):  # noqa: E501\n        \"\"\"Address - a model defined in OpenAPI\n\n        Args:\n            category (str, none_type):\n            country (bool, date, datetime, dict, float, int, list, str, none_type):\n            province_state (str, none_type):\n            city (str, none_type):\n            postal_code (str, none_type):\n            street_line1 (str, none_type):\n            street_line2 (str, none_type):\n            is_primary (bool, none_type):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            id (str): [optional]  # noqa: E501\n            status (AddressStatus): [optional]  # noqa: E501\n            meta ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            created (datetime): [optional]  # noqa: E501\n            updated (datetime): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.category = category\n        self.country = country\n        self.province_state = province_state\n        self.city = city\n        self.postal_code = postal_code\n        self.street_line1 = street_line1\n        self.street_line2 = street_line2\n        self.is_primary = is_primary\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        category: str | None,\n        country: object,\n        province_state: str | None,\n        city: str | None,\n        postal_code: str | None,\n        street_line1: str | None,\n        street_line2: str | None,\n        is_primary: bool | None,\n        id: str | None = None,\n        status: AddressStatus | None = None,\n        meta: dict | None = None,\n        created: datetime | None = None,\n        updated: datetime | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Address - a model defined in OpenAPI\n\n        Args:\n            category (str, none_type):\n            country (bool, date, datetime, dict, float, int, list, str, none_type):\n            province_state (str, none_type):\n            city (str, none_type):\n            postal_code (str, none_type):\n            street_line1 (str, none_type):\n            street_line2 (str, none_type):\n            is_primary (bool, none_type):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            id (str): [optional]  # noqa: E501\n            status (AddressStatus): [optional]  # noqa: E501\n            meta ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            created (datetime): [optional]  # noqa: E501\n            updated (datetime): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.category = category\n        self.country = country\n        self.province_state = province_state\n        self.city = city\n        self.postal_code = postal_code\n        self.street_line1 = street_line1\n        self.street_line2 = street_line2\n        self.is_primary = is_primary\n        if id is not None:\n            self.id = id\n        if status is not None:\n            self.status = status\n        if meta is not None:\n            self.meta = meta\n        if created is not None:\n            self.created = created\n        if updated is not None:\n            self.updated = updated\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      72,
      73,
      87,
      88,
      106,
      183,
      184,
      185,
      186,
      187,
      189,
      191,
      192,
      193,
      194,
      195,
      196,
      198,
      207,
      208,
      209,
      210,
      211,
      212,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      228,
      229,
      230,
      309,
      310,
      311,
      312,
      313,
      315,
      316,
      317,
      318,
      319,
      320,
      322,
      331,
      332,
      333,
      334,
      335,
      336,
      338,
      339,
      340,
      341,
      342,
      343,
      344,
      345,
      346,
      347,
      348,
      349,
      350,
      351,
      352,
      353,
      354,
      355,
      356,
      357,
      362,
      363,
      364,
      365
    ]
  },
  {
    "file_path": "xendit/customer/model/address_request.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.address_status import AddressStatus\nfrom xendit.customer.model.country_code import CountryCode\nglobals()['AddressStatus'] = AddressStatus\nglobals()['CountryCode'] = CountryCode\n\ndef lazy_import():\n    pass\n\nclass AddressRequest(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('category',): {\n            'max_length': 255,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'category': (str, none_type),  # noqa: E501\n            'country_code': (CountryCode, none_type),  # noqa: E501\n            'province_state': (str, none_type),  # noqa: E501\n            'city': (str, none_type),  # noqa: E501\n            'suburb': (str, none_type),  # noqa: E501\n            'postal_code': (str, none_type),  # noqa: E501\n            'line_1': (str, none_type),  # noqa: E501\n            'line_2': (str, none_type),  # noqa: E501\n            'status': (AddressStatus, none_type),  # noqa: E501\n            'is_primary': (bool, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'category': 'category',  # noqa: E501\n        'country_code': 'country_code',  # noqa: E501\n        'province_state': 'province_state',  # noqa: E501\n        'city': 'city',  # noqa: E501\n        'suburb': 'suburb',  # noqa: E501\n        'postal_code': 'postal_code',  # noqa: E501\n        'line_1': 'line_1',  # noqa: E501\n        'line_2': 'line_2',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'is_primary': 'is_primary',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"AddressRequest - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            category (str): Home, work or provincial. [optional]  # noqa: E501\n            country_code (CountryCode): [optional]  # noqa: E501\n            province_state (str): [optional]  # noqa: E501\n            city (str): [optional]  # noqa: E501\n            suburb (str): [optional]  # noqa: E501\n            postal_code (str): [optional]  # noqa: E501\n            line_1 (str): [optional]  # noqa: E501\n            line_2 (str): [optional]  # noqa: E501\n            status (AddressStatus): [optional]  # noqa: E501\n            is_primary (bool): [optional] if omitted the server will use the default value of False  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        category: str | None = None,\n        country_code: str | None = None,\n        province_state: str | None = None,\n        city: str | None = None,\n        suburb: str | None = None,\n        postal_code: str | None = None,\n        line_1: str | None = None,\n        line_2: str | None = None,\n        status: AddressStatus | None = None,\n        is_primary: bool | None = False,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"AddressRequest - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            category (str): Home, work or provincial. [optional]  # noqa: E501\n            country_code (CountryCode): [optional]  # noqa: E501\n            province_state (str): [optional]  # noqa: E501\n            city (str): [optional]  # noqa: E501\n            suburb (str): [optional]  # noqa: E501\n            postal_code (str): [optional]  # noqa: E501\n            line_1 (str): [optional]  # noqa: E501\n            line_2 (str): [optional]  # noqa: E501\n            status (AddressStatus): [optional]  # noqa: E501\n            is_primary (bool): [optional] if omitted the server will use the default value of False  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if category is not None:\n            self.category = category\n        if country_code is not None:\n            self.country_code = country_code\n        if province_state is not None:\n            self.province_state = province_state\n        if city is not None:\n            self.city = city\n        if suburb is not None:\n            self.suburb = suburb\n        if postal_code is not None:\n            self.postal_code = postal_code\n        if line_1 is not None:\n            self.line_1 = line_1\n        if line_2 is not None:\n            self.line_2 = line_2\n        if status is not None:\n            self.status = status\n        if is_primary is not None:\n            self.is_primary = is_primary\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      74,
      75,
      89,
      90,
      105,
      174,
      175,
      176,
      177,
      178,
      180,
      182,
      183,
      184,
      185,
      186,
      187,
      189,
      198,
      199,
      200,
      201,
      202,
      203,
      205,
      206,
      211,
      212,
      213,
      284,
      285,
      286,
      287,
      288,
      290,
      291,
      292,
      293,
      294,
      295,
      297,
      306,
      307,
      308,
      309,
      310,
      311,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      322,
      323,
      324,
      325,
      326,
      327,
      328,
      329,
      330,
      331,
      332,
      333,
      334,
      339,
      340,
      341,
      342
    ]
  },
  {
    "file_path": "xendit/customer/model/address_status.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass AddressStatus(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'None': None,\n            'ACTIVE': \"ACTIVE\",\n            'DELETED': \"DELETED\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"AddressStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"ACTIVE\", \"DELETED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"ACTIVE\", \"DELETED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"AddressStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"ACTIVE\", \"DELETED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"ACTIVE\", \"DELETED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      77,
      83,
      144,
      146,
      147,
      148,
      149,
      150,
      152,
      158,
      159,
      160,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      240,
      242,
      244,
      245,
      246,
      247,
      248,
      250,
      256,
      257,
      258,
      259,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      297
    ]
  },
  {
    "file_path": "xendit/customer/model/business_detail.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.country_code import CountryCode\nglobals()['CountryCode'] = CountryCode\n\ndef lazy_import():\n    pass\n\nclass BusinessDetail(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('business_type',): {\n            'None': None,\n            'CORPORATION': \"CORPORATION\",\n            'SOLE_PROPRIETOR': \"SOLE_PROPRIETOR\",\n            'PARTNERSHIP': \"PARTNERSHIP\",\n            'COOPERATIVE': \"COOPERATIVE\",\n            'TRUST': \"TRUST\",\n            'NON_PROFIT': \"NON_PROFIT\",\n            'GOVERNMENT': \"GOVERNMENT\",\n        },\n    }\n\n    validations = {\n        ('business_name',): {\n            'max_length': 255,\n        },\n        ('date_of_registration',): {\n            'max_length': 10,\n        },\n        ('nature_of_business',): {\n            'max_length': 255,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'business_name': (str, none_type),  # noqa: E501\n            'business_type': (str, none_type, none_type),  # noqa: E501\n            'date_of_registration': (str, none_type, none_type),  # noqa: E501\n            'nature_of_business': (str, none_type, none_type),  # noqa: E501\n            'business_domicile': (CountryCode, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'business_name': 'business_name',  # noqa: E501\n        'business_type': 'business_type',  # noqa: E501\n        'date_of_registration': 'date_of_registration',  # noqa: E501\n        'nature_of_business': 'nature_of_business',  # noqa: E501\n        'business_domicile': 'business_domicile',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"BusinessDetail - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            business_name (str): [optional]  # noqa: E501\n            business_type (str, none_type): [optional]  # noqa: E501\n            date_of_registration (str, none_type): [optional]  # noqa: E501\n            nature_of_business (str, none_type): [optional]  # noqa: E501\n            business_domicile (CountryCode): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        business_name: str | None = None,\n        business_type: str | None = None,\n        date_of_registration: str | None = None,\n        nature_of_business: str | None = None,\n        business_domicile: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"BusinessDetail - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            business_name (str): [optional]  # noqa: E501\n            business_type (str, none_type): [optional]  # noqa: E501\n            date_of_registration (str, none_type): [optional]  # noqa: E501\n            nature_of_business (str, none_type): [optional]  # noqa: E501\n            business_domicile (CountryCode): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if business_name is not None:\n            self.business_name = business_name\n        if business_type is not None:\n            self.business_type = business_type\n        if date_of_registration is not None:\n            self.date_of_registration = date_of_registration\n        if nature_of_business is not None:\n            self.nature_of_business = nature_of_business\n        if business_domicile is not None:\n            self.business_domicile = business_domicile\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      88,
      89,
      103,
      104,
      114,
      173,
      174,
      175,
      176,
      177,
      179,
      181,
      182,
      183,
      184,
      185,
      186,
      188,
      197,
      198,
      199,
      200,
      201,
      202,
      204,
      205,
      210,
      211,
      212,
      273,
      274,
      275,
      276,
      277,
      279,
      280,
      281,
      282,
      283,
      284,
      286,
      295,
      296,
      297,
      298,
      299,
      300,
      302,
      303,
      304,
      305,
      306,
      307,
      308,
      309,
      310,
      311,
      312,
      313,
      318,
      319,
      320,
      321
    ]
  },
  {
    "file_path": "xendit/customer/model/country_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CountryCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('value',): {\n            'max_length': 2,\n        },\n    }\n\n    additional_properties_type = None\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"CountryCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): ISO3166-2 country code.  # noqa: E501\n\n        Keyword Args:\n            value (str): ISO3166-2 country code.  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"CountryCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): ISO3166-2 country code.  # noqa: E501\n\n        Keyword Args:\n            value (str): ISO3166-2 country code.  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      74,
      80,
      141,
      143,
      144,
      145,
      146,
      147,
      149,
      155,
      156,
      157,
      158,
      160,
      161,
      162,
      163,
      164,
      165,
      167,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      237,
      239,
      241,
      242,
      243,
      244,
      245,
      247,
      253,
      254,
      255,
      256,
      258,
      259,
      260,
      261,
      262,
      263,
      265,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      291
    ]
  },
  {
    "file_path": "xendit/customer/model/create_customer400_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.create_customer400_response_all_of import CreateCustomer400ResponseAllOf\nfrom xendit.customer.model.error import Error\nglobals()['CreateCustomer400ResponseAllOf'] = CreateCustomer400ResponseAllOf\nglobals()['Error'] = Error\n\ndef lazy_import():\n    pass\n\nclass CreateCustomer400Response(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'DUPLICATE_END_CUSTOMER_ERROR': \"DUPLICATE_END_CUSTOMER_ERROR\",\n            'API_VALIDATION_ERROR': \"API_VALIDATION_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'error_code': (str,),  # noqa: E501\n            'message': (bool, date, datetime, dict, float, int, list, str, none_type,),  # noqa: E501\n            'errors': ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n        'errors': 'errors',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CreateCustomer400Response - a model defined in OpenAPI\n\n        Keyword Args:\n            error_code (str):\n            message (bool, date, datetime, dict, float, int, list, str, none_type):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            errors ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"CreateCustomer400Response - a model defined in OpenAPI\n\n        Keyword Args:\n            error_code (str):\n            message (bool, date, datetime, dict, float, int, list, str, none_type):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            errors ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              CreateCustomer400ResponseAllOf,\n              Error,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      75,
      76,
      90,
      91,
      99,
      152,
      153,
      154,
      155,
      156,
      158,
      160,
      161,
      162,
      163,
      164,
      165,
      167,
      176,
      177,
      178,
      179,
      180,
      181,
      183,
      190,
      192,
      193,
      194,
      195,
      197,
      198,
      203,
      204,
      206,
      260,
      261,
      262,
      263,
      264,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      282,
      283,
      284,
      285,
      286,
      287,
      289,
      296,
      298,
      299,
      300,
      301,
      303,
      304,
      309,
      310,
      311,
      312,
      324,
      325
    ]
  },
  {
    "file_path": "xendit/customer/model/create_customer400_response_all_of.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CreateCustomer400ResponseAllOf(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'DUPLICATE_END_CUSTOMER_ERROR': \"DUPLICATE_END_CUSTOMER_ERROR\",\n            'API_VALIDATION_ERROR': \"API_VALIDATION_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (bool, date, datetime, dict, float, int, list, str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CreateCustomer400ResponseAllOf - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: object | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CreateCustomer400ResponseAllOf - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      85,
      92,
      145,
      146,
      147,
      148,
      149,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      160,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/customer/model/customer.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.address import Address\nfrom xendit.customer.model.business_detail import BusinessDetail\nfrom xendit.customer.model.end_customer_status import EndCustomerStatus\nfrom xendit.customer.model.identity_account_response import IdentityAccountResponse\nfrom xendit.customer.model.individual_detail import IndividualDetail\nfrom xendit.customer.model.kyc_document_response import KYCDocumentResponse\nglobals()['Address'] = Address\nglobals()['BusinessDetail'] = BusinessDetail\nglobals()['EndCustomerStatus'] = EndCustomerStatus\nglobals()['IdentityAccountResponse'] = IdentityAccountResponse\nglobals()['IndividualDetail'] = IndividualDetail\nglobals()['KYCDocumentResponse'] = KYCDocumentResponse\n\ndef lazy_import():\n    pass\n\nclass Customer(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('type',): {\n            'INDIVIDUAL': \"INDIVIDUAL\",\n            'BUSINESS': \"BUSINESS\",\n        },\n    }\n\n    validations = {\n        ('reference_id',): {\n            'max_length': 255,\n        },\n        ('description',): {\n            'max_length': 1000,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'type': (str,),  # noqa: E501\n            'reference_id': (str,),  # noqa: E501\n            'individual_detail': (IndividualDetail,),  # noqa: E501\n            'business_detail': (BusinessDetail,),  # noqa: E501\n            'description': (str, none_type,),  # noqa: E501\n            'email': (str, none_type,),  # noqa: E501\n            'mobile_number': (str, none_type,),  # noqa: E501\n            'phone_number': (str, none_type,),  # noqa: E501\n            'addresses': ([Address], none_type,),  # noqa: E501\n            'identity_accounts': ([IdentityAccountResponse], none_type,),  # noqa: E501\n            'kyc_documents': ([KYCDocumentResponse], none_type,),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type,),  # noqa: E501\n            'id': (str,),  # noqa: E501\n            'created': (datetime,),  # noqa: E501\n            'updated': (datetime,),  # noqa: E501\n            'status': (EndCustomerStatus, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'type': 'type',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'individual_detail': 'individual_detail',  # noqa: E501\n        'business_detail': 'business_detail',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'email': 'email',  # noqa: E501\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'phone_number': 'phone_number',  # noqa: E501\n        'addresses': 'addresses',  # noqa: E501\n        'identity_accounts': 'identity_accounts',  # noqa: E501\n        'kyc_documents': 'kyc_documents',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n        'id': 'id',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'status': 'status',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, reference_id, individual_detail, business_detail, description, email, mobile_number, phone_number, addresses, identity_accounts, kyc_documents, metadata, id, created, updated, *args, **kwargs):  # noqa: E501\n        \"\"\"Customer - a model defined in OpenAPI\n\n        Args:\n            reference_id (str): Merchant's reference of this end customer, eg Merchant's user's id. Must be unique.\n            individual_detail (IndividualDetail):\n            business_detail (BusinessDetail):\n            description (str, none_type):\n            email (str, none_type):\n            mobile_number (str, none_type):\n            phone_number (str, none_type):\n            addresses ([Address], none_type):\n            identity_accounts ([IdentityAccountResponse], none_type):\n            kyc_documents ([KYCDocumentResponse], none_type):\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type):\n            id (str):\n            created (datetime):\n            updated (datetime):\n\n        Keyword Args:\n            type (str): defaults to \"INDIVIDUAL\", must be one of [\"INDIVIDUAL\", \"BUSINESS\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            status (EndCustomerStatus): [optional]  # noqa: E501\n        \"\"\"\n\n        type = kwargs.get('type', \"INDIVIDUAL\")\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        self.reference_id = reference_id\n        self.individual_detail = individual_detail\n        self.business_detail = business_detail\n        self.description = description\n        self.email = email\n        self.mobile_number = mobile_number\n        self.phone_number = phone_number\n        self.addresses = addresses\n        self.identity_accounts = identity_accounts\n        self.kyc_documents = kyc_documents\n        self.metadata = metadata\n        self.id = id\n        self.created = created\n        self.updated = updated\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        reference_id: str,\n        individual_detail: IndividualDetail | None,\n        business_detail: BusinessDetail | None,\n        description: str | None,\n        email: str | None,\n        mobile_number: str | None,\n        phone_number: str | None,\n        addresses: list | None,\n        identity_accounts: list | None,\n        kyc_documents: list | None,\n        metadata: dict | None,\n        id: str,\n        created: datetime,\n        updated: datetime,\n        status: EndCustomerStatus | None = None,\n        type: str = \"INDIVIDUAL\",\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Customer - a model defined in OpenAPI\n\n        Args:\n            reference_id (str): Merchant's reference of this end customer, eg Merchant's user's id. Must be unique.\n            individual_detail (IndividualDetail):\n            business_detail (BusinessDetail):\n            description (str, none_type):\n            email (str, none_type):\n            mobile_number (str, none_type):\n            phone_number (str, none_type):\n            addresses ([Address], none_type):\n            identity_accounts ([IdentityAccountResponse], none_type):\n            kyc_documents ([KYCDocumentResponse], none_type):\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type):\n            id (str):\n            created (datetime):\n            updated (datetime):\n\n\n        Keyword Args:\n            type (str): defaults to \"INDIVIDUAL\", must be one of [\"INDIVIDUAL\", \"BUSINESS\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            status (EndCustomerStatus): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        self.reference_id = reference_id\n        self.individual_detail = individual_detail\n        self.business_detail = business_detail\n        self.description = description\n        self.email = email\n        self.mobile_number = mobile_number\n        self.phone_number = phone_number\n        self.addresses = addresses\n        self.identity_accounts = identity_accounts\n        self.kyc_documents = kyc_documents\n        self.metadata = metadata\n        self.id = id\n        self.created = created\n        self.updated = updated\n        if status is not None:\n            self.status = status\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      89,
      90,
      104,
      105,
      126,
      209,
      210,
      211,
      212,
      213,
      214,
      216,
      218,
      219,
      220,
      221,
      222,
      223,
      225,
      234,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255,
      256,
      257,
      262,
      263,
      264,
      349,
      350,
      351,
      352,
      353,
      355,
      356,
      357,
      358,
      359,
      360,
      362,
      371,
      372,
      373,
      374,
      375,
      376,
      378,
      379,
      380,
      381,
      382,
      383,
      384,
      385,
      386,
      387,
      388,
      389,
      390,
      391,
      392,
      393,
      394,
      395,
      396,
      401,
      402,
      403,
      404
    ]
  },
  {
    "file_path": "xendit/customer/model/customer_request.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.address_request import AddressRequest\nfrom xendit.customer.model.business_detail import BusinessDetail\nfrom xendit.customer.model.identity_account_request import IdentityAccountRequest\nfrom xendit.customer.model.individual_detail import IndividualDetail\nfrom xendit.customer.model.kyc_document_request import KYCDocumentRequest\nglobals()['AddressRequest'] = AddressRequest\nglobals()['BusinessDetail'] = BusinessDetail\nglobals()['IdentityAccountRequest'] = IdentityAccountRequest\nglobals()['IndividualDetail'] = IndividualDetail\nglobals()['KYCDocumentRequest'] = KYCDocumentRequest\n\ndef lazy_import():\n    pass\n\nclass CustomerRequest(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('type',): {\n            'INDIVIDUAL': \"INDIVIDUAL\",\n            'BUSINESS': \"BUSINESS\",\n        },\n    }\n\n    validations = {\n        ('reference_id',): {\n            'max_length': 255,\n        },\n        ('description',): {\n            'max_length': 1000,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'reference_id': (str,),  # noqa: E501\n            'client_name': (str, none_type),  # noqa: E501\n            'type': (str, none_type),  # noqa: E501\n            'individual_detail': (IndividualDetail, none_type),  # noqa: E501\n            'business_detail': (BusinessDetail, none_type),  # noqa: E501\n            'description': (str, none_type, none_type),  # noqa: E501\n            'email': (str, none_type),  # noqa: E501\n            'mobile_number': (str, none_type),  # noqa: E501\n            'phone_number': (str, none_type),  # noqa: E501\n            'addresses': ([AddressRequest], none_type),  # noqa: E501\n            'identity_accounts': ([IdentityAccountRequest], none_type),  # noqa: E501\n            'kyc_documents': ([KYCDocumentRequest], none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'reference_id': 'reference_id',  # noqa: E501\n        'client_name': 'client_name',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'individual_detail': 'individual_detail',  # noqa: E501\n        'business_detail': 'business_detail',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'email': 'email',  # noqa: E501\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'phone_number': 'phone_number',  # noqa: E501\n        'addresses': 'addresses',  # noqa: E501\n        'identity_accounts': 'identity_accounts',  # noqa: E501\n        'kyc_documents': 'kyc_documents',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, reference_id, *args, **kwargs):  # noqa: E501\n        \"\"\"CustomerRequest - a model defined in OpenAPI\n\n        Args:\n            reference_id (str): Merchant's reference of this end customer, eg Merchant's user's id. Must be unique.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            client_name (str): Entity's name for this client. [optional]  # noqa: E501\n            type (str): [optional] if omitted the server will use the default value of \"INDIVIDUAL\"  # noqa: E501\n            individual_detail (IndividualDetail): [optional]  # noqa: E501\n            business_detail (BusinessDetail): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            email (str): [optional]  # noqa: E501\n            mobile_number (str): [optional]  # noqa: E501\n            phone_number (str): [optional]  # noqa: E501\n            addresses ([AddressRequest]): [optional]  # noqa: E501\n            identity_accounts ([IdentityAccountRequest]): [optional]  # noqa: E501\n            kyc_documents ([KYCDocumentRequest]): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.reference_id = reference_id\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        reference_id: str,\n        client_name: str | None = None,\n        individual_detail: IndividualDetail | None = None,\n        business_detail: BusinessDetail | None = None,\n        description: str | None = None,\n        email: str | None = None,\n        mobile_number: str | None = None,\n        phone_number: str | None = None,\n        addresses: list | None = None,\n        identity_accounts: list | None = None,\n        kyc_documents: list | None = None,\n        metadata: dict | None = None,\n        type: str | None = \"INDIVIDUAL\",\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CustomerRequest - a model defined in OpenAPI\n\n        Args:\n            reference_id (str): Merchant's reference of this end customer, eg Merchant's user's id. Must be unique.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            client_name (str): Entity's name for this client. [optional]  # noqa: E501\n            type (str): [optional] if omitted the server will use the default value of \"INDIVIDUAL\"  # noqa: E501\n            individual_detail (IndividualDetail): [optional]  # noqa: E501\n            business_detail (BusinessDetail): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            email (str): [optional]  # noqa: E501\n            mobile_number (str): [optional]  # noqa: E501\n            phone_number (str): [optional]  # noqa: E501\n            addresses ([AddressRequest]): [optional]  # noqa: E501\n            identity_accounts ([IdentityAccountRequest]): [optional]  # noqa: E501\n            kyc_documents ([KYCDocumentRequest]): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.reference_id = reference_id\n        if client_name is not None:\n            self.client_name = client_name\n        if type is not None:\n            self.type = type\n        if individual_detail is not None:\n            self.individual_detail = individual_detail\n        if business_detail is not None:\n            self.business_detail = business_detail\n        if description is not None:\n            self.description = description\n        if email is not None:\n            self.email = email\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if phone_number is not None:\n            self.phone_number = phone_number\n        if addresses is not None:\n            self.addresses = addresses\n        if identity_accounts is not None:\n            self.identity_accounts = identity_accounts\n        if kyc_documents is not None:\n            self.kyc_documents = kyc_documents\n        if metadata is not None:\n            self.metadata = metadata\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      87,
      88,
      102,
      103,
      121,
      198,
      199,
      200,
      201,
      202,
      204,
      206,
      207,
      208,
      209,
      210,
      211,
      213,
      222,
      223,
      224,
      225,
      226,
      227,
      229,
      230,
      231,
      236,
      237,
      238,
      317,
      318,
      319,
      320,
      321,
      323,
      324,
      325,
      326,
      327,
      328,
      330,
      339,
      340,
      341,
      342,
      343,
      344,
      346,
      347,
      348,
      349,
      350,
      351,
      352,
      353,
      354,
      355,
      356,
      357,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      368,
      369,
      370,
      371,
      372,
      377,
      378,
      379,
      380
    ]
  },
  {
    "file_path": "xendit/customer/model/employment_detail.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass EmploymentDetail(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'employer_name': (str, none_type, none_type),  # noqa: E501\n            'nature_of_business': (str, none_type, none_type),  # noqa: E501\n            'role_description': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'employer_name': 'employer_name',  # noqa: E501\n        'nature_of_business': 'nature_of_business',  # noqa: E501\n        'role_description': 'role_description',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"EmploymentDetail - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            employer_name (str, none_type): Name of employer. [optional]  # noqa: E501\n            nature_of_business (str, none_type): Industry or nature of business. [optional]  # noqa: E501\n            role_description (str, none_type): Occupation or title. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        employer_name: str | None = None,\n        nature_of_business: str | None = None,\n        role_description: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"EmploymentDetail - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            employer_name (str, none_type): Name of employer. [optional]  # noqa: E501\n            nature_of_business (str, none_type): Industry or nature of business. [optional]  # noqa: E501\n            role_description (str, none_type): Occupation or title. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if employer_name is not None:\n            self.employer_name = employer_name\n        if nature_of_business is not None:\n            self.nature_of_business = nature_of_business\n        if role_description is not None:\n            self.role_description = role_description\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      181,
      182,
      183,
      240,
      241,
      242,
      243,
      244,
      246,
      247,
      248,
      249,
      250,
      251,
      253,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      275,
      276,
      281,
      282,
      283,
      284
    ]
  },
  {
    "file_path": "xendit/customer/model/end_customer_status.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass EndCustomerStatus(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'None': None,\n            'ACTIVE': \"ACTIVE\",\n            'INACTIVE': \"INACTIVE\",\n            'PENDING': \"PENDING\",\n            'BLOCKED': \"BLOCKED\",\n            'DELETED': \"DELETED\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"EndCustomerStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"ACTIVE\", \"INACTIVE\", \"PENDING\", \"BLOCKED\", \"DELETED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"ACTIVE\", \"INACTIVE\", \"PENDING\", \"BLOCKED\", \"DELETED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"EndCustomerStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"ACTIVE\", \"INACTIVE\", \"PENDING\", \"BLOCKED\", \"DELETED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"ACTIVE\", \"INACTIVE\", \"PENDING\", \"BLOCKED\", \"DELETED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      80,
      86,
      147,
      149,
      150,
      151,
      152,
      153,
      155,
      161,
      162,
      163,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      243,
      245,
      247,
      248,
      249,
      250,
      251,
      253,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      271,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      300
    ]
  },
  {
    "file_path": "xendit/customer/model/error.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass Error(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str,),  # noqa: E501\n            'message': (str,),  # noqa: E501\n            'errors': ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n        'errors': 'errors',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, error_code, message, *args, **kwargs):  # noqa: E501\n        \"\"\"Error - a model defined in OpenAPI\n\n        Args:\n            error_code (str):\n            message (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            errors ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str,\n        message: str,\n        errors: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Error - a model defined in OpenAPI\n\n        Args:\n            error_code (str):\n            message (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            errors ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        if errors is not None:\n            self.errors = errors\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      146,
      147,
      148,
      149,
      150,
      152,
      154,
      155,
      156,
      157,
      158,
      159,
      161,
      170,
      171,
      172,
      173,
      174,
      175,
      177,
      178,
      179,
      180,
      185,
      186,
      187,
      246,
      247,
      248,
      249,
      250,
      252,
      253,
      254,
      255,
      256,
      257,
      259,
      268,
      269,
      270,
      271,
      272,
      273,
      275,
      276,
      277,
      278,
      279,
      280,
      285,
      286,
      287,
      288
    ]
  },
  {
    "file_path": "xendit/customer/model/get_customer_by_reference_id200_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.customer import Customer\nglobals()['Customer'] = Customer\n\ndef lazy_import():\n    pass\n\nclass GetCustomerByReferenceID200Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'has_more': (bool, none_type),  # noqa: E501\n            'data': ([Customer], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'has_more': 'has_more',  # noqa: E501\n        'data': 'data',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"GetCustomerByReferenceID200Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            has_more (bool): [optional]  # noqa: E501\n            data ([Customer]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        has_more: bool | None = None,\n        data: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"GetCustomerByReferenceID200Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            has_more (bool): [optional]  # noqa: E501\n            data ([Customer]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if has_more is not None:\n            self.has_more = has_more\n        if data is not None:\n            self.data = data\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      92,
      145,
      146,
      147,
      148,
      149,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      160,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/customer/model/get_customer_by_reference_id400_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.error import Error\nfrom xendit.customer.model.get_customer_by_reference_id400_response_all_of import GetCustomerByReferenceID400ResponseAllOf\nglobals()['Error'] = Error\nglobals()['GetCustomerByReferenceID400ResponseAllOf'] = GetCustomerByReferenceID400ResponseAllOf\n\ndef lazy_import():\n    pass\n\nclass GetCustomerByReferenceID400Response(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'ENTITY_NOT_FOUND_ERROR': \"ENTITY_NOT_FOUND_ERROR\",\n            'CLIENT_NOT_FOUND_ERROR': \"CLIENT_NOT_FOUND_ERROR\",\n            'END_CUSTOMER_NOT_FOUND_ERROR': \"END_CUSTOMER_NOT_FOUND_ERROR\",\n            'API_VALIDATION_ERROR': \"API_VALIDATION_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'error_code': (str,),  # noqa: E501\n            'message': (bool, date, datetime, dict, float, int, list, str, none_type,),  # noqa: E501\n            'errors': ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n        'errors': 'errors',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"GetCustomerByReferenceID400Response - a model defined in OpenAPI\n\n        Keyword Args:\n            error_code (str):\n            message (bool, date, datetime, dict, float, int, list, str, none_type):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            errors ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"GetCustomerByReferenceID400Response - a model defined in OpenAPI\n\n        Keyword Args:\n            error_code (str):\n            message (bool, date, datetime, dict, float, int, list, str, none_type):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            errors ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              Error,\n              GetCustomerByReferenceID400ResponseAllOf,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      77,
      78,
      92,
      93,
      101,
      154,
      155,
      156,
      157,
      158,
      160,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      178,
      179,
      180,
      181,
      182,
      183,
      185,
      192,
      194,
      195,
      196,
      197,
      199,
      200,
      205,
      206,
      208,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      275,
      284,
      285,
      286,
      287,
      288,
      289,
      291,
      298,
      300,
      301,
      302,
      303,
      305,
      306,
      311,
      312,
      313,
      314,
      326,
      327
    ]
  },
  {
    "file_path": "xendit/customer/model/get_customer_by_reference_id400_response_all_of.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass GetCustomerByReferenceID400ResponseAllOf(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'ENTITY_NOT_FOUND_ERROR': \"ENTITY_NOT_FOUND_ERROR\",\n            'CLIENT_NOT_FOUND_ERROR': \"CLIENT_NOT_FOUND_ERROR\",\n            'END_CUSTOMER_NOT_FOUND_ERROR': \"END_CUSTOMER_NOT_FOUND_ERROR\",\n            'API_VALIDATION_ERROR': \"API_VALIDATION_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (bool, date, datetime, dict, float, int, list, str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"GetCustomerByReferenceID400ResponseAllOf - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: object | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"GetCustomerByReferenceID400ResponseAllOf - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      73,
      87,
      94,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      184,
      185,
      186,
      241,
      242,
      243,
      244,
      245,
      247,
      248,
      249,
      250,
      251,
      252,
      254,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      271,
      272,
      273,
      274,
      275,
      280,
      281,
      282,
      283
    ]
  },
  {
    "file_path": "xendit/customer/model/identity_account_request.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.country_code import CountryCode\nfrom xendit.customer.model.identity_account_request_properties import IdentityAccountRequestProperties\nfrom xendit.customer.model.identity_account_type import IdentityAccountType\nglobals()['CountryCode'] = CountryCode\nglobals()['IdentityAccountRequestProperties'] = IdentityAccountRequestProperties\nglobals()['IdentityAccountType'] = IdentityAccountType\n\ndef lazy_import():\n    pass\n\nclass IdentityAccountRequest(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('company',): {\n            'max_length': 100,\n        },\n        ('description',): {\n            'max_length': 255,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'type': (IdentityAccountType, none_type),  # noqa: E501\n            'company': (str, none_type),  # noqa: E501\n            'description': (str, none_type),  # noqa: E501\n            'country': (CountryCode, none_type),  # noqa: E501\n            'properties': (IdentityAccountRequestProperties, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'type': 'type',  # noqa: E501\n        'company': 'company',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'country': 'country',  # noqa: E501\n        'properties': 'properties',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"IdentityAccountRequest - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            type (IdentityAccountType): [optional]  # noqa: E501\n            company (str): The issuing institution associated with the account (e.g., OCBC, GOPAY, 7-11). If adding financial accounts that Xendit supports, we recommend you use the channel_name found at https://xendit.github.io/apireference/#payment-channels for this field. [optional]  # noqa: E501\n            description (str): Free text description of this account. [optional]  # noqa: E501\n            country (CountryCode): [optional]  # noqa: E501\n            properties (IdentityAccountRequestProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        type: IdentityAccountType | None = None,\n        company: str | None = None,\n        description: str | None = None,\n        country: str | None = None,\n        properties: IdentityAccountRequestProperties | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"IdentityAccountRequest - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            type (IdentityAccountType): [optional]  # noqa: E501\n            company (str): The issuing institution associated with the account (e.g., OCBC, GOPAY, 7-11). If adding financial accounts that Xendit supports, we recommend you use the channel_name found at https://xendit.github.io/apireference/#payment-channels for this field. [optional]  # noqa: E501\n            description (str): Free text description of this account. [optional]  # noqa: E501\n            country (CountryCode): [optional]  # noqa: E501\n            properties (IdentityAccountRequestProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if type is not None:\n            self.type = type\n        if company is not None:\n            self.company = company\n        if description is not None:\n            self.description = description\n        if country is not None:\n            self.country = country\n        if properties is not None:\n            self.properties = properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      79,
      80,
      94,
      95,
      105,
      164,
      165,
      166,
      167,
      168,
      170,
      172,
      173,
      174,
      175,
      176,
      177,
      179,
      188,
      189,
      190,
      191,
      192,
      193,
      195,
      196,
      201,
      202,
      203,
      264,
      265,
      266,
      267,
      268,
      270,
      271,
      272,
      273,
      274,
      275,
      277,
      286,
      287,
      288,
      289,
      290,
      291,
      293,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      309,
      310,
      311,
      312
    ]
  },
  {
    "file_path": "xendit/customer/model/identity_account_request_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.account_bank import AccountBank\nfrom xendit.customer.model.account_card import AccountCard\nfrom xendit.customer.model.account_ewallet import AccountEwallet\nfrom xendit.customer.model.account_otc import AccountOTC\nfrom xendit.customer.model.account_pay_later import AccountPayLater\nfrom xendit.customer.model.account_qr_code import AccountQRCode\nglobals()['AccountBank'] = AccountBank\nglobals()['AccountCard'] = AccountCard\nglobals()['AccountEwallet'] = AccountEwallet\nglobals()['AccountOTC'] = AccountOTC\nglobals()['AccountPayLater'] = AccountPayLater\nglobals()['AccountQRCode'] = AccountQRCode\n\ndef lazy_import():\n    pass\n\nclass IdentityAccountRequestProperties(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'account_number': (str, none_type),  # noqa: E501\n            'account_holder_name': (str, none_type, none_type),  # noqa: E501\n            'swift_code': (str, none_type, none_type),  # noqa: E501\n            'account_type': (str, none_type, none_type),  # noqa: E501\n            'account_details': (str, none_type, none_type),  # noqa: E501\n            'currency': (bool, date, datetime, dict, float, int, list, str, none_type, none_type),  # noqa: E501\n            'token_id': (str, none_type),  # noqa: E501\n            'account_id': (str, none_type),  # noqa: E501\n            'payment_code': (str, none_type),  # noqa: E501\n            'expires_at': (str, none_type, none_type),  # noqa: E501\n            'qr_string': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'account_number': 'account_number',  # noqa: E501\n        'account_holder_name': 'account_holder_name',  # noqa: E501\n        'swift_code': 'swift_code',  # noqa: E501\n        'account_type': 'account_type',  # noqa: E501\n        'account_details': 'account_details',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'token_id': 'token_id',  # noqa: E501\n        'account_id': 'account_id',  # noqa: E501\n        'payment_code': 'payment_code',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n        'qr_string': 'qr_string',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"IdentityAccountRequestProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_number (str): Unique account identifier as per the bank records.. [optional]  # noqa: E501\n            account_holder_name (str, none_type): Name of account holder as per the cardless credit account.. [optional]  # noqa: E501\n            swift_code (str, none_type): The SWIFT code for international payments. [optional]  # noqa: E501\n            account_type (str, none_type): Free text account type, e.g., Savings, Transaction, Virtual Account.. [optional]  # noqa: E501\n            account_details (str, none_type): Potentially masked account detail, for display purposes only.. [optional]  # noqa: E501\n            currency (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n            token_id (str): The token id returned in tokenisation. [optional]  # noqa: E501\n            account_id (str): Alphanumeric string identifying this account. Usually an email address or phone number.. [optional]  # noqa: E501\n            payment_code (str): Complete fixed payment code (including prefix). [optional]  # noqa: E501\n            expires_at (str, none_type): YYYY-MM-DD string with expiry date for the payment code. [optional]  # noqa: E501\n            qr_string (str): String representation of the QR Code image. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"IdentityAccountRequestProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_number (str): Unique account identifier as per the bank records.. [optional]  # noqa: E501\n            account_holder_name (str, none_type): Name of account holder as per the cardless credit account.. [optional]  # noqa: E501\n            swift_code (str, none_type): The SWIFT code for international payments. [optional]  # noqa: E501\n            account_type (str, none_type): Free text account type, e.g., Savings, Transaction, Virtual Account.. [optional]  # noqa: E501\n            account_details (str, none_type): Potentially masked account detail, for display purposes only.. [optional]  # noqa: E501\n            currency (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n            token_id (str): The token id returned in tokenisation. [optional]  # noqa: E501\n            account_id (str): Alphanumeric string identifying this account. Usually an email address or phone number.. [optional]  # noqa: E501\n            payment_code (str): Complete fixed payment code (including prefix). [optional]  # noqa: E501\n            expires_at (str, none_type): YYYY-MM-DD string with expiry date for the payment code. [optional]  # noqa: E501\n            qr_string (str): String representation of the QR Code image. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n              AccountBank,\n              AccountCard,\n              AccountEwallet,\n              AccountOTC,\n              AccountPayLater,\n              AccountQRCode,\n          ],\n          'allOf': [\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      79,
      80,
      94,
      95,
      111,
      180,
      181,
      182,
      183,
      184,
      186,
      188,
      189,
      190,
      191,
      192,
      193,
      195,
      204,
      205,
      206,
      207,
      208,
      209,
      211,
      218,
      220,
      221,
      222,
      223,
      225,
      226,
      231,
      232,
      234,
      296,
      297,
      298,
      299,
      300,
      302,
      303,
      304,
      305,
      306,
      307,
      309,
      318,
      319,
      320,
      321,
      322,
      323,
      325,
      332,
      334,
      335,
      336,
      337,
      339,
      340,
      345,
      346,
      347,
      348,
      360,
      361
    ]
  },
  {
    "file_path": "xendit/customer/model/identity_account_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.country_code import CountryCode\nfrom xendit.customer.model.identity_account_response_properties import IdentityAccountResponseProperties\nglobals()['CountryCode'] = CountryCode\nglobals()['IdentityAccountResponseProperties'] = IdentityAccountResponseProperties\n\ndef lazy_import():\n    pass\n\nclass IdentityAccountResponse(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('type',): {\n            'None': None,\n            'BANK_ACCOUNT': \"BANK_ACCOUNT\",\n            'EWALLET': \"EWALLET\",\n            'CREDIT_CARD': \"CREDIT_CARD\",\n            'OTC': \"OTC\",\n            'QR_CODE': \"QR_CODE\",\n            'CARDLESS_CREDIT': \"CARDLESS_CREDIT\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'company': (str, none_type,),  # noqa: E501\n            'description': (str, none_type,),  # noqa: E501\n            'country': (CountryCode,),  # noqa: E501\n            'type': (str, none_type,),  # noqa: E501\n            'properties': (IdentityAccountResponseProperties,),  # noqa: E501\n            'id': (str, none_type),  # noqa: E501\n            'code': (str, none_type, none_type),  # noqa: E501\n            'holder_name': (str, none_type, none_type),  # noqa: E501\n            'created': (datetime, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'company': 'company',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'country': 'country',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'properties': 'properties',  # noqa: E501\n        'id': 'id',  # noqa: E501\n        'code': 'code',  # noqa: E501\n        'holder_name': 'holder_name',  # noqa: E501\n        'created': 'created',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, company, description, country, type, properties, *args, **kwargs):  # noqa: E501\n        \"\"\"IdentityAccountResponse - a model defined in OpenAPI\n\n        Args:\n            company (str, none_type):\n            description (str, none_type):\n            country (CountryCode):\n            type (str, none_type):\n            properties (IdentityAccountResponseProperties):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            id (str): [optional]  # noqa: E501\n            code (str, none_type): [optional]  # noqa: E501\n            holder_name (str, none_type): [optional]  # noqa: E501\n            created (datetime): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.company = company\n        self.description = description\n        self.country = country\n        self.type = type\n        self.properties = properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        company: str | None,\n        description: str | None,\n        country: str | None,\n        type: str | None,\n        properties: IdentityAccountResponseProperties,\n        id: str | None = None,\n        code: str | None = None,\n        holder_name: str | None = None,\n        created: datetime | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"IdentityAccountResponse - a model defined in OpenAPI\n\n        Args:\n            company (str, none_type):\n            description (str, none_type):\n            country (CountryCode):\n            type (str, none_type):\n            properties (IdentityAccountResponseProperties):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            id (str): [optional]  # noqa: E501\n            code (str, none_type): [optional]  # noqa: E501\n            holder_name (str, none_type): [optional]  # noqa: E501\n            created (datetime): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.company = company\n        self.description = description\n        self.country = country\n        self.type = type\n        self.properties = properties\n        if id is not None:\n            self.id = id\n        if code is not None:\n            self.code = code\n        if holder_name is not None:\n            self.holder_name = holder_name\n        if created is not None:\n            self.created = created\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      80,
      81,
      95,
      96,
      110,
      179,
      180,
      181,
      182,
      183,
      185,
      187,
      188,
      189,
      190,
      191,
      192,
      194,
      203,
      204,
      205,
      206,
      207,
      208,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      221,
      222,
      223,
      294,
      295,
      296,
      297,
      298,
      300,
      301,
      302,
      303,
      304,
      305,
      307,
      316,
      317,
      318,
      319,
      320,
      321,
      323,
      324,
      325,
      326,
      327,
      328,
      329,
      330,
      331,
      332,
      333,
      334,
      335,
      336,
      337,
      342,
      343,
      344,
      345
    ]
  },
  {
    "file_path": "xendit/customer/model/identity_account_response_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.account_bank import AccountBank\nfrom xendit.customer.model.account_card import AccountCard\nfrom xendit.customer.model.account_ewallet import AccountEwallet\nfrom xendit.customer.model.account_otc import AccountOTC\nfrom xendit.customer.model.account_pay_later import AccountPayLater\nfrom xendit.customer.model.account_qr_code import AccountQRCode\nglobals()['AccountBank'] = AccountBank\nglobals()['AccountCard'] = AccountCard\nglobals()['AccountEwallet'] = AccountEwallet\nglobals()['AccountOTC'] = AccountOTC\nglobals()['AccountPayLater'] = AccountPayLater\nglobals()['AccountQRCode'] = AccountQRCode\n\ndef lazy_import():\n    pass\n\nclass IdentityAccountResponseProperties(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'account_number': (str, none_type),  # noqa: E501\n            'account_holder_name': (str, none_type, none_type),  # noqa: E501\n            'swift_code': (str, none_type, none_type),  # noqa: E501\n            'account_type': (str, none_type, none_type),  # noqa: E501\n            'account_details': (str, none_type, none_type),  # noqa: E501\n            'currency': (bool, date, datetime, dict, float, int, list, str, none_type, none_type),  # noqa: E501\n            'token_id': (str, none_type),  # noqa: E501\n            'payment_code': (str, none_type),  # noqa: E501\n            'expires_at': (str, none_type, none_type),  # noqa: E501\n            'qr_string': (str, none_type),  # noqa: E501\n            'account_id': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'account_number': 'account_number',  # noqa: E501\n        'account_holder_name': 'account_holder_name',  # noqa: E501\n        'swift_code': 'swift_code',  # noqa: E501\n        'account_type': 'account_type',  # noqa: E501\n        'account_details': 'account_details',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'token_id': 'token_id',  # noqa: E501\n        'payment_code': 'payment_code',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n        'qr_string': 'qr_string',  # noqa: E501\n        'account_id': 'account_id',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"IdentityAccountResponseProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_number (str): Unique account identifier as per the bank records.. [optional]  # noqa: E501\n            account_holder_name (str, none_type): Name of account holder as per the cardless credit account.. [optional]  # noqa: E501\n            swift_code (str, none_type): The SWIFT code for international payments. [optional]  # noqa: E501\n            account_type (str, none_type): Free text account type, e.g., Savings, Transaction, Virtual Account.. [optional]  # noqa: E501\n            account_details (str, none_type): Potentially masked account detail, for display purposes only.. [optional]  # noqa: E501\n            currency (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n            token_id (str): The token id returned in tokenisation. [optional]  # noqa: E501\n            payment_code (str): Complete fixed payment code (including prefix). [optional]  # noqa: E501\n            expires_at (str, none_type): YYYY-MM-DD string with expiry date for the payment code. [optional]  # noqa: E501\n            qr_string (str): String representation of the QR Code image. [optional]  # noqa: E501\n            account_id (str): Alphanumeric string identifying this account. Usually an email address or phone number.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"IdentityAccountResponseProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_number (str): Unique account identifier as per the bank records.. [optional]  # noqa: E501\n            account_holder_name (str, none_type): Name of account holder as per the cardless credit account.. [optional]  # noqa: E501\n            swift_code (str, none_type): The SWIFT code for international payments. [optional]  # noqa: E501\n            account_type (str, none_type): Free text account type, e.g., Savings, Transaction, Virtual Account.. [optional]  # noqa: E501\n            account_details (str, none_type): Potentially masked account detail, for display purposes only.. [optional]  # noqa: E501\n            currency (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n            token_id (str): The token id returned in tokenisation. [optional]  # noqa: E501\n            payment_code (str): Complete fixed payment code (including prefix). [optional]  # noqa: E501\n            expires_at (str, none_type): YYYY-MM-DD string with expiry date for the payment code. [optional]  # noqa: E501\n            qr_string (str): String representation of the QR Code image. [optional]  # noqa: E501\n            account_id (str): Alphanumeric string identifying this account. Usually an email address or phone number.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n              AccountBank,\n              AccountCard,\n              AccountEwallet,\n              AccountOTC,\n              AccountPayLater,\n              AccountQRCode,\n          ],\n          'allOf': [\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      79,
      80,
      94,
      95,
      111,
      180,
      181,
      182,
      183,
      184,
      186,
      188,
      189,
      190,
      191,
      192,
      193,
      195,
      204,
      205,
      206,
      207,
      208,
      209,
      211,
      218,
      220,
      221,
      222,
      223,
      225,
      226,
      231,
      232,
      234,
      296,
      297,
      298,
      299,
      300,
      302,
      303,
      304,
      305,
      306,
      307,
      309,
      318,
      319,
      320,
      321,
      322,
      323,
      325,
      332,
      334,
      335,
      336,
      337,
      339,
      340,
      345,
      346,
      347,
      348,
      360,
      361
    ]
  },
  {
    "file_path": "xendit/customer/model/identity_account_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass IdentityAccountType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BANK_ACCOUNT': \"BANK_ACCOUNT\",\n            'EWALLET': \"EWALLET\",\n            'CREDIT_CARD': \"CREDIT_CARD\",\n            'PAY_LATER': \"PAY_LATER\",\n            'OTC': \"OTC\",\n            'QR_CODE': \"QR_CODE\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"IdentityAccountType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"BANK_ACCOUNT\", \"EWALLET\", \"CREDIT_CARD\", \"PAY_LATER\", \"OTC\", \"QR_CODE\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"BANK_ACCOUNT\", \"EWALLET\", \"CREDIT_CARD\", \"PAY_LATER\", \"OTC\", \"QR_CODE\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"IdentityAccountType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"BANK_ACCOUNT\", \"EWALLET\", \"CREDIT_CARD\", \"PAY_LATER\", \"OTC\", \"QR_CODE\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"BANK_ACCOUNT\", \"EWALLET\", \"CREDIT_CARD\", \"PAY_LATER\", \"OTC\", \"QR_CODE\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      80,
      86,
      147,
      149,
      150,
      151,
      152,
      153,
      155,
      161,
      162,
      163,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      243,
      245,
      247,
      248,
      249,
      250,
      251,
      253,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      271,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      300
    ]
  },
  {
    "file_path": "xendit/customer/model/individual_detail.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.country_code import CountryCode\nfrom xendit.customer.model.employment_detail import EmploymentDetail\nglobals()['CountryCode'] = CountryCode\nglobals()['EmploymentDetail'] = EmploymentDetail\n\ndef lazy_import():\n    pass\n\nclass IndividualDetail(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('gender',): {\n            'None': None,\n            'MALE': \"MALE\",\n            'FEMALE': \"FEMALE\",\n            'OTHER': \"OTHER\",\n        },\n    }\n\n    validations = {\n        ('given_names',): {\n            'max_length': 255,\n        },\n        ('given_names_non_roman',): {\n            'max_length': 255,\n        },\n        ('middle_name',): {\n            'max_length': 255,\n        },\n        ('surname',): {\n            'max_length': 255,\n        },\n        ('surname_non_roman',): {\n            'max_length': 255,\n        },\n        ('mother_maiden_name',): {\n            'max_length': 255,\n        },\n        ('date_of_birth',): {\n            'max_length': 30,\n        },\n        ('place_of_birth',): {\n            'max_length': 255,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'given_names': (str, none_type),  # noqa: E501\n            'given_names_non_roman': (str, none_type, none_type),  # noqa: E501\n            'middle_name': (str, none_type, none_type),  # noqa: E501\n            'surname': (str, none_type, none_type),  # noqa: E501\n            'surname_non_roman': (str, none_type, none_type),  # noqa: E501\n            'mother_maiden_name': (str, none_type, none_type),  # noqa: E501\n            'gender': (str, none_type, none_type),  # noqa: E501\n            'date_of_birth': (str, none_type, none_type),  # noqa: E501\n            'nationality': (CountryCode, none_type),  # noqa: E501\n            'place_of_birth': (str, none_type, none_type),  # noqa: E501\n            'employment': (EmploymentDetail, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'given_names': 'given_names',  # noqa: E501\n        'given_names_non_roman': 'given_names_non_roman',  # noqa: E501\n        'middle_name': 'middle_name',  # noqa: E501\n        'surname': 'surname',  # noqa: E501\n        'surname_non_roman': 'surname_non_roman',  # noqa: E501\n        'mother_maiden_name': 'mother_maiden_name',  # noqa: E501\n        'gender': 'gender',  # noqa: E501\n        'date_of_birth': 'date_of_birth',  # noqa: E501\n        'nationality': 'nationality',  # noqa: E501\n        'place_of_birth': 'place_of_birth',  # noqa: E501\n        'employment': 'employment',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"IndividualDetail - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            given_names (str): [optional]  # noqa: E501\n            given_names_non_roman (str, none_type): [optional]  # noqa: E501\n            middle_name (str, none_type): [optional]  # noqa: E501\n            surname (str, none_type): [optional]  # noqa: E501\n            surname_non_roman (str, none_type): [optional]  # noqa: E501\n            mother_maiden_name (str, none_type): [optional]  # noqa: E501\n            gender (str, none_type): [optional]  # noqa: E501\n            date_of_birth (str, none_type): [optional]  # noqa: E501\n            nationality (CountryCode): [optional]  # noqa: E501\n            place_of_birth (str, none_type): [optional]  # noqa: E501\n            employment (EmploymentDetail): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        given_names: str | None = None,\n        given_names_non_roman: str | None = None,\n        middle_name: str | None = None,\n        surname: str | None = None,\n        surname_non_roman: str | None = None,\n        mother_maiden_name: str | None = None,\n        gender: str | None = None,\n        date_of_birth: str | None = None,\n        nationality: str | None = None,\n        place_of_birth: str | None = None,\n        employment: EmploymentDetail | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"IndividualDetail - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            given_names (str): [optional]  # noqa: E501\n            given_names_non_roman (str, none_type): [optional]  # noqa: E501\n            middle_name (str, none_type): [optional]  # noqa: E501\n            surname (str, none_type): [optional]  # noqa: E501\n            surname_non_roman (str, none_type): [optional]  # noqa: E501\n            mother_maiden_name (str, none_type): [optional]  # noqa: E501\n            gender (str, none_type): [optional]  # noqa: E501\n            date_of_birth (str, none_type): [optional]  # noqa: E501\n            nationality (CountryCode): [optional]  # noqa: E501\n            place_of_birth (str, none_type): [optional]  # noqa: E501\n            employment (EmploymentDetail): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if given_names is not None:\n            self.given_names = given_names\n        if given_names_non_roman is not None:\n            self.given_names_non_roman = given_names_non_roman\n        if middle_name is not None:\n            self.middle_name = middle_name\n        if surname is not None:\n            self.surname = surname\n        if surname_non_roman is not None:\n            self.surname_non_roman = surname_non_roman\n        if mother_maiden_name is not None:\n            self.mother_maiden_name = mother_maiden_name\n        if gender is not None:\n            self.gender = gender\n        if date_of_birth is not None:\n            self.date_of_birth = date_of_birth\n        if nationality is not None:\n            self.nationality = nationality\n        if place_of_birth is not None:\n            self.place_of_birth = place_of_birth\n        if employment is not None:\n            self.employment = employment\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      101,
      102,
      116,
      117,
      133,
      204,
      205,
      206,
      207,
      208,
      210,
      212,
      213,
      214,
      215,
      216,
      217,
      219,
      228,
      229,
      230,
      231,
      232,
      233,
      235,
      236,
      241,
      242,
      243,
      316,
      317,
      318,
      319,
      320,
      322,
      323,
      324,
      325,
      326,
      327,
      329,
      338,
      339,
      340,
      341,
      342,
      343,
      345,
      346,
      347,
      348,
      349,
      350,
      351,
      352,
      353,
      354,
      355,
      356,
      357,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      368,
      373,
      374,
      375,
      376
    ]
  },
  {
    "file_path": "xendit/customer/model/kyc_document_request.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.country_code import CountryCode\nfrom xendit.customer.model.kyc_document_sub_type import KYCDocumentSubType\nfrom xendit.customer.model.kyc_document_type import KYCDocumentType\nglobals()['CountryCode'] = CountryCode\nglobals()['KYCDocumentSubType'] = KYCDocumentSubType\nglobals()['KYCDocumentType'] = KYCDocumentType\n\ndef lazy_import():\n    pass\n\nclass KYCDocumentRequest(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'country': (CountryCode, none_type),  # noqa: E501\n            'type': (KYCDocumentType, none_type),  # noqa: E501\n            'sub_type': (KYCDocumentSubType, none_type),  # noqa: E501\n            'document_name': (str, none_type),  # noqa: E501\n            'document_number': (str, none_type),  # noqa: E501\n            'expires_at': (str, none_type),  # noqa: E501\n            'holder_name': (str, none_type),  # noqa: E501\n            'document_images': ([str], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'country': 'country',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'sub_type': 'sub_type',  # noqa: E501\n        'document_name': 'document_name',  # noqa: E501\n        'document_number': 'document_number',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n        'holder_name': 'holder_name',  # noqa: E501\n        'document_images': 'document_images',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"KYCDocumentRequest - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            country (CountryCode): [optional]  # noqa: E501\n            type (KYCDocumentType): [optional]  # noqa: E501\n            sub_type (KYCDocumentSubType): [optional]  # noqa: E501\n            document_name (str): [optional]  # noqa: E501\n            document_number (str): [optional]  # noqa: E501\n            expires_at (str): [optional]  # noqa: E501\n            holder_name (str): [optional]  # noqa: E501\n            document_images ([str]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        country: str | None = None,\n        type: KYCDocumentType | None = None,\n        sub_type: KYCDocumentSubType | None = None,\n        document_name: str | None = None,\n        document_number: str | None = None,\n        expires_at: str | None = None,\n        holder_name: str | None = None,\n        document_images: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"KYCDocumentRequest - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            country (CountryCode): [optional]  # noqa: E501\n            type (KYCDocumentType): [optional]  # noqa: E501\n            sub_type (KYCDocumentSubType): [optional]  # noqa: E501\n            document_name (str): [optional]  # noqa: E501\n            document_number (str): [optional]  # noqa: E501\n            expires_at (str): [optional]  # noqa: E501\n            holder_name (str): [optional]  # noqa: E501\n            document_images ([str]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if country is not None:\n            self.country = country\n        if type is not None:\n            self.type = type\n        if sub_type is not None:\n            self.sub_type = sub_type\n        if document_name is not None:\n            self.document_name = document_name\n        if document_number is not None:\n            self.document_number = document_number\n        if expires_at is not None:\n            self.expires_at = expires_at\n        if holder_name is not None:\n            self.holder_name = holder_name\n        if document_images is not None:\n            self.document_images = document_images\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      73,
      74,
      88,
      89,
      102,
      167,
      168,
      169,
      170,
      171,
      173,
      175,
      176,
      177,
      178,
      179,
      180,
      182,
      191,
      192,
      193,
      194,
      195,
      196,
      198,
      199,
      204,
      205,
      206,
      273,
      274,
      275,
      276,
      277,
      279,
      280,
      281,
      282,
      283,
      284,
      286,
      295,
      296,
      297,
      298,
      299,
      300,
      302,
      303,
      304,
      305,
      306,
      307,
      308,
      309,
      310,
      311,
      312,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      324,
      325,
      326,
      327
    ]
  },
  {
    "file_path": "xendit/customer/model/kyc_document_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass KYCDocumentResponse(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'country': (bool, date, datetime, dict, float, int, list, str, none_type,),  # noqa: E501\n            'type': (bool, date, datetime, dict, float, int, list, str, none_type,),  # noqa: E501\n            'sub_type': (bool, date, datetime, dict, float, int, list, str, none_type,),  # noqa: E501\n            'document_name': (str, none_type,),  # noqa: E501\n            'document_number': (str, none_type,),  # noqa: E501\n            'expires_at': (str, none_type,),  # noqa: E501\n            'holder_name': (str, none_type,),  # noqa: E501\n            'document_images': ([str], none_type,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'country': 'country',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'sub_type': 'sub_type',  # noqa: E501\n        'document_name': 'document_name',  # noqa: E501\n        'document_number': 'document_number',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n        'holder_name': 'holder_name',  # noqa: E501\n        'document_images': 'document_images',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, country, type, sub_type, document_name, document_number, expires_at, holder_name, document_images, *args, **kwargs):  # noqa: E501\n        \"\"\"KYCDocumentResponse - a model defined in OpenAPI\n\n        Args:\n            country (bool, date, datetime, dict, float, int, list, str, none_type):\n            type (bool, date, datetime, dict, float, int, list, str, none_type):\n            sub_type (bool, date, datetime, dict, float, int, list, str, none_type):\n            document_name (str, none_type):\n            document_number (str, none_type):\n            expires_at (str, none_type):\n            holder_name (str, none_type):\n            document_images ([str], none_type):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.country = country\n        self.type = type\n        self.sub_type = sub_type\n        self.document_name = document_name\n        self.document_number = document_number\n        self.expires_at = expires_at\n        self.holder_name = holder_name\n        self.document_images = document_images\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        country: object,\n        type: object,\n        sub_type: object,\n        document_name: str | None,\n        document_number: str | None,\n        expires_at: str | None,\n        holder_name: str | None,\n        document_images: list | None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"KYCDocumentResponse - a model defined in OpenAPI\n\n        Args:\n            country (bool, date, datetime, dict, float, int, list, str, none_type):\n            type (bool, date, datetime, dict, float, int, list, str, none_type):\n            sub_type (bool, date, datetime, dict, float, int, list, str, none_type):\n            document_name (str, none_type):\n            document_number (str, none_type):\n            expires_at (str, none_type):\n            holder_name (str, none_type):\n            document_images ([str], none_type):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.country = country\n        self.type = type\n        self.sub_type = sub_type\n        self.document_name = document_name\n        self.document_number = document_number\n        self.expires_at = expires_at\n        self.holder_name = holder_name\n        self.document_images = document_images\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      94,
      161,
      162,
      163,
      164,
      165,
      167,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      185,
      186,
      187,
      188,
      189,
      190,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      206,
      207,
      208,
      277,
      278,
      279,
      280,
      281,
      283,
      284,
      285,
      286,
      287,
      288,
      290,
      299,
      300,
      301,
      302,
      303,
      304,
      306,
      307,
      308,
      309,
      310,
      311,
      312,
      313,
      314,
      315,
      320,
      321,
      322,
      323
    ]
  },
  {
    "file_path": "xendit/customer/model/kyc_document_sub_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass KYCDocumentSubType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'None': None,\n            'NATIONAL_ID': \"NATIONAL_ID\",\n            'CONSULAR_ID': \"CONSULAR_ID\",\n            'VOTER_ID': \"VOTER_ID\",\n            'POSTAL_ID': \"POSTAL_ID\",\n            'RESIDENCE_PERMIT': \"RESIDENCE_PERMIT\",\n            'TAX_ID': \"TAX_ID\",\n            'STUDENT_ID': \"STUDENT_ID\",\n            'MILITARY_ID': \"MILITARY_ID\",\n            'MEDICAL_ID': \"MEDICAL_ID\",\n            'OTHERS': \"OTHERS\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"KYCDocumentSubType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"NATIONAL_ID\", \"CONSULAR_ID\", \"VOTER_ID\", \"POSTAL_ID\", \"RESIDENCE_PERMIT\", \"TAX_ID\", \"STUDENT_ID\", \"MILITARY_ID\", \"MEDICAL_ID\", \"OTHERS\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"NATIONAL_ID\", \"CONSULAR_ID\", \"VOTER_ID\", \"POSTAL_ID\", \"RESIDENCE_PERMIT\", \"TAX_ID\", \"STUDENT_ID\", \"MILITARY_ID\", \"MEDICAL_ID\", \"OTHERS\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"KYCDocumentSubType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"NATIONAL_ID\", \"CONSULAR_ID\", \"VOTER_ID\", \"POSTAL_ID\", \"RESIDENCE_PERMIT\", \"TAX_ID\", \"STUDENT_ID\", \"MILITARY_ID\", \"MEDICAL_ID\", \"OTHERS\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"NATIONAL_ID\", \"CONSULAR_ID\", \"VOTER_ID\", \"POSTAL_ID\", \"RESIDENCE_PERMIT\", \"TAX_ID\", \"STUDENT_ID\", \"MILITARY_ID\", \"MEDICAL_ID\", \"OTHERS\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      85,
      91,
      152,
      154,
      155,
      156,
      157,
      158,
      160,
      166,
      167,
      168,
      169,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      248,
      250,
      252,
      253,
      254,
      255,
      256,
      258,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      276,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      294,
      295,
      296,
      305
    ]
  },
  {
    "file_path": "xendit/customer/model/kyc_document_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass KYCDocumentType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BIRTH_CERTIFICATE': \"BIRTH_CERTIFICATE\",\n            'BANK_STATEMENT': \"BANK_STATEMENT\",\n            'DRIVING_LICENSE': \"DRIVING_LICENSE\",\n            'IDENTITY_CARD': \"IDENTITY_CARD\",\n            'PASSPORT': \"PASSPORT\",\n            'VISA': \"VISA\",\n            'BUSINESS_REGISTRATION': \"BUSINESS_REGISTRATION\",\n            'BUSINESS_LICENSE': \"BUSINESS_LICENSE\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"KYCDocumentType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"BIRTH_CERTIFICATE\", \"BANK_STATEMENT\", \"DRIVING_LICENSE\", \"IDENTITY_CARD\", \"PASSPORT\", \"VISA\", \"BUSINESS_REGISTRATION\", \"BUSINESS_LICENSE\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"BIRTH_CERTIFICATE\", \"BANK_STATEMENT\", \"DRIVING_LICENSE\", \"IDENTITY_CARD\", \"PASSPORT\", \"VISA\", \"BUSINESS_REGISTRATION\", \"BUSINESS_LICENSE\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"KYCDocumentType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"BIRTH_CERTIFICATE\", \"BANK_STATEMENT\", \"DRIVING_LICENSE\", \"IDENTITY_CARD\", \"PASSPORT\", \"VISA\", \"BUSINESS_REGISTRATION\", \"BUSINESS_LICENSE\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"BIRTH_CERTIFICATE\", \"BANK_STATEMENT\", \"DRIVING_LICENSE\", \"IDENTITY_CARD\", \"PASSPORT\", \"VISA\", \"BUSINESS_REGISTRATION\", \"BUSINESS_LICENSE\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      82,
      88,
      149,
      151,
      152,
      153,
      154,
      155,
      157,
      163,
      164,
      165,
      166,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      245,
      247,
      249,
      250,
      251,
      252,
      253,
      255,
      261,
      262,
      263,
      264,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      302
    ]
  },
  {
    "file_path": "xendit/customer/model/patch_customer.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.address_request import AddressRequest\nfrom xendit.customer.model.business_detail import BusinessDetail\nfrom xendit.customer.model.end_customer_status import EndCustomerStatus\nfrom xendit.customer.model.identity_account_request import IdentityAccountRequest\nfrom xendit.customer.model.individual_detail import IndividualDetail\nfrom xendit.customer.model.kyc_document_request import KYCDocumentRequest\nglobals()['AddressRequest'] = AddressRequest\nglobals()['BusinessDetail'] = BusinessDetail\nglobals()['EndCustomerStatus'] = EndCustomerStatus\nglobals()['IdentityAccountRequest'] = IdentityAccountRequest\nglobals()['IndividualDetail'] = IndividualDetail\nglobals()['KYCDocumentRequest'] = KYCDocumentRequest\n\ndef lazy_import():\n    pass\n\nclass PatchCustomer(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('reference_id',): {\n            'max_length': 255,\n        },\n        ('description',): {\n            'max_length': 1000,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'client_name': (str, none_type, none_type),  # noqa: E501\n            'reference_id': (str, none_type, none_type),  # noqa: E501\n            'individual_detail': (IndividualDetail, none_type),  # noqa: E501\n            'business_detail': (BusinessDetail, none_type),  # noqa: E501\n            'description': (str, none_type, none_type),  # noqa: E501\n            'email': (str, none_type, none_type),  # noqa: E501\n            'mobile_number': (str, none_type, none_type),  # noqa: E501\n            'phone_number': (str, none_type, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n            'addresses': ([AddressRequest], none_type, none_type),  # noqa: E501\n            'identity_accounts': ([IdentityAccountRequest], none_type, none_type),  # noqa: E501\n            'kyc_documents': ([KYCDocumentRequest], none_type, none_type),  # noqa: E501\n            'status': (EndCustomerStatus, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'client_name': 'client_name',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'individual_detail': 'individual_detail',  # noqa: E501\n        'business_detail': 'business_detail',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'email': 'email',  # noqa: E501\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'phone_number': 'phone_number',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n        'addresses': 'addresses',  # noqa: E501\n        'identity_accounts': 'identity_accounts',  # noqa: E501\n        'kyc_documents': 'kyc_documents',  # noqa: E501\n        'status': 'status',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"PatchCustomer - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            client_name (str, none_type): Entity's name for this client. [optional]  # noqa: E501\n            reference_id (str, none_type): Merchant's reference of this end customer, eg Merchant's user's id. Must be unique.. [optional]  # noqa: E501\n            individual_detail (IndividualDetail): [optional]  # noqa: E501\n            business_detail (BusinessDetail): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            email (str, none_type): [optional]  # noqa: E501\n            mobile_number (str, none_type): [optional]  # noqa: E501\n            phone_number (str, none_type): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            addresses ([AddressRequest], none_type): [optional]  # noqa: E501\n            identity_accounts ([IdentityAccountRequest], none_type): [optional]  # noqa: E501\n            kyc_documents ([KYCDocumentRequest], none_type): [optional]  # noqa: E501\n            status (EndCustomerStatus): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        client_name: str | None = None,\n        reference_id: str | None = None,\n        individual_detail: IndividualDetail | None = None,\n        business_detail: BusinessDetail | None = None,\n        description: str | None = None,\n        email: str | None = None,\n        mobile_number: str | None = None,\n        phone_number: str | None = None,\n        metadata: dict | None = None,\n        addresses: list | None = None,\n        identity_accounts: list | None = None,\n        kyc_documents: list | None = None,\n        status: EndCustomerStatus | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PatchCustomer - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            client_name (str, none_type): Entity's name for this client. [optional]  # noqa: E501\n            reference_id (str, none_type): Merchant's reference of this end customer, eg Merchant's user's id. Must be unique.. [optional]  # noqa: E501\n            individual_detail (IndividualDetail): [optional]  # noqa: E501\n            business_detail (BusinessDetail): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            email (str, none_type): [optional]  # noqa: E501\n            mobile_number (str, none_type): [optional]  # noqa: E501\n            phone_number (str, none_type): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            addresses ([AddressRequest], none_type): [optional]  # noqa: E501\n            identity_accounts ([IdentityAccountRequest], none_type): [optional]  # noqa: E501\n            kyc_documents ([KYCDocumentRequest], none_type): [optional]  # noqa: E501\n            status (EndCustomerStatus): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if client_name is not None:\n            self.client_name = client_name\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if individual_detail is not None:\n            self.individual_detail = individual_detail\n        if business_detail is not None:\n            self.business_detail = business_detail\n        if description is not None:\n            self.description = description\n        if email is not None:\n            self.email = email\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if phone_number is not None:\n            self.phone_number = phone_number\n        if metadata is not None:\n            self.metadata = metadata\n        if addresses is not None:\n            self.addresses = addresses\n        if identity_accounts is not None:\n            self.identity_accounts = identity_accounts\n        if kyc_documents is not None:\n            self.kyc_documents = kyc_documents\n        if status is not None:\n            self.status = status\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      85,
      86,
      100,
      101,
      119,
      194,
      195,
      196,
      197,
      198,
      200,
      202,
      203,
      204,
      205,
      206,
      207,
      209,
      218,
      219,
      220,
      221,
      222,
      223,
      225,
      226,
      231,
      232,
      233,
      310,
      311,
      312,
      313,
      314,
      316,
      317,
      318,
      319,
      320,
      321,
      323,
      332,
      333,
      334,
      335,
      336,
      337,
      339,
      340,
      341,
      342,
      343,
      344,
      345,
      346,
      347,
      348,
      349,
      350,
      351,
      352,
      353,
      354,
      355,
      356,
      357,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      371,
      372,
      373,
      374
    ]
  },
  {
    "file_path": "xendit/customer/model/response_data_not_found.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ResponseDataNotFound(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'DATA_NOT_FOUND': \"DATA_NOT_FOUND\",\n            'ENTITY_NOT_FOUND_ERROR': \"ENTITY_NOT_FOUND_ERROR\",\n            'CLIENT_NOT_FOUND_ERROR': \"CLIENT_NOT_FOUND_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (bool, date, datetime, dict, float, int, list, str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"ResponseDataNotFound - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: object | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ResponseDataNotFound - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      72,
      86,
      93,
      146,
      147,
      148,
      149,
      150,
      152,
      154,
      155,
      156,
      157,
      158,
      159,
      161,
      170,
      171,
      172,
      173,
      174,
      175,
      177,
      178,
      183,
      184,
      185,
      240,
      241,
      242,
      243,
      244,
      246,
      247,
      248,
      249,
      250,
      251,
      253,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      279,
      280,
      281,
      282
    ]
  },
  {
    "file_path": "xendit/customer/model/update_customer400_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.customer.model.error import Error\nfrom xendit.customer.model.update_customer400_response_all_of import UpdateCustomer400ResponseAllOf\nglobals()['Error'] = Error\nglobals()['UpdateCustomer400ResponseAllOf'] = UpdateCustomer400ResponseAllOf\n\ndef lazy_import():\n    pass\n\nclass UpdateCustomer400Response(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'ENTITY_NOT_FOUND_ERROR': \"ENTITY_NOT_FOUND_ERROR\",\n            'CLIENT_NOT_FOUND_ERROR': \"CLIENT_NOT_FOUND_ERROR\",\n            'END_CUSTOMER_NOT_FOUND_ERROR': \"END_CUSTOMER_NOT_FOUND_ERROR\",\n            'DUPLICATE_END_CUSTOMER_ERROR': \"DUPLICATE_END_CUSTOMER_ERROR\",\n            'API_VALIDATION_ERROR': \"API_VALIDATION_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'error_code': (str,),  # noqa: E501\n            'message': (bool, date, datetime, dict, float, int, list, str, none_type,),  # noqa: E501\n            'errors': ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n        'errors': 'errors',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"UpdateCustomer400Response - a model defined in OpenAPI\n\n        Keyword Args:\n            error_code (str):\n            message (bool, date, datetime, dict, float, int, list, str, none_type):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            errors ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"UpdateCustomer400Response - a model defined in OpenAPI\n\n        Keyword Args:\n            error_code (str):\n            message (bool, date, datetime, dict, float, int, list, str, none_type):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            errors ([{str: (bool, date, datetime, dict, float, int, list, str, none_type)}]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              Error,\n              UpdateCustomer400ResponseAllOf,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      78,
      79,
      93,
      94,
      102,
      155,
      156,
      157,
      158,
      159,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      186,
      193,
      195,
      196,
      197,
      198,
      200,
      201,
      206,
      207,
      209,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      276,
      285,
      286,
      287,
      288,
      289,
      290,
      292,
      299,
      301,
      302,
      303,
      304,
      306,
      307,
      312,
      313,
      314,
      315,
      327,
      328
    ]
  },
  {
    "file_path": "xendit/customer/model/update_customer400_response_all_of.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass UpdateCustomer400ResponseAllOf(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'ENTITY_NOT_FOUND_ERROR': \"ENTITY_NOT_FOUND_ERROR\",\n            'CLIENT_NOT_FOUND_ERROR': \"CLIENT_NOT_FOUND_ERROR\",\n            'END_CUSTOMER_NOT_FOUND_ERROR': \"END_CUSTOMER_NOT_FOUND_ERROR\",\n            'DUPLICATE_END_CUSTOMER_ERROR': \"DUPLICATE_END_CUSTOMER_ERROR\",\n            'API_VALIDATION_ERROR': \"API_VALIDATION_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (bool, date, datetime, dict, float, int, list, str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"UpdateCustomer400ResponseAllOf - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: object | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"UpdateCustomer400ResponseAllOf - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (bool, date, datetime, dict, float, int, list, str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      74,
      88,
      95,
      148,
      149,
      150,
      151,
      152,
      154,
      156,
      157,
      158,
      159,
      160,
      161,
      163,
      172,
      173,
      174,
      175,
      176,
      177,
      179,
      180,
      185,
      186,
      187,
      242,
      243,
      244,
      245,
      246,
      248,
      249,
      250,
      251,
      252,
      253,
      255,
      264,
      265,
      266,
      267,
      268,
      269,
      271,
      272,
      273,
      274,
      275,
      276,
      281,
      282,
      283,
      284
    ]
  },
  {
    "file_path": "xendit/invoice/invoice_api.py",
    "code": "\"\"\"\n    xendit-invoice-service\n\n    xendit-invoice-service descriptions  # noqa: E501\n\n    The version of the OpenAPI document: 1.9.0\n\"\"\"\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\n\nfrom xendit.api_client import ApiClient, Endpoint as _Endpoint\nfrom xendit.model_utils import (  # noqa: F401\n    check_allowed_values,\n    check_validations,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_and_convert_types\n)\nfrom typing import Optional, List # noqa: F401\n\nfrom xendit.invoice.model import *  # noqa: F401,E501\n\nclass InvoiceApi(object):\n    \"\"\"NOTE: This class is auto generated by the OpenAPI Generator.\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None):\n        if api_client is None:\n            api_client = ApiClient()\n        self.api_client = api_client\n        self.create_invoice_endpoint = _Endpoint(\n            settings={\n                'response_type': (Invoice,),\n                'auth': [],\n                'endpoint_path': '/v2/invoices/',\n                'operation_id': 'create_invoice',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'create_invoice_request',\n                    'for_user_id',\n                ],\n                'required': [\n                    'create_invoice_request',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'create_invoice_request':\n                        (CreateInvoiceRequest,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'create_invoice_request': 'body',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n        self.get_invoice_by_id_endpoint = _Endpoint(\n            settings={\n                'response_type': (Invoice,),\n                'auth': [],\n                'endpoint_path': '/v2/invoices/{invoice_id}',\n                'operation_id': 'get_invoice_by_id',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'invoice_id',\n                    'for_user_id',\n                ],\n                'required': [\n                    'invoice_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'invoice_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'invoice_id': 'invoice_id',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'invoice_id': 'path',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.get_invoices_endpoint = _Endpoint(\n            settings={\n                'response_type': ([Invoice],),\n                'auth': [],\n                'endpoint_path': '/v2/invoices',\n                'operation_id': 'get_invoices',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'for_user_id',\n                    'external_id',\n                    'statuses',\n                    'limit',\n                    'created_after',\n                    'created_before',\n                    'paid_after',\n                    'paid_before',\n                    'expired_after',\n                    'expired_before',\n                    'last_invoice',\n                    'client_types',\n                    'payment_channels',\n                    'on_demand_link',\n                    'recurring_payment_id',\n                ],\n                'required': [],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'for_user_id':\n                        (str,),\n                    'external_id':\n                        (str,),\n                    'statuses':\n                        ([InvoiceStatus],),\n                    'limit':\n                        (float,),\n                    'created_after':\n                        (datetime,),\n                    'created_before':\n                        (datetime,),\n                    'paid_after':\n                        (datetime,),\n                    'paid_before':\n                        (datetime,),\n                    'expired_after':\n                        (datetime,),\n                    'expired_before':\n                        (datetime,),\n                    'last_invoice':\n                        (str,),\n                    'client_types':\n                        ([InvoiceClientType],),\n                    'payment_channels':\n                        ([str],),\n                    'on_demand_link':\n                        (str,),\n                    'recurring_payment_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'for_user_id': 'for-user-id',\n                    'external_id': 'external_id',\n                    'statuses': 'statuses',\n                    'limit': 'limit',\n                    'created_after': 'created_after',\n                    'created_before': 'created_before',\n                    'paid_after': 'paid_after',\n                    'paid_before': 'paid_before',\n                    'expired_after': 'expired_after',\n                    'expired_before': 'expired_before',\n                    'last_invoice': 'last_invoice',\n                    'client_types': 'client_types',\n                    'payment_channels': 'payment_channels',\n                    'on_demand_link': 'on_demand_link',\n                    'recurring_payment_id': 'recurring_payment_id',\n                },\n                'location_map': {\n                    'for_user_id': 'header',\n                    'external_id': 'query',\n                    'statuses': 'query',\n                    'limit': 'query',\n                    'created_after': 'query',\n                    'created_before': 'query',\n                    'paid_after': 'query',\n                    'paid_before': 'query',\n                    'expired_after': 'query',\n                    'expired_before': 'query',\n                    'last_invoice': 'query',\n                    'client_types': 'query',\n                    'payment_channels': 'query',\n                    'on_demand_link': 'query',\n                    'recurring_payment_id': 'query',\n                },\n                'collection_format_map': {\n                    'statuses': 'multi',\n                    'client_types': 'multi',\n                    'payment_channels': 'multi',\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.expire_invoice_endpoint = _Endpoint(\n            settings={\n                'response_type': (Invoice,),\n                'auth': [],\n                'endpoint_path': '/invoices/{invoice_id}/expire!',\n                'operation_id': 'expire_invoice',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'invoice_id',\n                    'for_user_id',\n                ],\n                'required': [\n                    'invoice_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'invoice_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'invoice_id': 'invoice_id',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'invoice_id': 'path',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n\n    def create_invoice(\n        self,\n        create_invoice_request: CreateInvoiceRequest,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> Invoice:\n        \"\"\"Create an invoice  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.create_invoice(create_invoice_request, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            create_invoice_request (CreateInvoiceRequest):\n\n        Keyword Args:\n            for_user_id (str): Business ID of the sub-account merchant (XP feature). [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            Invoice\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['create_invoice_request'] = create_invoice_request\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.create_invoice_endpoint.call_with_http_info(**kwargs)\n\n    def get_invoice_by_id(\n        self,\n        invoice_id: str,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> Invoice:\n        \"\"\"Get invoice by invoice id  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_invoice_by_id(invoice_id, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            invoice_id (str): Invoice ID\n\n        Keyword Args:\n            for_user_id (str): Business ID of the sub-account merchant (XP feature). [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            Invoice\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['invoice_id'] = invoice_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.get_invoice_by_id_endpoint.call_with_http_info(**kwargs)\n\n    def get_invoices(\n        self,\n        for_user_id: Optional[str] = None,\n        external_id: Optional[str] = None,\n        statuses: Optional[List[InvoiceStatus]] = None,\n        limit: Optional[float] = None,\n        created_after: Optional[datetime] = None,\n        created_before: Optional[datetime] = None,\n        paid_after: Optional[datetime] = None,\n        paid_before: Optional[datetime] = None,\n        expired_after: Optional[datetime] = None,\n        expired_before: Optional[datetime] = None,\n        last_invoice: Optional[str] = None,\n        client_types: Optional[List[InvoiceClientType]] = None,\n        payment_channels: Optional[List[str]] = None,\n        on_demand_link: Optional[str] = None,\n        recurring_payment_id: Optional[str] = None,\n        **kwargs\n    ) -> [Invoice]:\n        \"\"\"Get all Invoices  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_invoices(for_user_id, external_id, statuses, limit, created_after, created_before, paid_after, paid_before, expired_after, expired_before, last_invoice, client_types, payment_channels, on_demand_link, recurring_payment_id, async_req=True)\n        >>> result = thread.get()\n\n\n        Keyword Args:\n            for_user_id (str): Business ID of the sub-account merchant (XP feature). [optional]\n            external_id (str): [optional]\n            statuses ([InvoiceStatus]): [optional]\n            limit (float): [optional]\n            created_after (datetime): [optional]\n            created_before (datetime): [optional]\n            paid_after (datetime): [optional]\n            paid_before (datetime): [optional]\n            expired_after (datetime): [optional]\n            expired_before (datetime): [optional]\n            last_invoice (str): [optional]\n            client_types ([InvoiceClientType]): [optional]\n            payment_channels ([str]): [optional]\n            on_demand_link (str): [optional]\n            recurring_payment_id (str): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            [Invoice]\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if external_id is not None:\n            kwargs['external_id'] = external_id\n        if statuses is not None:\n            kwargs['statuses'] = statuses\n        if limit is not None:\n            kwargs['limit'] = limit\n        if created_after is not None:\n            kwargs['created_after'] = created_after\n        if created_before is not None:\n            kwargs['created_before'] = created_before\n        if paid_after is not None:\n            kwargs['paid_after'] = paid_after\n        if paid_before is not None:\n            kwargs['paid_before'] = paid_before\n        if expired_after is not None:\n            kwargs['expired_after'] = expired_after\n        if expired_before is not None:\n            kwargs['expired_before'] = expired_before\n        if last_invoice is not None:\n            kwargs['last_invoice'] = last_invoice\n        if client_types is not None:\n            kwargs['client_types'] = client_types\n        if payment_channels is not None:\n            kwargs['payment_channels'] = payment_channels\n        if on_demand_link is not None:\n            kwargs['on_demand_link'] = on_demand_link\n        if recurring_payment_id is not None:\n            kwargs['recurring_payment_id'] = recurring_payment_id\n        return self.get_invoices_endpoint.call_with_http_info(**kwargs)\n\n    def expire_invoice(\n        self,\n        invoice_id: str,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> Invoice:\n        \"\"\"Manually expire an invoice  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.expire_invoice(invoice_id, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            invoice_id (str): Invoice ID to be expired\n\n        Keyword Args:\n            for_user_id (str): Business ID of the sub-account merchant (XP feature). [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            Invoice\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['invoice_id'] = invoice_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.expire_invoice_endpoint.call_with_http_info(**kwargs)\n\n",
    "uncovered_lines": [
      33,
      401,
      486,
      569,
      572,
      575,
      578,
      581,
      584,
      587,
      590,
      592,
      593,
      594,
      595,
      596,
      597,
      598,
      599,
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      609,
      610,
      611,
      612,
      613,
      614,
      615,
      616,
      617,
      618,
      619,
      620,
      621,
      622,
      623,
      624,
      681,
      684,
      687,
      690,
      693,
      696,
      699,
      702,
      704,
      705,
      706,
      707,
      708,
      709
    ]
  },
  {
    "file_path": "xendit/invoice/model/address_object.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass AddressObject(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'country': (str, none_type, none_type),  # noqa: E501\n            'street_line1': (str, none_type, none_type),  # noqa: E501\n            'street_line2': (str, none_type, none_type),  # noqa: E501\n            'city': (str, none_type, none_type),  # noqa: E501\n            'province': (str, none_type, none_type),  # noqa: E501\n            'state': (str, none_type, none_type),  # noqa: E501\n            'postal_code': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'country': 'country',  # noqa: E501\n        'street_line1': 'street_line1',  # noqa: E501\n        'street_line2': 'street_line2',  # noqa: E501\n        'city': 'city',  # noqa: E501\n        'province': 'province',  # noqa: E501\n        'state': 'state',  # noqa: E501\n        'postal_code': 'postal_code',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"AddressObject - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            country (str, none_type): The country where the address is located.. [optional]  # noqa: E501\n            street_line1 (str, none_type): The first line of the street address.. [optional]  # noqa: E501\n            street_line2 (str, none_type): The second line of the street address.. [optional]  # noqa: E501\n            city (str, none_type): The city or locality within the address.. [optional]  # noqa: E501\n            province (str, none_type): The province or region within the country.. [optional]  # noqa: E501\n            state (str, none_type): The state or administrative division within the country.. [optional]  # noqa: E501\n            postal_code (str, none_type): The postal code or ZIP code for the address.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        country: str | None = None,\n        street_line1: str | None = None,\n        street_line2: str | None = None,\n        city: str | None = None,\n        province: str | None = None,\n        state: str | None = None,\n        postal_code: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"AddressObject - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            country (str, none_type): The country where the address is located.. [optional]  # noqa: E501\n            street_line1 (str, none_type): The first line of the street address.. [optional]  # noqa: E501\n            street_line2 (str, none_type): The second line of the street address.. [optional]  # noqa: E501\n            city (str, none_type): The city or locality within the address.. [optional]  # noqa: E501\n            province (str, none_type): The province or region within the country.. [optional]  # noqa: E501\n            state (str, none_type): The state or administrative division within the country.. [optional]  # noqa: E501\n            postal_code (str, none_type): The postal code or ZIP code for the address.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if country is not None:\n            self.country = country\n        if street_line1 is not None:\n            self.street_line1 = street_line1\n        if street_line2 is not None:\n            self.street_line2 = street_line2\n        if city is not None:\n            self.city = city\n        if province is not None:\n            self.province = province\n        if state is not None:\n            self.state = state\n        if postal_code is not None:\n            self.postal_code = postal_code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      93,
      156,
      157,
      158,
      159,
      160,
      162,
      164,
      165,
      166,
      167,
      168,
      169,
      171,
      180,
      181,
      182,
      183,
      184,
      185,
      187,
      188,
      193,
      194,
      195,
      260,
      261,
      262,
      263,
      264,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      282,
      283,
      284,
      285,
      286,
      287,
      289,
      290,
      291,
      292,
      293,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      309,
      310,
      311,
      312
    ]
  },
  {
    "file_path": "xendit/invoice/model/alternative_display_item.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass AlternativeDisplayItem(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'type': (str, none_type),  # noqa: E501\n            'value': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'type': 'type',  # noqa: E501\n        'value': 'value',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"AlternativeDisplayItem - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            type (str): Represent type of alternative display.. [optional]  # noqa: E501\n            value (str): Represent value of alternative display value.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        type: str | None = None,\n        value: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"AlternativeDisplayItem - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            type (str): Represent type of alternative display.. [optional]  # noqa: E501\n            value (str): Represent value of alternative display value.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if type is not None:\n            self.type = type\n        if value is not None:\n            self.value = value\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/invoice/model/bad_request_error.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass BadRequestError(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'MAXIMUM_TRANSFER_AMOUNT_ERROR': \"MAXIMUM_TRANSFER_AMOUNT_ERROR\",\n            'NO_COLLECTION_METHODS_ERROR': \"NO_COLLECTION_METHODS_ERROR\",\n            'EMAIL_FORMAT_ERROR': \"EMAIL_FORMAT_ERROR\",\n            'UNAVAILABLE_PAYMENT_METHOD_ERROR': \"UNAVAILABLE_PAYMENT_METHOD_ERROR\",\n            'UNSUPPORTED_CURRENCY': \"UNSUPPORTED_CURRENCY\",\n            'MISMATCH_CURRENCY_ERROR': \"MISMATCH_CURRENCY_ERROR\",\n            'INVALID_REMINDER_TIME': \"INVALID_REMINDER_TIME\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str,),  # noqa: E501\n            'message': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, error_code, message, *args, **kwargs):  # noqa: E501\n        \"\"\"BadRequestError - a model defined in OpenAPI\n\n        Args:\n            error_code (str): The error code indicating the type of error that occurred.\n            message (str): A human-readable error message that provides additional information about the error.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str,\n        message: str,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"BadRequestError - a model defined in OpenAPI\n\n        Args:\n            error_code (str): The error code indicating the type of error that occurred.\n            message (str): A human-readable error message that provides additional information about the error.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      76,
      90,
      97,
      152,
      153,
      154,
      155,
      156,
      158,
      160,
      161,
      162,
      163,
      164,
      165,
      167,
      176,
      177,
      178,
      179,
      180,
      181,
      183,
      184,
      185,
      186,
      191,
      192,
      193,
      250,
      251,
      252,
      253,
      254,
      256,
      257,
      258,
      259,
      260,
      261,
      263,
      272,
      273,
      274,
      275,
      276,
      277,
      279,
      280,
      281,
      282,
      287,
      288,
      289,
      290
    ]
  },
  {
    "file_path": "xendit/invoice/model/bank.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.alternative_display_item import AlternativeDisplayItem\nfrom xendit.invoice.model.bank_code import BankCode\nglobals()['AlternativeDisplayItem'] = AlternativeDisplayItem\nglobals()['BankCode'] = BankCode\n\ndef lazy_import():\n    pass\n\nclass Bank(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'bank_code': (BankCode,),  # noqa: E501\n            'collection_type': (str,),  # noqa: E501\n            'account_holder_name': (str,),  # noqa: E501\n            'bank_branch': (str, none_type),  # noqa: E501\n            'bank_account_number': (str, none_type),  # noqa: E501\n            'transfer_amount': (float, none_type),  # noqa: E501\n            'alternative_displays': ([AlternativeDisplayItem], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'bank_code': 'bank_code',  # noqa: E501\n        'collection_type': 'collection_type',  # noqa: E501\n        'account_holder_name': 'account_holder_name',  # noqa: E501\n        'bank_branch': 'bank_branch',  # noqa: E501\n        'bank_account_number': 'bank_account_number',  # noqa: E501\n        'transfer_amount': 'transfer_amount',  # noqa: E501\n        'alternative_displays': 'alternative_displays',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, bank_code, collection_type, account_holder_name, *args, **kwargs):  # noqa: E501\n        \"\"\"Bank - a model defined in OpenAPI\n\n        Args:\n            bank_code (BankCode):\n            collection_type (str): The collection type for the bank details.\n            account_holder_name (str): The name of the account holder.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            bank_branch (str): The branch of the bank.. [optional]  # noqa: E501\n            bank_account_number (str): The bank account number.. [optional]  # noqa: E501\n            transfer_amount (float): The transfer amount.. [optional]  # noqa: E501\n            alternative_displays ([AlternativeDisplayItem]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.bank_code = bank_code\n        self.collection_type = collection_type\n        self.account_holder_name = account_holder_name\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        bank_code: BankCode,\n        collection_type: str,\n        account_holder_name: str,\n        bank_branch: str | None = None,\n        bank_account_number: str | None = None,\n        transfer_amount: float | None = None,\n        alternative_displays: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Bank - a model defined in OpenAPI\n\n        Args:\n            bank_code (BankCode):\n            collection_type (str): The collection type for the bank details.\n            account_holder_name (str): The name of the account holder.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            bank_branch (str): The branch of the bank.. [optional]  # noqa: E501\n            bank_account_number (str): The bank account number.. [optional]  # noqa: E501\n            transfer_amount (float): The transfer amount.. [optional]  # noqa: E501\n            alternative_displays ([AlternativeDisplayItem]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.bank_code = bank_code\n        self.collection_type = collection_type\n        self.account_holder_name = account_holder_name\n        if bank_branch is not None:\n            self.bank_branch = bank_branch\n        if bank_account_number is not None:\n            self.bank_account_number = bank_account_number\n        if transfer_amount is not None:\n            self.transfer_amount = transfer_amount\n        if alternative_displays is not None:\n            self.alternative_displays = alternative_displays\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      86,
      87,
      99,
      164,
      165,
      166,
      167,
      168,
      170,
      172,
      173,
      174,
      175,
      176,
      177,
      179,
      188,
      189,
      190,
      191,
      192,
      193,
      195,
      196,
      197,
      198,
      199,
      204,
      205,
      206,
      273,
      274,
      275,
      276,
      277,
      279,
      280,
      281,
      282,
      283,
      284,
      286,
      295,
      296,
      297,
      298,
      299,
      300,
      302,
      303,
      304,
      305,
      306,
      307,
      308,
      309,
      310,
      311,
      312,
      313,
      314,
      319,
      320,
      321,
      322
    ]
  },
  {
    "file_path": "xendit/invoice/model/bank_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass BankCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BCA': \"BCA\",\n            'BNI': \"BNI\",\n            'BRI': \"BRI\",\n            'MANDIRI': \"MANDIRI\",\n            'PERMATA': \"PERMATA\",\n            'BSI': \"BSI\",\n            'BJB': \"BJB\",\n            'SAHABAT_SAMPOERNA': \"SAHABAT_SAMPOERNA\",\n            'CIMB': \"CIMB\",\n            'VIETCAPITAL': \"VIETCAPITAL\",\n            'WOORI': \"WOORI\",\n            'PV': \"PV\",\n            'MSB': \"MSB\",\n            'VPB': \"VPB\",\n            'BIDV': \"BIDV\",\n            'CAKE': \"CAKE\",\n            'BNC': \"BNC\",\n            'HANA': \"HANA\",\n            'MUAMALAT': \"MUAMALAT\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"BankCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available bank channels used for invoice-related transactions.., must be one of [\"BCA\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"BJB\", \"SAHABAT_SAMPOERNA\", \"CIMB\", \"VIETCAPITAL\", \"WOORI\", \"PV\", \"MSB\", \"VPB\", \"BIDV\", \"CAKE\", \"BNC\", \"HANA\", \"MUAMALAT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available bank channels used for invoice-related transactions.., must be one of [\"BCA\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"BJB\", \"SAHABAT_SAMPOERNA\", \"CIMB\", \"VIETCAPITAL\", \"WOORI\", \"PV\", \"MSB\", \"VPB\", \"BIDV\", \"CAKE\", \"BNC\", \"HANA\", \"MUAMALAT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"BankCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available bank channels used for invoice-related transactions.., must be one of [\"BCA\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"BJB\", \"SAHABAT_SAMPOERNA\", \"CIMB\", \"VIETCAPITAL\", \"WOORI\", \"PV\", \"MSB\", \"VPB\", \"BIDV\", \"CAKE\", \"BNC\", \"HANA\", \"MUAMALAT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available bank channels used for invoice-related transactions.., must be one of [\"BCA\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"BJB\", \"SAHABAT_SAMPOERNA\", \"CIMB\", \"VIETCAPITAL\", \"WOORI\", \"PV\", \"MSB\", \"VPB\", \"BIDV\", \"CAKE\", \"BNC\", \"HANA\", \"MUAMALAT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      93,
      99,
      160,
      162,
      163,
      164,
      165,
      166,
      168,
      174,
      175,
      176,
      177,
      179,
      180,
      181,
      182,
      183,
      184,
      186,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      256,
      258,
      260,
      261,
      262,
      263,
      264,
      266,
      272,
      273,
      274,
      275,
      277,
      278,
      279,
      280,
      281,
      282,
      284,
      293,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      313
    ]
  },
  {
    "file_path": "xendit/invoice/model/channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.channel_properties_cards import ChannelPropertiesCards\nglobals()['ChannelPropertiesCards'] = ChannelPropertiesCards\n\ndef lazy_import():\n    pass\n\nclass ChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'cards': (ChannelPropertiesCards, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'cards': 'cards',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"ChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            cards (ChannelPropertiesCards): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        cards: ChannelPropertiesCards | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ChannelProperties - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            cards (ChannelPropertiesCards): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if cards is not None:\n            self.cards = cards\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      91,
      142,
      143,
      144,
      145,
      146,
      148,
      150,
      151,
      152,
      153,
      154,
      155,
      157,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      174,
      179,
      180,
      181,
      234,
      235,
      236,
      237,
      238,
      240,
      241,
      242,
      243,
      244,
      245,
      247,
      256,
      257,
      258,
      259,
      260,
      261,
      263,
      264,
      265,
      266,
      271,
      272,
      273,
      274
    ]
  },
  {
    "file_path": "xendit/invoice/model/channel_properties_cards.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.channel_properties_cards_installment_configuration import ChannelPropertiesCardsInstallmentConfiguration\nglobals()['ChannelPropertiesCardsInstallmentConfiguration'] = ChannelPropertiesCardsInstallmentConfiguration\n\ndef lazy_import():\n    pass\n\nclass ChannelPropertiesCards(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'allowed_bins': ([str], none_type),  # noqa: E501\n            'installment_configuration': (ChannelPropertiesCardsInstallmentConfiguration, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'allowed_bins': 'allowed_bins',  # noqa: E501\n        'installment_configuration': 'installment_configuration',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"ChannelPropertiesCards - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            allowed_bins ([str]): An array of allowed BINs (6 or 8 digits) for credit card payments.. [optional]  # noqa: E501\n            installment_configuration (ChannelPropertiesCardsInstallmentConfiguration): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        allowed_bins: list | None = None,\n        installment_configuration: ChannelPropertiesCardsInstallmentConfiguration | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ChannelPropertiesCards - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            allowed_bins ([str]): An array of allowed BINs (6 or 8 digits) for credit card payments.. [optional]  # noqa: E501\n            installment_configuration (ChannelPropertiesCardsInstallmentConfiguration): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if allowed_bins is not None:\n            self.allowed_bins = allowed_bins\n        if installment_configuration is not None:\n            self.installment_configuration = installment_configuration\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      92,
      145,
      146,
      147,
      148,
      149,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      160,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/invoice/model/channel_properties_cards_installment_configuration.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.channel_properties_cards_installment_configuration_allowed_terms_inner import ChannelPropertiesCardsInstallmentConfigurationAllowedTermsInner\nglobals()['ChannelPropertiesCardsInstallmentConfigurationAllowedTermsInner'] = ChannelPropertiesCardsInstallmentConfigurationAllowedTermsInner\n\ndef lazy_import():\n    pass\n\nclass ChannelPropertiesCardsInstallmentConfiguration(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'allow_full_payment': (bool, none_type),  # noqa: E501\n            'allowed_terms': ([ChannelPropertiesCardsInstallmentConfigurationAllowedTermsInner], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'allow_full_payment': 'allow_full_payment',  # noqa: E501\n        'allowed_terms': 'allowed_terms',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"ChannelPropertiesCardsInstallmentConfiguration - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            allow_full_payment (bool): Indicate whether full payment (without installment) is allowed. [optional]  # noqa: E501\n            allowed_terms ([ChannelPropertiesCardsInstallmentConfigurationAllowedTermsInner]): An object to set what kind (from specific bank / specific tenor) of cards installments will be available on a specific invoice. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        allow_full_payment: bool | None = None,\n        allowed_terms: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ChannelPropertiesCardsInstallmentConfiguration - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            allow_full_payment (bool): Indicate whether full payment (without installment) is allowed. [optional]  # noqa: E501\n            allowed_terms ([ChannelPropertiesCardsInstallmentConfigurationAllowedTermsInner]): An object to set what kind (from specific bank / specific tenor) of cards installments will be available on a specific invoice. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if allow_full_payment is not None:\n            self.allow_full_payment = allow_full_payment\n        if allowed_terms is not None:\n            self.allowed_terms = allowed_terms\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      92,
      145,
      146,
      147,
      148,
      149,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      160,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/invoice/model/channel_properties_cards_installment_configuration_allowed_terms_inner.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ChannelPropertiesCardsInstallmentConfigurationAllowedTermsInner(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'issuer': (str, none_type),  # noqa: E501\n            'terms': ([float], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'issuer': 'issuer',  # noqa: E501\n        'terms': 'terms',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"ChannelPropertiesCardsInstallmentConfigurationAllowedTermsInner - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            issuer (str): The bank code of the installment provider / issuer. [optional]  # noqa: E501\n            terms ([float]): An array containing list of installment tenor available to choose. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        issuer: str | None = None,\n        terms: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ChannelPropertiesCardsInstallmentConfigurationAllowedTermsInner - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            issuer (str): The bank code of the installment provider / issuer. [optional]  # noqa: E501\n            terms ([float]): An array containing list of installment tenor available to choose. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if issuer is not None:\n            self.issuer = issuer\n        if terms is not None:\n            self.terms = terms\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/invoice/model/create_invoice_request.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.channel_properties import ChannelProperties\nfrom xendit.invoice.model.customer_object import CustomerObject\nfrom xendit.invoice.model.invoice_fee import InvoiceFee\nfrom xendit.invoice.model.invoice_item import InvoiceItem\nfrom xendit.invoice.model.notification_preference import NotificationPreference\nglobals()['ChannelProperties'] = ChannelProperties\nglobals()['CustomerObject'] = CustomerObject\nglobals()['InvoiceFee'] = InvoiceFee\nglobals()['InvoiceItem'] = InvoiceItem\nglobals()['NotificationPreference'] = NotificationPreference\n\ndef lazy_import():\n    pass\n\nclass CreateInvoiceRequest(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('metadata',): {\n            'max_properties': 50,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'external_id': (str,),  # noqa: E501\n            'amount': (float,),  # noqa: E501\n            'payer_email': (str, none_type),  # noqa: E501\n            'description': (str, none_type),  # noqa: E501\n            'invoice_duration': (float, none_type),  # noqa: E501\n            'callback_virtual_account_id': (str, none_type),  # noqa: E501\n            'should_send_email': (bool, none_type),  # noqa: E501\n            'customer': (CustomerObject, none_type),  # noqa: E501\n            'customer_notification_preference': (NotificationPreference, none_type),  # noqa: E501\n            'success_redirect_url': (str, none_type),  # noqa: E501\n            'failure_redirect_url': (str, none_type),  # noqa: E501\n            'payment_methods': ([str], none_type),  # noqa: E501\n            'mid_label': (str, none_type),  # noqa: E501\n            'should_authenticate_credit_card': (bool, none_type),  # noqa: E501\n            'currency': (str, none_type),  # noqa: E501\n            'reminder_time': (float, none_type),  # noqa: E501\n            'locale': (str, none_type),  # noqa: E501\n            'reminder_time_unit': (str, none_type),  # noqa: E501\n            'items': ([InvoiceItem], none_type),  # noqa: E501\n            'fees': ([InvoiceFee], none_type),  # noqa: E501\n            'channel_properties': (ChannelProperties, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'external_id': 'external_id',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'payer_email': 'payer_email',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'invoice_duration': 'invoice_duration',  # noqa: E501\n        'callback_virtual_account_id': 'callback_virtual_account_id',  # noqa: E501\n        'should_send_email': 'should_send_email',  # noqa: E501\n        'customer': 'customer',  # noqa: E501\n        'customer_notification_preference': 'customer_notification_preference',  # noqa: E501\n        'success_redirect_url': 'success_redirect_url',  # noqa: E501\n        'failure_redirect_url': 'failure_redirect_url',  # noqa: E501\n        'payment_methods': 'payment_methods',  # noqa: E501\n        'mid_label': 'mid_label',  # noqa: E501\n        'should_authenticate_credit_card': 'should_authenticate_credit_card',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'reminder_time': 'reminder_time',  # noqa: E501\n        'locale': 'locale',  # noqa: E501\n        'reminder_time_unit': 'reminder_time_unit',  # noqa: E501\n        'items': 'items',  # noqa: E501\n        'fees': 'fees',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, external_id, amount, *args, **kwargs):  # noqa: E501\n        \"\"\"CreateInvoiceRequest - a model defined in OpenAPI\n\n        Args:\n            external_id (str): The external ID of the invoice.\n            amount (float): The invoice amount.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payer_email (str): The email address of the payer.. [optional]  # noqa: E501\n            description (str): A description of the payment.. [optional]  # noqa: E501\n            invoice_duration (float): The duration of the invoice in seconds.. [optional]  # noqa: E501\n            callback_virtual_account_id (str): The ID of the callback virtual account.. [optional]  # noqa: E501\n            should_send_email (bool): Indicates whether email notifications should be sent.. [optional]  # noqa: E501\n            customer (CustomerObject): [optional]  # noqa: E501\n            customer_notification_preference (NotificationPreference): [optional]  # noqa: E501\n            success_redirect_url (str): The URL to redirect to on successful payment.. [optional]  # noqa: E501\n            failure_redirect_url (str): The URL to redirect to on payment failure.. [optional]  # noqa: E501\n            payment_methods ([str]): An array of available payment methods.. [optional]  # noqa: E501\n            mid_label (str): The middle label.. [optional]  # noqa: E501\n            should_authenticate_credit_card (bool): Indicates whether credit card authentication is required.. [optional]  # noqa: E501\n            currency (str): The currency of the invoice.. [optional]  # noqa: E501\n            reminder_time (float): The reminder time.. [optional]  # noqa: E501\n            locale (str): The default language to display.. [optional]  # noqa: E501\n            reminder_time_unit (str): The unit of the reminder time.. [optional]  # noqa: E501\n            items ([InvoiceItem]): An array of items included in the invoice.. [optional]  # noqa: E501\n            fees ([InvoiceFee]): An array of fees associated with the invoice.. [optional]  # noqa: E501\n            channel_properties (ChannelProperties): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): A free-format JSON for additional information that you may use. Object can be up to 50 keys, with key names up to 40 characters long and values up to 500 characters long.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.external_id = external_id\n        self.amount = amount\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        external_id: str,\n        amount: float,\n        payer_email: str | None = None,\n        description: str | None = None,\n        invoice_duration: float | None = None,\n        callback_virtual_account_id: str | None = None,\n        should_send_email: bool | None = None,\n        customer: CustomerObject | None = None,\n        customer_notification_preference: NotificationPreference | None = None,\n        success_redirect_url: str | None = None,\n        failure_redirect_url: str | None = None,\n        payment_methods: list | None = None,\n        mid_label: str | None = None,\n        should_authenticate_credit_card: bool | None = None,\n        currency: str | None = None,\n        reminder_time: float | None = None,\n        locale: str | None = None,\n        reminder_time_unit: str | None = None,\n        items: list | None = None,\n        fees: list | None = None,\n        channel_properties: ChannelProperties | None = None,\n        metadata: dict | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CreateInvoiceRequest - a model defined in OpenAPI\n\n        Args:\n            external_id (str): The external ID of the invoice.\n            amount (float): The invoice amount.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payer_email (str): The email address of the payer.. [optional]  # noqa: E501\n            description (str): A description of the payment.. [optional]  # noqa: E501\n            invoice_duration (float): The duration of the invoice in seconds.. [optional]  # noqa: E501\n            callback_virtual_account_id (str): The ID of the callback virtual account.. [optional]  # noqa: E501\n            should_send_email (bool): Indicates whether email notifications should be sent.. [optional]  # noqa: E501\n            customer (CustomerObject): [optional]  # noqa: E501\n            customer_notification_preference (NotificationPreference): [optional]  # noqa: E501\n            success_redirect_url (str): The URL to redirect to on successful payment.. [optional]  # noqa: E501\n            failure_redirect_url (str): The URL to redirect to on payment failure.. [optional]  # noqa: E501\n            payment_methods ([str]): An array of available payment methods.. [optional]  # noqa: E501\n            mid_label (str): The middle label.. [optional]  # noqa: E501\n            should_authenticate_credit_card (bool): Indicates whether credit card authentication is required.. [optional]  # noqa: E501\n            currency (str): The currency of the invoice.. [optional]  # noqa: E501\n            reminder_time (float): The reminder time.. [optional]  # noqa: E501\n            locale (str): The default language to display.. [optional]  # noqa: E501\n            reminder_time_unit (str): The unit of the reminder time.. [optional]  # noqa: E501\n            items ([InvoiceItem]): An array of items included in the invoice.. [optional]  # noqa: E501\n            fees ([InvoiceFee]): An array of fees associated with the invoice.. [optional]  # noqa: E501\n            channel_properties (ChannelProperties): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): A free-format JSON for additional information that you may use. Object can be up to 50 keys, with key names up to 40 characters long and values up to 500 characters long.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.external_id = external_id\n        self.amount = amount\n        if payer_email is not None:\n            self.payer_email = payer_email\n        if description is not None:\n            self.description = description\n        if invoice_duration is not None:\n            self.invoice_duration = invoice_duration\n        if callback_virtual_account_id is not None:\n            self.callback_virtual_account_id = callback_virtual_account_id\n        if should_send_email is not None:\n            self.should_send_email = should_send_email\n        if customer is not None:\n            self.customer = customer\n        if customer_notification_preference is not None:\n            self.customer_notification_preference = customer_notification_preference\n        if success_redirect_url is not None:\n            self.success_redirect_url = success_redirect_url\n        if failure_redirect_url is not None:\n            self.failure_redirect_url = failure_redirect_url\n        if payment_methods is not None:\n            self.payment_methods = payment_methods\n        if mid_label is not None:\n            self.mid_label = mid_label\n        if should_authenticate_credit_card is not None:\n            self.should_authenticate_credit_card = should_authenticate_credit_card\n        if currency is not None:\n            self.currency = currency\n        if reminder_time is not None:\n            self.reminder_time = reminder_time\n        if locale is not None:\n            self.locale = locale\n        if reminder_time_unit is not None:\n            self.reminder_time_unit = reminder_time_unit\n        if items is not None:\n            self.items = items\n        if fees is not None:\n            self.fees = fees\n        if channel_properties is not None:\n            self.channel_properties = channel_properties\n        if metadata is not None:\n            self.metadata = metadata\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      80,
      81,
      227,
      228,
      229,
      230,
      231,
      233,
      252,
      257,
      258,
      356,
      357,
      358,
      359,
      360,
      362,
      363,
      364,
      365,
      366,
      367,
      369,
      378,
      379,
      380,
      381,
      382,
      383,
      385,
      386,
      387,
      388,
      389,
      390,
      391,
      392,
      393,
      394,
      395,
      396,
      397,
      398,
      399,
      400,
      401,
      402,
      403,
      404,
      405,
      406,
      407,
      408,
      409,
      410,
      411,
      412,
      413,
      414,
      415,
      416,
      417,
      418,
      419,
      420,
      421,
      422,
      423,
      424,
      425,
      426,
      427,
      428,
      433,
      434,
      435,
      436
    ]
  },
  {
    "file_path": "xendit/invoice/model/customer_object.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.address_object import AddressObject\nglobals()['AddressObject'] = AddressObject\n\ndef lazy_import():\n    pass\n\nclass CustomerObject(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'id': (str, none_type, none_type),  # noqa: E501\n            'phone_number': (str, none_type, none_type),  # noqa: E501\n            'given_names': (str, none_type, none_type),  # noqa: E501\n            'surname': (str, none_type, none_type),  # noqa: E501\n            'email': (str, none_type, none_type),  # noqa: E501\n            'mobile_number': (str, none_type, none_type),  # noqa: E501\n            'customer_id': (str, none_type, none_type),  # noqa: E501\n            'addresses': ([AddressObject], none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'id': 'id',  # noqa: E501\n        'phone_number': 'phone_number',  # noqa: E501\n        'given_names': 'given_names',  # noqa: E501\n        'surname': 'surname',  # noqa: E501\n        'email': 'email',  # noqa: E501\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'customer_id': 'customer_id',  # noqa: E501\n        'addresses': 'addresses',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CustomerObject - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            id (str, none_type): The unique identifier for the customer.. [optional]  # noqa: E501\n            phone_number (str, none_type): The customer's phone number.. [optional]  # noqa: E501\n            given_names (str, none_type): The customer's given names or first names.. [optional]  # noqa: E501\n            surname (str, none_type): The customer's surname or last name.. [optional]  # noqa: E501\n            email (str, none_type): The customer's email address.. [optional]  # noqa: E501\n            mobile_number (str, none_type): The customer's mobile phone number.. [optional]  # noqa: E501\n            customer_id (str, none_type): An additional identifier for the customer.. [optional]  # noqa: E501\n            addresses ([AddressObject], none_type): An array of addresses associated with the customer.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        id: str | None = None,\n        phone_number: str | None = None,\n        given_names: str | None = None,\n        surname: str | None = None,\n        email: str | None = None,\n        mobile_number: str | None = None,\n        customer_id: str | None = None,\n        addresses: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CustomerObject - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            id (str, none_type): The unique identifier for the customer.. [optional]  # noqa: E501\n            phone_number (str, none_type): The customer's phone number.. [optional]  # noqa: E501\n            given_names (str, none_type): The customer's given names or first names.. [optional]  # noqa: E501\n            surname (str, none_type): The customer's surname or last name.. [optional]  # noqa: E501\n            email (str, none_type): The customer's email address.. [optional]  # noqa: E501\n            mobile_number (str, none_type): The customer's mobile phone number.. [optional]  # noqa: E501\n            customer_id (str, none_type): An additional identifier for the customer.. [optional]  # noqa: E501\n            addresses ([AddressObject], none_type): An array of addresses associated with the customer.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if id is not None:\n            self.id = id\n        if phone_number is not None:\n            self.phone_number = phone_number\n        if given_names is not None:\n            self.given_names = given_names\n        if surname is not None:\n            self.surname = surname\n        if email is not None:\n            self.email = email\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if customer_id is not None:\n            self.customer_id = customer_id\n        if addresses is not None:\n            self.addresses = addresses\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      98,
      163,
      164,
      165,
      166,
      167,
      169,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      187,
      188,
      189,
      190,
      191,
      192,
      194,
      195,
      200,
      201,
      202,
      269,
      270,
      271,
      272,
      273,
      275,
      276,
      277,
      278,
      279,
      280,
      282,
      291,
      292,
      293,
      294,
      295,
      296,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      305,
      306,
      307,
      308,
      309,
      310,
      311,
      312,
      313,
      314,
      315,
      320,
      321,
      322,
      323
    ]
  },
  {
    "file_path": "xendit/invoice/model/direct_debit.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.direct_debit_type import DirectDebitType\nglobals()['DirectDebitType'] = DirectDebitType\n\ndef lazy_import():\n    pass\n\nclass DirectDebit(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'direct_debit_type': (DirectDebitType,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'direct_debit_type': 'direct_debit_type',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, direct_debit_type, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebit - a model defined in OpenAPI\n\n        Args:\n            direct_debit_type (DirectDebitType):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.direct_debit_type = direct_debit_type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        direct_debit_type: DirectDebitType,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebit - a model defined in OpenAPI\n\n        Args:\n            direct_debit_type (DirectDebitType):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.direct_debit_type = direct_debit_type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      91,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      275,
      276,
      277,
      278
    ]
  },
  {
    "file_path": "xendit/invoice/model/direct_debit_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BA_BRI': \"BA_BRI\",\n            'DC_BRI': \"DC_BRI\",\n            'DD_BRI': \"DD_BRI\",\n            'DD_MANDIRI': \"DD_MANDIRI\",\n            'BA_BPI': \"BA_BPI\",\n            'DC_BPI': \"DC_BPI\",\n            'DD_BPI': \"DD_BPI\",\n            'BA_UBP': \"BA_UBP\",\n            'DC_UBP': \"DC_UBP\",\n            'DD_UBP': \"DD_UBP\",\n            'BCA_KLIKPAY': \"BCA_KLIKPAY\",\n            'BA_BCA_KLIKPAY': \"BA_BCA_KLIKPAY\",\n            'DC_BCA_KLIKPAY': \"DC_BCA_KLIKPAY\",\n            'DD_BCA_KLIKPAY': \"DD_BCA_KLIKPAY\",\n            'DD_BDO_EPAY': \"DD_BDO_EPAY\",\n            'DD_RCBC': \"DD_RCBC\",\n            'DD_CHINABANK': \"DD_CHINABANK\",\n            'BA_CHINABANK': \"BA_CHINABANK\",\n            'DC_CHINABANK': \"DC_CHINABANK\",\n            'DD_PUBLIC_FPX': \"DD_PUBLIC_FPX\",\n            'DD_AMBANK_FPX': \"DD_AMBANK_FPX\",\n            'DD_KFH_FPX': \"DD_KFH_FPX\",\n            'DD_AGRO_FPX': \"DD_AGRO_FPX\",\n            'DD_AFFIN_FPX': \"DD_AFFIN_FPX\",\n            'DD_ALLIANCE_FPX': \"DD_ALLIANCE_FPX\",\n            'DD_MUAMALAT_FPX': \"DD_MUAMALAT_FPX\",\n            'DD_HLB_FPX': \"DD_HLB_FPX\",\n            'DD_ISLAM_FPX': \"DD_ISLAM_FPX\",\n            'DD_RAKYAT_FPX': \"DD_RAKYAT_FPX\",\n            'DD_CIMB_FPX': \"DD_CIMB_FPX\",\n            'DD_UOB_FPX': \"DD_UOB_FPX\",\n            'DD_BOC_FPX': \"DD_BOC_FPX\",\n            'DD_BSN_FPX': \"DD_BSN_FPX\",\n            'DD_OCBC_FPX': \"DD_OCBC_FPX\",\n            'DD_HSBC_FPX': \"DD_HSBC_FPX\",\n            'DD_SCH_FPX': \"DD_SCH_FPX\",\n            'DD_MAYB2U_FPX': \"DD_MAYB2U_FPX\",\n            'DD_RHB_FPX': \"DD_RHB_FPX\",\n            'DD_UOB_FPX_BUSINESS': \"DD_UOB_FPX_BUSINESS\",\n            'DD_AGRO_FPX_BUSINESS': \"DD_AGRO_FPX_BUSINESS\",\n            'DD_ALLIANCE_FPX_BUSINESS': \"DD_ALLIANCE_FPX_BUSINESS\",\n            'DD_AMBANK_FPX_BUSINESS': \"DD_AMBANK_FPX_BUSINESS\",\n            'DD_ISLAM_FPX_BUSINESS': \"DD_ISLAM_FPX_BUSINESS\",\n            'DD_MUAMALAT_FPX_BUSINESS': \"DD_MUAMALAT_FPX_BUSINESS\",\n            'DD_HLB_FPX_BUSINESS': \"DD_HLB_FPX_BUSINESS\",\n            'DD_HSBC_FPX_BUSINESS': \"DD_HSBC_FPX_BUSINESS\",\n            'DD_RAKYAT_FPX_BUSINESS': \"DD_RAKYAT_FPX_BUSINESS\",\n            'DD_KFH_FPX_BUSINESS': \"DD_KFH_FPX_BUSINESS\",\n            'DD_OCBC_FPX_BUSINESS': \"DD_OCBC_FPX_BUSINESS\",\n            'DD_PUBLIC_FPX_BUSINESS': \"DD_PUBLIC_FPX_BUSINESS\",\n            'DD_RHB_FPX_BUSINESS': \"DD_RHB_FPX_BUSINESS\",\n            'DD_SCH_FPX_BUSINESS': \"DD_SCH_FPX_BUSINESS\",\n            'DD_CITIBANK_FPX_BUSINESS': \"DD_CITIBANK_FPX_BUSINESS\",\n            'DD_BNP_FPX_BUSINESS': \"DD_BNP_FPX_BUSINESS\",\n            'DD_DEUTSCHE_FPX_BUSINESS': \"DD_DEUTSCHE_FPX_BUSINESS\",\n            'DD_MAYB2E_FPX_BUSINESS': \"DD_MAYB2E_FPX_BUSINESS\",\n            'DD_CIMB_FPX_BUSINESS': \"DD_CIMB_FPX_BUSINESS\",\n            'DD_AFFIN_FPX_BUSINESS': \"DD_AFFIN_FPX_BUSINESS\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"DirectDebitType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available Direct Debit channels used for invoice-related transactions.., must be one of [\"BA_BRI\", \"DC_BRI\", \"DD_BRI\", \"DD_MANDIRI\", \"BA_BPI\", \"DC_BPI\", \"DD_BPI\", \"BA_UBP\", \"DC_UBP\", \"DD_UBP\", \"BCA_KLIKPAY\", \"BA_BCA_KLIKPAY\", \"DC_BCA_KLIKPAY\", \"DD_BCA_KLIKPAY\", \"DD_BDO_EPAY\", \"DD_RCBC\", \"DD_CHINABANK\", \"BA_CHINABANK\", \"DC_CHINABANK\", \"DD_PUBLIC_FPX\", \"DD_AMBANK_FPX\", \"DD_KFH_FPX\", \"DD_AGRO_FPX\", \"DD_AFFIN_FPX\", \"DD_ALLIANCE_FPX\", \"DD_MUAMALAT_FPX\", \"DD_HLB_FPX\", \"DD_ISLAM_FPX\", \"DD_RAKYAT_FPX\", \"DD_CIMB_FPX\", \"DD_UOB_FPX\", \"DD_BOC_FPX\", \"DD_BSN_FPX\", \"DD_OCBC_FPX\", \"DD_HSBC_FPX\", \"DD_SCH_FPX\", \"DD_MAYB2U_FPX\", \"DD_RHB_FPX\", \"DD_UOB_FPX_BUSINESS\", \"DD_AGRO_FPX_BUSINESS\", \"DD_ALLIANCE_FPX_BUSINESS\", \"DD_AMBANK_FPX_BUSINESS\", \"DD_ISLAM_FPX_BUSINESS\", \"DD_MUAMALAT_FPX_BUSINESS\", \"DD_HLB_FPX_BUSINESS\", \"DD_HSBC_FPX_BUSINESS\", \"DD_RAKYAT_FPX_BUSINESS\", \"DD_KFH_FPX_BUSINESS\", \"DD_OCBC_FPX_BUSINESS\", \"DD_PUBLIC_FPX_BUSINESS\", \"DD_RHB_FPX_BUSINESS\", \"DD_SCH_FPX_BUSINESS\", \"DD_CITIBANK_FPX_BUSINESS\", \"DD_BNP_FPX_BUSINESS\", \"DD_DEUTSCHE_FPX_BUSINESS\", \"DD_MAYB2E_FPX_BUSINESS\", \"DD_CIMB_FPX_BUSINESS\", \"DD_AFFIN_FPX_BUSINESS\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available Direct Debit channels used for invoice-related transactions.., must be one of [\"BA_BRI\", \"DC_BRI\", \"DD_BRI\", \"DD_MANDIRI\", \"BA_BPI\", \"DC_BPI\", \"DD_BPI\", \"BA_UBP\", \"DC_UBP\", \"DD_UBP\", \"BCA_KLIKPAY\", \"BA_BCA_KLIKPAY\", \"DC_BCA_KLIKPAY\", \"DD_BCA_KLIKPAY\", \"DD_BDO_EPAY\", \"DD_RCBC\", \"DD_CHINABANK\", \"BA_CHINABANK\", \"DC_CHINABANK\", \"DD_PUBLIC_FPX\", \"DD_AMBANK_FPX\", \"DD_KFH_FPX\", \"DD_AGRO_FPX\", \"DD_AFFIN_FPX\", \"DD_ALLIANCE_FPX\", \"DD_MUAMALAT_FPX\", \"DD_HLB_FPX\", \"DD_ISLAM_FPX\", \"DD_RAKYAT_FPX\", \"DD_CIMB_FPX\", \"DD_UOB_FPX\", \"DD_BOC_FPX\", \"DD_BSN_FPX\", \"DD_OCBC_FPX\", \"DD_HSBC_FPX\", \"DD_SCH_FPX\", \"DD_MAYB2U_FPX\", \"DD_RHB_FPX\", \"DD_UOB_FPX_BUSINESS\", \"DD_AGRO_FPX_BUSINESS\", \"DD_ALLIANCE_FPX_BUSINESS\", \"DD_AMBANK_FPX_BUSINESS\", \"DD_ISLAM_FPX_BUSINESS\", \"DD_MUAMALAT_FPX_BUSINESS\", \"DD_HLB_FPX_BUSINESS\", \"DD_HSBC_FPX_BUSINESS\", \"DD_RAKYAT_FPX_BUSINESS\", \"DD_KFH_FPX_BUSINESS\", \"DD_OCBC_FPX_BUSINESS\", \"DD_PUBLIC_FPX_BUSINESS\", \"DD_RHB_FPX_BUSINESS\", \"DD_SCH_FPX_BUSINESS\", \"DD_CITIBANK_FPX_BUSINESS\", \"DD_BNP_FPX_BUSINESS\", \"DD_DEUTSCHE_FPX_BUSINESS\", \"DD_MAYB2E_FPX_BUSINESS\", \"DD_CIMB_FPX_BUSINESS\", \"DD_AFFIN_FPX_BUSINESS\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"DirectDebitType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available Direct Debit channels used for invoice-related transactions.., must be one of [\"BA_BRI\", \"DC_BRI\", \"DD_BRI\", \"DD_MANDIRI\", \"BA_BPI\", \"DC_BPI\", \"DD_BPI\", \"BA_UBP\", \"DC_UBP\", \"DD_UBP\", \"BCA_KLIKPAY\", \"BA_BCA_KLIKPAY\", \"DC_BCA_KLIKPAY\", \"DD_BCA_KLIKPAY\", \"DD_BDO_EPAY\", \"DD_RCBC\", \"DD_CHINABANK\", \"BA_CHINABANK\", \"DC_CHINABANK\", \"DD_PUBLIC_FPX\", \"DD_AMBANK_FPX\", \"DD_KFH_FPX\", \"DD_AGRO_FPX\", \"DD_AFFIN_FPX\", \"DD_ALLIANCE_FPX\", \"DD_MUAMALAT_FPX\", \"DD_HLB_FPX\", \"DD_ISLAM_FPX\", \"DD_RAKYAT_FPX\", \"DD_CIMB_FPX\", \"DD_UOB_FPX\", \"DD_BOC_FPX\", \"DD_BSN_FPX\", \"DD_OCBC_FPX\", \"DD_HSBC_FPX\", \"DD_SCH_FPX\", \"DD_MAYB2U_FPX\", \"DD_RHB_FPX\", \"DD_UOB_FPX_BUSINESS\", \"DD_AGRO_FPX_BUSINESS\", \"DD_ALLIANCE_FPX_BUSINESS\", \"DD_AMBANK_FPX_BUSINESS\", \"DD_ISLAM_FPX_BUSINESS\", \"DD_MUAMALAT_FPX_BUSINESS\", \"DD_HLB_FPX_BUSINESS\", \"DD_HSBC_FPX_BUSINESS\", \"DD_RAKYAT_FPX_BUSINESS\", \"DD_KFH_FPX_BUSINESS\", \"DD_OCBC_FPX_BUSINESS\", \"DD_PUBLIC_FPX_BUSINESS\", \"DD_RHB_FPX_BUSINESS\", \"DD_SCH_FPX_BUSINESS\", \"DD_CITIBANK_FPX_BUSINESS\", \"DD_BNP_FPX_BUSINESS\", \"DD_DEUTSCHE_FPX_BUSINESS\", \"DD_MAYB2E_FPX_BUSINESS\", \"DD_CIMB_FPX_BUSINESS\", \"DD_AFFIN_FPX_BUSINESS\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available Direct Debit channels used for invoice-related transactions.., must be one of [\"BA_BRI\", \"DC_BRI\", \"DD_BRI\", \"DD_MANDIRI\", \"BA_BPI\", \"DC_BPI\", \"DD_BPI\", \"BA_UBP\", \"DC_UBP\", \"DD_UBP\", \"BCA_KLIKPAY\", \"BA_BCA_KLIKPAY\", \"DC_BCA_KLIKPAY\", \"DD_BCA_KLIKPAY\", \"DD_BDO_EPAY\", \"DD_RCBC\", \"DD_CHINABANK\", \"BA_CHINABANK\", \"DC_CHINABANK\", \"DD_PUBLIC_FPX\", \"DD_AMBANK_FPX\", \"DD_KFH_FPX\", \"DD_AGRO_FPX\", \"DD_AFFIN_FPX\", \"DD_ALLIANCE_FPX\", \"DD_MUAMALAT_FPX\", \"DD_HLB_FPX\", \"DD_ISLAM_FPX\", \"DD_RAKYAT_FPX\", \"DD_CIMB_FPX\", \"DD_UOB_FPX\", \"DD_BOC_FPX\", \"DD_BSN_FPX\", \"DD_OCBC_FPX\", \"DD_HSBC_FPX\", \"DD_SCH_FPX\", \"DD_MAYB2U_FPX\", \"DD_RHB_FPX\", \"DD_UOB_FPX_BUSINESS\", \"DD_AGRO_FPX_BUSINESS\", \"DD_ALLIANCE_FPX_BUSINESS\", \"DD_AMBANK_FPX_BUSINESS\", \"DD_ISLAM_FPX_BUSINESS\", \"DD_MUAMALAT_FPX_BUSINESS\", \"DD_HLB_FPX_BUSINESS\", \"DD_HSBC_FPX_BUSINESS\", \"DD_RAKYAT_FPX_BUSINESS\", \"DD_KFH_FPX_BUSINESS\", \"DD_OCBC_FPX_BUSINESS\", \"DD_PUBLIC_FPX_BUSINESS\", \"DD_RHB_FPX_BUSINESS\", \"DD_SCH_FPX_BUSINESS\", \"DD_CITIBANK_FPX_BUSINESS\", \"DD_BNP_FPX_BUSINESS\", \"DD_DEUTSCHE_FPX_BUSINESS\", \"DD_MAYB2E_FPX_BUSINESS\", \"DD_CIMB_FPX_BUSINESS\", \"DD_AFFIN_FPX_BUSINESS\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      132,
      138,
      199,
      201,
      202,
      203,
      204,
      205,
      207,
      213,
      214,
      215,
      216,
      218,
      219,
      220,
      221,
      222,
      223,
      225,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      295,
      297,
      299,
      300,
      301,
      302,
      303,
      305,
      311,
      312,
      313,
      314,
      316,
      317,
      318,
      319,
      320,
      321,
      323,
      332,
      333,
      334,
      335,
      336,
      337,
      338,
      339,
      340,
      341,
      342,
      343,
      352
    ]
  },
  {
    "file_path": "xendit/invoice/model/ewallet.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.ewallet_type import EwalletType\nglobals()['EwalletType'] = EwalletType\n\ndef lazy_import():\n    pass\n\nclass Ewallet(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'ewallet_type': (EwalletType,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'ewallet_type': 'ewallet_type',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, ewallet_type, *args, **kwargs):  # noqa: E501\n        \"\"\"Ewallet - a model defined in OpenAPI\n\n        Args:\n            ewallet_type (EwalletType):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.ewallet_type = ewallet_type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        ewallet_type: EwalletType,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Ewallet - a model defined in OpenAPI\n\n        Args:\n            ewallet_type (EwalletType):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.ewallet_type = ewallet_type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      91,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      275,
      276,
      277,
      278
    ]
  },
  {
    "file_path": "xendit/invoice/model/ewallet_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass EwalletType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'OVO': \"OVO\",\n            'GOPAY': \"GOPAY\",\n            'DANA': \"DANA\",\n            'LINKAJA': \"LINKAJA\",\n            'PAYMAYA': \"PAYMAYA\",\n            'SHOPEEPAY': \"SHOPEEPAY\",\n            'GCASH': \"GCASH\",\n            'GRABPAY': \"GRABPAY\",\n            'ASTRAPAY': \"ASTRAPAY\",\n            'NEXCASH': \"NEXCASH\",\n            'JENIUSPAY': \"JENIUSPAY\",\n            'MOMO': \"MOMO\",\n            'ZALOPAY': \"ZALOPAY\",\n            'VIETTELPAY': \"VIETTELPAY\",\n            'VNPTWALLET': \"VNPTWALLET\",\n            'APPOTA': \"APPOTA\",\n            'LINEPAY': \"LINEPAY\",\n            'TRUEMONEY': \"TRUEMONEY\",\n            'WECHATPAY': \"WECHATPAY\",\n            'TOUCHNGO': \"TOUCHNGO\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"EwalletType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available eWallet channels used for invoice-related transactions.., must be one of [\"OVO\", \"GOPAY\", \"DANA\", \"LINKAJA\", \"PAYMAYA\", \"SHOPEEPAY\", \"GCASH\", \"GRABPAY\", \"ASTRAPAY\", \"NEXCASH\", \"JENIUSPAY\", \"MOMO\", \"ZALOPAY\", \"VIETTELPAY\", \"VNPTWALLET\", \"APPOTA\", \"LINEPAY\", \"TRUEMONEY\", \"WECHATPAY\", \"TOUCHNGO\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available eWallet channels used for invoice-related transactions.., must be one of [\"OVO\", \"GOPAY\", \"DANA\", \"LINKAJA\", \"PAYMAYA\", \"SHOPEEPAY\", \"GCASH\", \"GRABPAY\", \"ASTRAPAY\", \"NEXCASH\", \"JENIUSPAY\", \"MOMO\", \"ZALOPAY\", \"VIETTELPAY\", \"VNPTWALLET\", \"APPOTA\", \"LINEPAY\", \"TRUEMONEY\", \"WECHATPAY\", \"TOUCHNGO\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"EwalletType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available eWallet channels used for invoice-related transactions.., must be one of [\"OVO\", \"GOPAY\", \"DANA\", \"LINKAJA\", \"PAYMAYA\", \"SHOPEEPAY\", \"GCASH\", \"GRABPAY\", \"ASTRAPAY\", \"NEXCASH\", \"JENIUSPAY\", \"MOMO\", \"ZALOPAY\", \"VIETTELPAY\", \"VNPTWALLET\", \"APPOTA\", \"LINEPAY\", \"TRUEMONEY\", \"WECHATPAY\", \"TOUCHNGO\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available eWallet channels used for invoice-related transactions.., must be one of [\"OVO\", \"GOPAY\", \"DANA\", \"LINKAJA\", \"PAYMAYA\", \"SHOPEEPAY\", \"GCASH\", \"GRABPAY\", \"ASTRAPAY\", \"NEXCASH\", \"JENIUSPAY\", \"MOMO\", \"ZALOPAY\", \"VIETTELPAY\", \"VNPTWALLET\", \"APPOTA\", \"LINEPAY\", \"TRUEMONEY\", \"WECHATPAY\", \"TOUCHNGO\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      94,
      100,
      161,
      163,
      164,
      165,
      166,
      167,
      169,
      175,
      176,
      177,
      178,
      180,
      181,
      182,
      183,
      184,
      185,
      187,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      257,
      259,
      261,
      262,
      263,
      264,
      265,
      267,
      273,
      274,
      275,
      276,
      278,
      279,
      280,
      281,
      282,
      283,
      285,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      305,
      314
    ]
  },
  {
    "file_path": "xendit/invoice/model/forbidden_error.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ForbiddenError(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'ACCESS_SUSPENDED': \"ACCESS_SUSPENDED\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str,),  # noqa: E501\n            'message': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, message, *args, **kwargs):  # noqa: E501\n        \"\"\"ForbiddenError - a model defined in OpenAPI\n\n        Args:\n            message (str): A human-readable error message providing additional context about the 403 Forbidden response.\n\n        Keyword Args:\n            error_code (str): The specific error code indicating that access to the invoice operation is suspended.. defaults to \"ACCESS_SUSPENDED\", must be one of [\"ACCESS_SUSPENDED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        error_code = kwargs.get('error_code', \"ACCESS_SUSPENDED\")\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        message: str,\n        error_code: str = \"ACCESS_SUSPENDED\",\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ForbiddenError - a model defined in OpenAPI\n\n        Args:\n            message (str): A human-readable error message providing additional context about the 403 Forbidden response.\n\n\n        Keyword Args:\n            error_code (str): The specific error code indicating that access to the invoice operation is suspended.. defaults to \"ACCESS_SUSPENDED\", must be one of [\"ACCESS_SUSPENDED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      91,
      146,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      180,
      181,
      186,
      187,
      188,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      282,
      283,
      284,
      285
    ]
  },
  {
    "file_path": "xendit/invoice/model/invoice.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.bank import Bank\nfrom xendit.invoice.model.channel_properties import ChannelProperties\nfrom xendit.invoice.model.customer_object import CustomerObject\nfrom xendit.invoice.model.direct_debit import DirectDebit\nfrom xendit.invoice.model.ewallet import Ewallet\nfrom xendit.invoice.model.invoice_currency import InvoiceCurrency\nfrom xendit.invoice.model.invoice_fee import InvoiceFee\nfrom xendit.invoice.model.invoice_item import InvoiceItem\nfrom xendit.invoice.model.invoice_payment_method import InvoicePaymentMethod\nfrom xendit.invoice.model.invoice_status import InvoiceStatus\nfrom xendit.invoice.model.notification_preference import NotificationPreference\nfrom xendit.invoice.model.paylater import Paylater\nfrom xendit.invoice.model.qr_code import QrCode\nfrom xendit.invoice.model.retail_outlet import RetailOutlet\nglobals()['Bank'] = Bank\nglobals()['ChannelProperties'] = ChannelProperties\nglobals()['CustomerObject'] = CustomerObject\nglobals()['DirectDebit'] = DirectDebit\nglobals()['Ewallet'] = Ewallet\nglobals()['InvoiceCurrency'] = InvoiceCurrency\nglobals()['InvoiceFee'] = InvoiceFee\nglobals()['InvoiceItem'] = InvoiceItem\nglobals()['InvoicePaymentMethod'] = InvoicePaymentMethod\nglobals()['InvoiceStatus'] = InvoiceStatus\nglobals()['NotificationPreference'] = NotificationPreference\nglobals()['Paylater'] = Paylater\nglobals()['QrCode'] = QrCode\nglobals()['RetailOutlet'] = RetailOutlet\n\ndef lazy_import():\n    pass\n\nclass Invoice(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'external_id': (str,),  # noqa: E501\n            'user_id': (str,),  # noqa: E501\n            'status': (InvoiceStatus,),  # noqa: E501\n            'merchant_name': (str,),  # noqa: E501\n            'merchant_profile_picture_url': (str,),  # noqa: E501\n            'amount': (float,),  # noqa: E501\n            'expiry_date': (datetime,),  # noqa: E501\n            'invoice_url': (str,),  # noqa: E501\n            'available_banks': ([Bank],),  # noqa: E501\n            'available_retail_outlets': ([RetailOutlet],),  # noqa: E501\n            'available_ewallets': ([Ewallet],),  # noqa: E501\n            'available_qr_codes': ([QrCode],),  # noqa: E501\n            'available_direct_debits': ([DirectDebit],),  # noqa: E501\n            'available_paylaters': ([Paylater],),  # noqa: E501\n            'should_send_email': (bool,),  # noqa: E501\n            'created': (datetime,),  # noqa: E501\n            'updated': (datetime,),  # noqa: E501\n            'id': (str, none_type),  # noqa: E501\n            'payer_email': (str, none_type),  # noqa: E501\n            'description': (str, none_type),  # noqa: E501\n            'payment_method': (InvoicePaymentMethod, none_type),  # noqa: E501\n            'locale': (str, none_type),  # noqa: E501\n            'should_exclude_credit_card': (bool, none_type),  # noqa: E501\n            'success_redirect_url': (str, none_type),  # noqa: E501\n            'failure_redirect_url': (str, none_type),  # noqa: E501\n            'should_authenticate_credit_card': (bool, none_type),  # noqa: E501\n            'currency': (InvoiceCurrency, none_type),  # noqa: E501\n            'items': ([InvoiceItem], none_type),  # noqa: E501\n            'fixed_va': (bool, none_type),  # noqa: E501\n            'reminder_date': (datetime, none_type),  # noqa: E501\n            'customer': (CustomerObject, none_type),  # noqa: E501\n            'customer_notification_preference': (NotificationPreference, none_type),  # noqa: E501\n            'fees': ([InvoiceFee], none_type),  # noqa: E501\n            'channel_properties': (ChannelProperties, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'external_id': 'external_id',  # noqa: E501\n        'user_id': 'user_id',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'merchant_name': 'merchant_name',  # noqa: E501\n        'merchant_profile_picture_url': 'merchant_profile_picture_url',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'expiry_date': 'expiry_date',  # noqa: E501\n        'invoice_url': 'invoice_url',  # noqa: E501\n        'available_banks': 'available_banks',  # noqa: E501\n        'available_retail_outlets': 'available_retail_outlets',  # noqa: E501\n        'available_ewallets': 'available_ewallets',  # noqa: E501\n        'available_qr_codes': 'available_qr_codes',  # noqa: E501\n        'available_direct_debits': 'available_direct_debits',  # noqa: E501\n        'available_paylaters': 'available_paylaters',  # noqa: E501\n        'should_send_email': 'should_send_email',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'id': 'id',  # noqa: E501\n        'payer_email': 'payer_email',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'payment_method': 'payment_method',  # noqa: E501\n        'locale': 'locale',  # noqa: E501\n        'should_exclude_credit_card': 'should_exclude_credit_card',  # noqa: E501\n        'success_redirect_url': 'success_redirect_url',  # noqa: E501\n        'failure_redirect_url': 'failure_redirect_url',  # noqa: E501\n        'should_authenticate_credit_card': 'should_authenticate_credit_card',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'items': 'items',  # noqa: E501\n        'fixed_va': 'fixed_va',  # noqa: E501\n        'reminder_date': 'reminder_date',  # noqa: E501\n        'customer': 'customer',  # noqa: E501\n        'customer_notification_preference': 'customer_notification_preference',  # noqa: E501\n        'fees': 'fees',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, external_id, user_id, status, merchant_name, merchant_profile_picture_url, amount, expiry_date, invoice_url, available_banks, available_retail_outlets, available_ewallets, available_qr_codes, available_direct_debits, available_paylaters, should_send_email, created, updated, *args, **kwargs):  # noqa: E501\n        \"\"\"Invoice - a model defined in OpenAPI\n\n        Args:\n            external_id (str): The external identifier for the invoice.\n            user_id (str): The user ID associated with the invoice.\n            status (InvoiceStatus):\n            merchant_name (str): The name of the merchant.\n            merchant_profile_picture_url (str): The URL of the merchant's profile picture.\n            amount (float): The total amount of the invoice.\n            expiry_date (datetime): Representing a date and time in ISO 8601 format.\n            invoice_url (str): The URL to view the invoice.\n            available_banks ([Bank]): An array of available banks for payment.\n            available_retail_outlets ([RetailOutlet]): An array of available retail outlets for payment.\n            available_ewallets ([Ewallet]): An array of available e-wallets for payment.\n            available_qr_codes ([QrCode]): An array of available QR codes for payment.\n            available_direct_debits ([DirectDebit]): An array of available direct debit options for payment.\n            available_paylaters ([Paylater]): An array of available pay-later options for payment.\n            should_send_email (bool): Indicates whether email notifications should be sent.\n            created (datetime): Representing a date and time in ISO 8601 format.\n            updated (datetime): Representing a date and time in ISO 8601 format.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            id (str): The unique identifier for the invoice.. [optional]  # noqa: E501\n            payer_email (str): The email address of the payer.. [optional]  # noqa: E501\n            description (str): A description of the invoice.. [optional]  # noqa: E501\n            payment_method (InvoicePaymentMethod): [optional]  # noqa: E501\n            locale (str): The locale or language used for the invoice.. [optional]  # noqa: E501\n            should_exclude_credit_card (bool): Indicates whether credit card payments should be excluded.. [optional]  # noqa: E501\n            success_redirect_url (str): The URL to redirect to on successful payment.. [optional]  # noqa: E501\n            failure_redirect_url (str): The URL to redirect to on payment failure.. [optional]  # noqa: E501\n            should_authenticate_credit_card (bool): Indicates whether credit card authentication is required.. [optional]  # noqa: E501\n            currency (InvoiceCurrency): [optional]  # noqa: E501\n            items ([InvoiceItem]): An array of items included in the invoice.. [optional]  # noqa: E501\n            fixed_va (bool): Indicates whether the virtual account is fixed.. [optional]  # noqa: E501\n            reminder_date (datetime): Representing a date and time in ISO 8601 format.. [optional]  # noqa: E501\n            customer (CustomerObject): [optional]  # noqa: E501\n            customer_notification_preference (NotificationPreference): [optional]  # noqa: E501\n            fees ([InvoiceFee]): An array of fees associated with the invoice.. [optional]  # noqa: E501\n            channel_properties (ChannelProperties): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): A free-format JSON for additional information that you may use. Object can be up to 50 keys, with key names up to 40 characters long and values up to 500 characters long.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.external_id = external_id\n        self.user_id = user_id\n        self.status = status\n        self.merchant_name = merchant_name\n        self.merchant_profile_picture_url = merchant_profile_picture_url\n        self.amount = amount\n        self.expiry_date = expiry_date\n        self.invoice_url = invoice_url\n        self.available_banks = available_banks\n        self.available_retail_outlets = available_retail_outlets\n        self.available_ewallets = available_ewallets\n        self.available_qr_codes = available_qr_codes\n        self.available_direct_debits = available_direct_debits\n        self.available_paylaters = available_paylaters\n        self.should_send_email = should_send_email\n        self.created = created\n        self.updated = updated\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        external_id: str,\n        user_id: str,\n        status: InvoiceStatus,\n        merchant_name: str,\n        merchant_profile_picture_url: str,\n        amount: float,\n        expiry_date: datetime,\n        invoice_url: str,\n        available_banks: list,\n        available_retail_outlets: list,\n        available_ewallets: list,\n        available_qr_codes: list,\n        available_direct_debits: list,\n        available_paylaters: list,\n        should_send_email: bool,\n        created: datetime,\n        updated: datetime,\n        id: str | None = None,\n        payer_email: str | None = None,\n        description: str | None = None,\n        payment_method: InvoicePaymentMethod | None = None,\n        locale: str | None = None,\n        should_exclude_credit_card: bool | None = None,\n        success_redirect_url: str | None = None,\n        failure_redirect_url: str | None = None,\n        should_authenticate_credit_card: bool | None = None,\n        currency: InvoiceCurrency | None = None,\n        items: list | None = None,\n        fixed_va: bool | None = None,\n        reminder_date: datetime | None = None,\n        customer: CustomerObject | None = None,\n        customer_notification_preference: NotificationPreference | None = None,\n        fees: list | None = None,\n        channel_properties: ChannelProperties | None = None,\n        metadata: dict | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Invoice - a model defined in OpenAPI\n\n        Args:\n            external_id (str): The external identifier for the invoice.\n            user_id (str): The user ID associated with the invoice.\n            status (InvoiceStatus):\n            merchant_name (str): The name of the merchant.\n            merchant_profile_picture_url (str): The URL of the merchant's profile picture.\n            amount (float): The total amount of the invoice.\n            expiry_date (datetime): Representing a date and time in ISO 8601 format.\n            invoice_url (str): The URL to view the invoice.\n            available_banks ([Bank]): An array of available banks for payment.\n            available_retail_outlets ([RetailOutlet]): An array of available retail outlets for payment.\n            available_ewallets ([Ewallet]): An array of available e-wallets for payment.\n            available_qr_codes ([QrCode]): An array of available QR codes for payment.\n            available_direct_debits ([DirectDebit]): An array of available direct debit options for payment.\n            available_paylaters ([Paylater]): An array of available pay-later options for payment.\n            should_send_email (bool): Indicates whether email notifications should be sent.\n            created (datetime): Representing a date and time in ISO 8601 format.\n            updated (datetime): Representing a date and time in ISO 8601 format.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            id (str): The unique identifier for the invoice.. [optional]  # noqa: E501\n            payer_email (str): The email address of the payer.. [optional]  # noqa: E501\n            description (str): A description of the invoice.. [optional]  # noqa: E501\n            payment_method (InvoicePaymentMethod): [optional]  # noqa: E501\n            locale (str): The locale or language used for the invoice.. [optional]  # noqa: E501\n            should_exclude_credit_card (bool): Indicates whether credit card payments should be excluded.. [optional]  # noqa: E501\n            success_redirect_url (str): The URL to redirect to on successful payment.. [optional]  # noqa: E501\n            failure_redirect_url (str): The URL to redirect to on payment failure.. [optional]  # noqa: E501\n            should_authenticate_credit_card (bool): Indicates whether credit card authentication is required.. [optional]  # noqa: E501\n            currency (InvoiceCurrency): [optional]  # noqa: E501\n            items ([InvoiceItem]): An array of items included in the invoice.. [optional]  # noqa: E501\n            fixed_va (bool): Indicates whether the virtual account is fixed.. [optional]  # noqa: E501\n            reminder_date (datetime): Representing a date and time in ISO 8601 format.. [optional]  # noqa: E501\n            customer (CustomerObject): [optional]  # noqa: E501\n            customer_notification_preference (NotificationPreference): [optional]  # noqa: E501\n            fees ([InvoiceFee]): An array of fees associated with the invoice.. [optional]  # noqa: E501\n            channel_properties (ChannelProperties): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): A free-format JSON for additional information that you may use. Object can be up to 50 keys, with key names up to 40 characters long and values up to 500 characters long.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.external_id = external_id\n        self.user_id = user_id\n        self.status = status\n        self.merchant_name = merchant_name\n        self.merchant_profile_picture_url = merchant_profile_picture_url\n        self.amount = amount\n        self.expiry_date = expiry_date\n        self.invoice_url = invoice_url\n        self.available_banks = available_banks\n        self.available_retail_outlets = available_retail_outlets\n        self.available_ewallets = available_ewallets\n        self.available_qr_codes = available_qr_codes\n        self.available_direct_debits = available_direct_debits\n        self.available_paylaters = available_paylaters\n        self.should_send_email = should_send_email\n        self.created = created\n        self.updated = updated\n        if id is not None:\n            self.id = id\n        if payer_email is not None:\n            self.payer_email = payer_email\n        if description is not None:\n            self.description = description\n        if payment_method is not None:\n            self.payment_method = payment_method\n        if locale is not None:\n            self.locale = locale\n        if should_exclude_credit_card is not None:\n            self.should_exclude_credit_card = should_exclude_credit_card\n        if success_redirect_url is not None:\n            self.success_redirect_url = success_redirect_url\n        if failure_redirect_url is not None:\n            self.failure_redirect_url = failure_redirect_url\n        if should_authenticate_credit_card is not None:\n            self.should_authenticate_credit_card = should_authenticate_credit_card\n        if currency is not None:\n            self.currency = currency\n        if items is not None:\n            self.items = items\n        if fixed_va is not None:\n            self.fixed_va = fixed_va\n        if reminder_date is not None:\n            self.reminder_date = reminder_date\n        if customer is not None:\n            self.customer = customer\n        if customer_notification_preference is not None:\n            self.customer_notification_preference = customer_notification_preference\n        if fees is not None:\n            self.fees = fees\n        if channel_properties is not None:\n            self.channel_properties = channel_properties\n        if metadata is not None:\n            self.metadata = metadata\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      95,
      96,
      110,
      111,
      151,
      272,
      273,
      274,
      275,
      276,
      278,
      280,
      281,
      282,
      283,
      284,
      285,
      287,
      296,
      297,
      298,
      299,
      300,
      301,
      303,
      304,
      305,
      306,
      307,
      308,
      309,
      310,
      311,
      312,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      326,
      327,
      328,
      451,
      452,
      453,
      454,
      455,
      457,
      458,
      459,
      460,
      461,
      462,
      464,
      473,
      474,
      475,
      476,
      477,
      478,
      480,
      481,
      482,
      483,
      484,
      485,
      486,
      487,
      488,
      489,
      490,
      491,
      492,
      493,
      494,
      495,
      496,
      497,
      498,
      499,
      500,
      501,
      502,
      503,
      504,
      505,
      506,
      507,
      508,
      509,
      510,
      511,
      512,
      513,
      514,
      515,
      516,
      517,
      518,
      519,
      520,
      521,
      522,
      523,
      524,
      525,
      526,
      527,
      528,
      529,
      530,
      531,
      532,
      533,
      534,
      539,
      540,
      541,
      542
    ]
  },
  {
    "file_path": "xendit/invoice/model/invoice_callback.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.invoice_callback_item import InvoiceCallbackItem\nfrom xendit.invoice.model.invoice_fee import InvoiceFee\nfrom xendit.invoice.model.payment_details import PaymentDetails\nglobals()['InvoiceCallbackItem'] = InvoiceCallbackItem\nglobals()['InvoiceFee'] = InvoiceFee\nglobals()['PaymentDetails'] = PaymentDetails\n\ndef lazy_import():\n    pass\n\nclass InvoiceCallback(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'id': (str,),  # noqa: E501\n            'external_id': (str,),  # noqa: E501\n            'user_id': (str,),  # noqa: E501\n            'status': (str,),  # noqa: E501\n            'merchant_name': (str,),  # noqa: E501\n            'amount': (float,),  # noqa: E501\n            'created': (str,),  # noqa: E501\n            'updated': (str,),  # noqa: E501\n            'currency': (str,),  # noqa: E501\n            'payer_email': (str, none_type),  # noqa: E501\n            'description': (str, none_type),  # noqa: E501\n            'paid_amount': (float, none_type),  # noqa: E501\n            'paid_at': (str, none_type),  # noqa: E501\n            'payment_method': (str, none_type),  # noqa: E501\n            'payment_channel': (str, none_type),  # noqa: E501\n            'payment_destination': (str, none_type),  # noqa: E501\n            'payment_details': (PaymentDetails, none_type),  # noqa: E501\n            'payment_id': (str, none_type),  # noqa: E501\n            'success_redirect_url': (str, none_type),  # noqa: E501\n            'failure_redirect_url': (str, none_type),  # noqa: E501\n            'credit_card_charge_id': (str, none_type),  # noqa: E501\n            'items': ([InvoiceCallbackItem], none_type),  # noqa: E501\n            'fees': ([InvoiceFee], none_type),  # noqa: E501\n            'should_authenticate_credit_card': (bool, none_type),  # noqa: E501\n            'bank_code': (str, none_type),  # noqa: E501\n            'ewallet_type': (str, none_type),  # noqa: E501\n            'on_demand_link': (str, none_type),  # noqa: E501\n            'recurring_payment_id': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'id': 'id',  # noqa: E501\n        'external_id': 'external_id',  # noqa: E501\n        'user_id': 'user_id',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'merchant_name': 'merchant_name',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'payer_email': 'payer_email',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'paid_amount': 'paid_amount',  # noqa: E501\n        'paid_at': 'paid_at',  # noqa: E501\n        'payment_method': 'payment_method',  # noqa: E501\n        'payment_channel': 'payment_channel',  # noqa: E501\n        'payment_destination': 'payment_destination',  # noqa: E501\n        'payment_details': 'payment_details',  # noqa: E501\n        'payment_id': 'payment_id',  # noqa: E501\n        'success_redirect_url': 'success_redirect_url',  # noqa: E501\n        'failure_redirect_url': 'failure_redirect_url',  # noqa: E501\n        'credit_card_charge_id': 'credit_card_charge_id',  # noqa: E501\n        'items': 'items',  # noqa: E501\n        'fees': 'fees',  # noqa: E501\n        'should_authenticate_credit_card': 'should_authenticate_credit_card',  # noqa: E501\n        'bank_code': 'bank_code',  # noqa: E501\n        'ewallet_type': 'ewallet_type',  # noqa: E501\n        'on_demand_link': 'on_demand_link',  # noqa: E501\n        'recurring_payment_id': 'recurring_payment_id',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, id, external_id, user_id, status, merchant_name, amount, created, updated, currency, *args, **kwargs):  # noqa: E501\n        \"\"\"InvoiceCallback - a model defined in OpenAPI\n\n        Args:\n            id (str): An invoice ID generated by Xendit\n            external_id (str): ID of your choice (typically the unique identifier of an invoice in your system)\n            user_id (str): Xendit Business ID\n            status (str): The status of the invoice.\n            merchant_name (str): The name of company or website\n            amount (float): Nominal amount for the invoice\n            created (str): The date and time when the invoice was created.\n            updated (str): The date and time when the invoice was last updated.\n            currency (str): The currency of the invoice.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payer_email (str): Email of the payer. [optional]  # noqa: E501\n            description (str): Description for the invoice. [optional]  # noqa: E501\n            paid_amount (float): Total amount paid for the invoice. [optional]  # noqa: E501\n            paid_at (str): The date and time when the invoice was paid.. [optional]  # noqa: E501\n            payment_method (str): The payment method used for the invoice.. [optional]  # noqa: E501\n            payment_channel (str): The payment channel.. [optional]  # noqa: E501\n            payment_destination (str): The payment destination.. [optional]  # noqa: E501\n            payment_details (PaymentDetails): [optional]  # noqa: E501\n            payment_id (str): The ID of the payment.. [optional]  # noqa: E501\n            success_redirect_url (str): The URL to redirect to on successful payment.. [optional]  # noqa: E501\n            failure_redirect_url (str): The URL to redirect to on payment failure.. [optional]  # noqa: E501\n            credit_card_charge_id (str): The ID associated with a credit card charge (if applicable).. [optional]  # noqa: E501\n            items ([InvoiceCallbackItem]): [optional]  # noqa: E501\n            fees ([InvoiceFee]): An array of fees associated with the invoice.. [optional]  # noqa: E501\n            should_authenticate_credit_card (bool): Indicates whether credit card authentication is required.. [optional]  # noqa: E501\n            bank_code (str): The bank code for the bank details.. [optional]  # noqa: E501\n            ewallet_type (str): The type of eWallet.. [optional]  # noqa: E501\n            on_demand_link (str): The on-demand link.. [optional]  # noqa: E501\n            recurring_payment_id (str): The ID of the recurring payment.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.external_id = external_id\n        self.user_id = user_id\n        self.status = status\n        self.merchant_name = merchant_name\n        self.amount = amount\n        self.created = created\n        self.updated = updated\n        self.currency = currency\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        id: str,\n        external_id: str,\n        user_id: str,\n        status: str,\n        merchant_name: str,\n        amount: float,\n        created: str,\n        updated: str,\n        currency: str,\n        payer_email: str | None = None,\n        description: str | None = None,\n        paid_amount: float | None = None,\n        paid_at: str | None = None,\n        payment_method: str | None = None,\n        payment_channel: str | None = None,\n        payment_destination: str | None = None,\n        payment_details: PaymentDetails | None = None,\n        payment_id: str | None = None,\n        success_redirect_url: str | None = None,\n        failure_redirect_url: str | None = None,\n        credit_card_charge_id: str | None = None,\n        items: list | None = None,\n        fees: list | None = None,\n        should_authenticate_credit_card: bool | None = None,\n        bank_code: str | None = None,\n        ewallet_type: str | None = None,\n        on_demand_link: str | None = None,\n        recurring_payment_id: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"InvoiceCallback - a model defined in OpenAPI\n\n        Args:\n            id (str): An invoice ID generated by Xendit\n            external_id (str): ID of your choice (typically the unique identifier of an invoice in your system)\n            user_id (str): Xendit Business ID\n            status (str): The status of the invoice.\n            merchant_name (str): The name of company or website\n            amount (float): Nominal amount for the invoice\n            created (str): The date and time when the invoice was created.\n            updated (str): The date and time when the invoice was last updated.\n            currency (str): The currency of the invoice.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payer_email (str): Email of the payer. [optional]  # noqa: E501\n            description (str): Description for the invoice. [optional]  # noqa: E501\n            paid_amount (float): Total amount paid for the invoice. [optional]  # noqa: E501\n            paid_at (str): The date and time when the invoice was paid.. [optional]  # noqa: E501\n            payment_method (str): The payment method used for the invoice.. [optional]  # noqa: E501\n            payment_channel (str): The payment channel.. [optional]  # noqa: E501\n            payment_destination (str): The payment destination.. [optional]  # noqa: E501\n            payment_details (PaymentDetails): [optional]  # noqa: E501\n            payment_id (str): The ID of the payment.. [optional]  # noqa: E501\n            success_redirect_url (str): The URL to redirect to on successful payment.. [optional]  # noqa: E501\n            failure_redirect_url (str): The URL to redirect to on payment failure.. [optional]  # noqa: E501\n            credit_card_charge_id (str): The ID associated with a credit card charge (if applicable).. [optional]  # noqa: E501\n            items ([InvoiceCallbackItem]): [optional]  # noqa: E501\n            fees ([InvoiceFee]): An array of fees associated with the invoice.. [optional]  # noqa: E501\n            should_authenticate_credit_card (bool): Indicates whether credit card authentication is required.. [optional]  # noqa: E501\n            bank_code (str): The bank code for the bank details.. [optional]  # noqa: E501\n            ewallet_type (str): The type of eWallet.. [optional]  # noqa: E501\n            on_demand_link (str): The on-demand link.. [optional]  # noqa: E501\n            recurring_payment_id (str): The ID of the recurring payment.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.external_id = external_id\n        self.user_id = user_id\n        self.status = status\n        self.merchant_name = merchant_name\n        self.amount = amount\n        self.created = created\n        self.updated = updated\n        self.currency = currency\n        if payer_email is not None:\n            self.payer_email = payer_email\n        if description is not None:\n            self.description = description\n        if paid_amount is not None:\n            self.paid_amount = paid_amount\n        if paid_at is not None:\n            self.paid_at = paid_at\n        if payment_method is not None:\n            self.payment_method = payment_method\n        if payment_channel is not None:\n            self.payment_channel = payment_channel\n        if payment_destination is not None:\n            self.payment_destination = payment_destination\n        if payment_details is not None:\n            self.payment_details = payment_details\n        if payment_id is not None:\n            self.payment_id = payment_id\n        if success_redirect_url is not None:\n            self.success_redirect_url = success_redirect_url\n        if failure_redirect_url is not None:\n            self.failure_redirect_url = failure_redirect_url\n        if credit_card_charge_id is not None:\n            self.credit_card_charge_id = credit_card_charge_id\n        if items is not None:\n            self.items = items\n        if fees is not None:\n            self.fees = fees\n        if should_authenticate_credit_card is not None:\n            self.should_authenticate_credit_card = should_authenticate_credit_card\n        if bank_code is not None:\n            self.bank_code = bank_code\n        if ewallet_type is not None:\n            self.ewallet_type = ewallet_type\n        if on_demand_link is not None:\n            self.on_demand_link = on_demand_link\n        if recurring_payment_id is not None:\n            self.recurring_payment_id = recurring_payment_id\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      73,
      74,
      88,
      89,
      122,
      229,
      230,
      231,
      232,
      233,
      235,
      237,
      238,
      239,
      240,
      241,
      242,
      244,
      253,
      254,
      255,
      256,
      257,
      258,
      260,
      261,
      262,
      263,
      264,
      265,
      266,
      267,
      268,
      269,
      270,
      275,
      276,
      277,
      386,
      387,
      388,
      389,
      390,
      392,
      393,
      394,
      395,
      396,
      397,
      399,
      408,
      409,
      410,
      411,
      412,
      413,
      415,
      416,
      417,
      418,
      419,
      420,
      421,
      422,
      423,
      424,
      425,
      426,
      427,
      428,
      429,
      430,
      431,
      432,
      433,
      434,
      435,
      436,
      437,
      438,
      439,
      440,
      441,
      442,
      443,
      444,
      445,
      446,
      447,
      448,
      449,
      450,
      451,
      452,
      453,
      454,
      455,
      456,
      457,
      458,
      459,
      460,
      461,
      462,
      463,
      468,
      469,
      470,
      471
    ]
  },
  {
    "file_path": "xendit/invoice/model/invoice_callback_item.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass InvoiceCallbackItem(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('quantity',): {\n            'exclusive_minimum''inclusive_minimum': 0,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'name': (str,),  # noqa: E501\n            'price': (float,),  # noqa: E501\n            'quantity': (float,),  # noqa: E501\n            'url': (str, none_type),  # noqa: E501\n            'category': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'name': 'name',  # noqa: E501\n        'price': 'price',  # noqa: E501\n        'quantity': 'quantity',  # noqa: E501\n        'url': 'url',  # noqa: E501\n        'category': 'category',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, name, price, quantity, *args, **kwargs):  # noqa: E501\n        \"\"\"InvoiceCallbackItem - a model defined in OpenAPI\n\n        Args:\n            name (str): The name of the item.\n            price (float): The price of the item.\n            quantity (float): The quantity of the item. Must be greater than or equal to 0.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            url (str): The URL associated with the item.. [optional]  # noqa: E501\n            category (str): The category of the item.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.name = name\n        self.price = price\n        self.quantity = quantity\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        name: str,\n        price: float,\n        quantity: float,\n        url: str | None = None,\n        category: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"InvoiceCallbackItem - a model defined in OpenAPI\n\n        Args:\n            name (str): The name of the item.\n            price (float): The price of the item.\n            quantity (float): The quantity of the item. Must be greater than or equal to 0.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            url (str): The URL associated with the item.. [optional]  # noqa: E501\n            category (str): The category of the item.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.name = name\n        self.price = price\n        self.quantity = quantity\n        if url is not None:\n            self.url = url\n        if category is not None:\n            self.category = category\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      94,
      155,
      156,
      157,
      158,
      159,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      186,
      187,
      188,
      189,
      190,
      195,
      196,
      197,
      260,
      261,
      262,
      263,
      264,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      282,
      283,
      284,
      285,
      286,
      287,
      289,
      290,
      291,
      292,
      293,
      294,
      295,
      296,
      297,
      302,
      303,
      304,
      305
    ]
  },
  {
    "file_path": "xendit/invoice/model/invoice_client_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass InvoiceClientType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'DASHBOARD': \"DASHBOARD\",\n            'API_GATEWAY': \"API_GATEWAY\",\n            'INTEGRATION': \"INTEGRATION\",\n            'ON_DEMAND': \"ON_DEMAND\",\n            'RECURRING': \"RECURRING\",\n            'MOBILE': \"MOBILE\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"InvoiceClientType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the client type or source of an invoice.., must be one of [\"DASHBOARD\", \"API_GATEWAY\", \"INTEGRATION\", \"ON_DEMAND\", \"RECURRING\", \"MOBILE\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the client type or source of an invoice.., must be one of [\"DASHBOARD\", \"API_GATEWAY\", \"INTEGRATION\", \"ON_DEMAND\", \"RECURRING\", \"MOBILE\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"InvoiceClientType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the client type or source of an invoice.., must be one of [\"DASHBOARD\", \"API_GATEWAY\", \"INTEGRATION\", \"ON_DEMAND\", \"RECURRING\", \"MOBILE\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the client type or source of an invoice.., must be one of [\"DASHBOARD\", \"API_GATEWAY\", \"INTEGRATION\", \"ON_DEMAND\", \"RECURRING\", \"MOBILE\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      80,
      86,
      147,
      149,
      150,
      151,
      152,
      153,
      155,
      161,
      162,
      163,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      243,
      245,
      247,
      248,
      249,
      250,
      251,
      253,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      271,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      300
    ]
  },
  {
    "file_path": "xendit/invoice/model/invoice_currency.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass InvoiceCurrency(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'IDR': \"IDR\",\n            'USD': \"USD\",\n            'THB': \"THB\",\n            'VND': \"VND\",\n            'PHP': \"PHP\",\n            'MYR': \"MYR\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"InvoiceCurrency - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the currency used for an invoice.., must be one of [\"IDR\", \"USD\", \"THB\", \"VND\", \"PHP\", \"MYR\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the currency used for an invoice.., must be one of [\"IDR\", \"USD\", \"THB\", \"VND\", \"PHP\", \"MYR\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"InvoiceCurrency - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the currency used for an invoice.., must be one of [\"IDR\", \"USD\", \"THB\", \"VND\", \"PHP\", \"MYR\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the currency used for an invoice.., must be one of [\"IDR\", \"USD\", \"THB\", \"VND\", \"PHP\", \"MYR\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      80,
      86,
      147,
      149,
      150,
      151,
      152,
      153,
      155,
      161,
      162,
      163,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      243,
      245,
      247,
      248,
      249,
      250,
      251,
      253,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      271,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      300
    ]
  },
  {
    "file_path": "xendit/invoice/model/invoice_error404_response_definition.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass InvoiceError404ResponseDefinition(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'INVOICE_NOT_FOUND_ERROR': \"INVOICE_NOT_FOUND_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str,),  # noqa: E501\n            'message': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, message, *args, **kwargs):  # noqa: E501\n        \"\"\"InvoiceError404ResponseDefinition - a model defined in OpenAPI\n\n        Args:\n            message (str): A human-readable error message providing additional context about the resource not being found.\n\n        Keyword Args:\n            error_code (str): The specific error code indicating that the requested invoice was not found.. defaults to \"INVOICE_NOT_FOUND_ERROR\", must be one of [\"INVOICE_NOT_FOUND_ERROR\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        error_code = kwargs.get('error_code', \"INVOICE_NOT_FOUND_ERROR\")\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        message: str,\n        error_code: str = \"INVOICE_NOT_FOUND_ERROR\",\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"InvoiceError404ResponseDefinition - a model defined in OpenAPI\n\n        Args:\n            message (str): A human-readable error message providing additional context about the resource not being found.\n\n\n        Keyword Args:\n            error_code (str): The specific error code indicating that the requested invoice was not found.. defaults to \"INVOICE_NOT_FOUND_ERROR\", must be one of [\"INVOICE_NOT_FOUND_ERROR\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      91,
      146,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      180,
      181,
      186,
      187,
      188,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      282,
      283,
      284,
      285
    ]
  },
  {
    "file_path": "xendit/invoice/model/invoice_fee.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass InvoiceFee(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'type': (str,),  # noqa: E501\n            'value': (float,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'type': 'type',  # noqa: E501\n        'value': 'value',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, type, value, *args, **kwargs):  # noqa: E501\n        \"\"\"InvoiceFee - a model defined in OpenAPI\n\n        Args:\n            type (str): The type of fee.\n            value (float): The value or amount of the fee.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        self.value = value\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        type: str,\n        value: float,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"InvoiceFee - a model defined in OpenAPI\n\n        Args:\n            type (str): The type of fee.\n            value (float): The value or amount of the fee.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        self.value = value\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      143,
      144,
      145,
      146,
      147,
      149,
      151,
      152,
      153,
      154,
      155,
      156,
      158,
      167,
      168,
      169,
      170,
      171,
      172,
      174,
      175,
      176,
      177,
      182,
      183,
      184,
      241,
      242,
      243,
      244,
      245,
      247,
      248,
      249,
      250,
      251,
      252,
      254,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/invoice/model/invoice_item.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass InvoiceItem(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('quantity',): {\n            'exclusive_minimum''inclusive_minimum': 0,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'name': (str,),  # noqa: E501\n            'price': (float,),  # noqa: E501\n            'quantity': (float,),  # noqa: E501\n            'reference_id': (str, none_type),  # noqa: E501\n            'url': (str, none_type),  # noqa: E501\n            'category': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'name': 'name',  # noqa: E501\n        'price': 'price',  # noqa: E501\n        'quantity': 'quantity',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'url': 'url',  # noqa: E501\n        'category': 'category',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, name, price, quantity, *args, **kwargs):  # noqa: E501\n        \"\"\"InvoiceItem - a model defined in OpenAPI\n\n        Args:\n            name (str): The name of the item.\n            price (float): The price of the item.\n            quantity (float): The quantity of the item. Must be greater than or equal to 0.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            reference_id (str): The reference ID of the item.. [optional]  # noqa: E501\n            url (str): The URL associated with the item.. [optional]  # noqa: E501\n            category (str): The category of the item.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.name = name\n        self.price = price\n        self.quantity = quantity\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        name: str,\n        price: float,\n        quantity: float,\n        reference_id: str | None = None,\n        url: str | None = None,\n        category: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"InvoiceItem - a model defined in OpenAPI\n\n        Args:\n            name (str): The name of the item.\n            price (float): The price of the item.\n            quantity (float): The quantity of the item. Must be greater than or equal to 0.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            reference_id (str): The reference ID of the item.. [optional]  # noqa: E501\n            url (str): The URL associated with the item.. [optional]  # noqa: E501\n            category (str): The category of the item.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.name = name\n        self.price = price\n        self.quantity = quantity\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if url is not None:\n            self.url = url\n        if category is not None:\n            self.category = category\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      95,
      158,
      159,
      160,
      161,
      162,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      182,
      183,
      184,
      185,
      186,
      187,
      189,
      190,
      191,
      192,
      193,
      198,
      199,
      200,
      265,
      266,
      267,
      268,
      269,
      271,
      272,
      273,
      274,
      275,
      276,
      278,
      287,
      288,
      289,
      290,
      291,
      292,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      309,
      310,
      311,
      312
    ]
  },
  {
    "file_path": "xendit/invoice/model/invoice_not_found_error.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass InvoiceNotFoundError(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'CALLBACK_VIRTUAL_ACCOUNT_NOT_FOUND_ERROR': \"CALLBACK_VIRTUAL_ACCOUNT_NOT_FOUND_ERROR\",\n            'UNIQUE_ACCOUNT_NUMBER_UNAVAILABLE_ERROR': \"UNIQUE_ACCOUNT_NUMBER_UNAVAILABLE_ERROR\",\n            'PAYMENT_CODE_NOT_AVAILABLE_ERROR': \"PAYMENT_CODE_NOT_AVAILABLE_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str,),  # noqa: E501\n            'message': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, error_code, message, *args, **kwargs):  # noqa: E501\n        \"\"\"InvoiceNotFoundError - a model defined in OpenAPI\n\n        Args:\n            error_code (str): The error code indicating the type of error that occurred.\n            message (str): A human-readable error message that provides additional information about the error.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str,\n        message: str,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"InvoiceNotFoundError - a model defined in OpenAPI\n\n        Args:\n            error_code (str): The error code indicating the type of error that occurred.\n            message (str): A human-readable error message that provides additional information about the error.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      72,
      86,
      93,
      148,
      149,
      150,
      151,
      152,
      154,
      156,
      157,
      158,
      159,
      160,
      161,
      163,
      172,
      173,
      174,
      175,
      176,
      177,
      179,
      180,
      181,
      182,
      187,
      188,
      189,
      246,
      247,
      248,
      249,
      250,
      252,
      253,
      254,
      255,
      256,
      257,
      259,
      268,
      269,
      270,
      271,
      272,
      273,
      275,
      276,
      277,
      278,
      283,
      284,
      285,
      286
    ]
  },
  {
    "file_path": "xendit/invoice/model/invoice_payment_method.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass InvoicePaymentMethod(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'POOL': \"POOL\",\n            'CALLBACK_VIRTUAL_ACCOUNT': \"CALLBACK_VIRTUAL_ACCOUNT\",\n            'CREDIT_CARD': \"CREDIT_CARD\",\n            'RETAIL_OUTLET': \"RETAIL_OUTLET\",\n            'QR_CODE': \"QR_CODE\",\n            'QRIS': \"QRIS\",\n            'EWALLET': \"EWALLET\",\n            'DIRECT_DEBIT': \"DIRECT_DEBIT\",\n            'BANK_TRANSFER': \"BANK_TRANSFER\",\n            'PAYLATER': \"PAYLATER\",\n            'CRYPTOCURRENCY': \"CRYPTOCURRENCY\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"InvoicePaymentMethod - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the payment method used for an invoice.., must be one of [\"POOL\", \"CALLBACK_VIRTUAL_ACCOUNT\", \"CREDIT_CARD\", \"RETAIL_OUTLET\", \"QR_CODE\", \"QRIS\", \"EWALLET\", \"DIRECT_DEBIT\", \"BANK_TRANSFER\", \"PAYLATER\", \"CRYPTOCURRENCY\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the payment method used for an invoice.., must be one of [\"POOL\", \"CALLBACK_VIRTUAL_ACCOUNT\", \"CREDIT_CARD\", \"RETAIL_OUTLET\", \"QR_CODE\", \"QRIS\", \"EWALLET\", \"DIRECT_DEBIT\", \"BANK_TRANSFER\", \"PAYLATER\", \"CRYPTOCURRENCY\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"InvoicePaymentMethod - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the payment method used for an invoice.., must be one of [\"POOL\", \"CALLBACK_VIRTUAL_ACCOUNT\", \"CREDIT_CARD\", \"RETAIL_OUTLET\", \"QR_CODE\", \"QRIS\", \"EWALLET\", \"DIRECT_DEBIT\", \"BANK_TRANSFER\", \"PAYLATER\", \"CRYPTOCURRENCY\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the payment method used for an invoice.., must be one of [\"POOL\", \"CALLBACK_VIRTUAL_ACCOUNT\", \"CREDIT_CARD\", \"RETAIL_OUTLET\", \"QR_CODE\", \"QRIS\", \"EWALLET\", \"DIRECT_DEBIT\", \"BANK_TRANSFER\", \"PAYLATER\", \"CRYPTOCURRENCY\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      85,
      91,
      152,
      154,
      155,
      156,
      157,
      158,
      160,
      166,
      167,
      168,
      169,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      248,
      250,
      252,
      253,
      254,
      255,
      256,
      258,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      276,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      294,
      295,
      296,
      305
    ]
  },
  {
    "file_path": "xendit/invoice/model/invoice_status.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass InvoiceStatus(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'PENDING': \"PENDING\",\n            'PAID': \"PAID\",\n            'SETTLED': \"SETTLED\",\n            'EXPIRED': \"EXPIRED\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"InvoiceStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the status of an invoice.., must be one of [\"PENDING\", \"PAID\", \"SETTLED\", \"EXPIRED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the status of an invoice.., must be one of [\"PENDING\", \"PAID\", \"SETTLED\", \"EXPIRED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"InvoiceStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the status of an invoice.., must be one of [\"PENDING\", \"PAID\", \"SETTLED\", \"EXPIRED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the status of an invoice.., must be one of [\"PENDING\", \"PAID\", \"SETTLED\", \"EXPIRED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      78,
      84,
      145,
      147,
      148,
      149,
      150,
      151,
      153,
      159,
      160,
      161,
      162,
      164,
      165,
      166,
      167,
      168,
      169,
      171,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      241,
      243,
      245,
      246,
      247,
      248,
      249,
      251,
      257,
      258,
      259,
      260,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      298
    ]
  },
  {
    "file_path": "xendit/invoice/model/notification_channel.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass NotificationChannel(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'EMAIL': \"email\",\n            'SMS': \"sms\",\n            'WHATSAPP': \"whatsapp\",\n            'VIBER': \"viber\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"NotificationChannel - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing a notification channel for sending messages.., must be one of [\"email\", \"sms\", \"whatsapp\", \"viber\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing a notification channel for sending messages.., must be one of [\"email\", \"sms\", \"whatsapp\", \"viber\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"NotificationChannel - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing a notification channel for sending messages.., must be one of [\"email\", \"sms\", \"whatsapp\", \"viber\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing a notification channel for sending messages.., must be one of [\"email\", \"sms\", \"whatsapp\", \"viber\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      78,
      84,
      145,
      147,
      148,
      149,
      150,
      151,
      153,
      159,
      160,
      161,
      162,
      164,
      165,
      166,
      167,
      168,
      169,
      171,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      241,
      243,
      245,
      246,
      247,
      248,
      249,
      251,
      257,
      258,
      259,
      260,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      298
    ]
  },
  {
    "file_path": "xendit/invoice/model/notification_preference.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.notification_channel import NotificationChannel\nglobals()['NotificationChannel'] = NotificationChannel\n\ndef lazy_import():\n    pass\n\nclass NotificationPreference(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'invoice_created': ([NotificationChannel], none_type),  # noqa: E501\n            'invoice_reminder': ([NotificationChannel], none_type),  # noqa: E501\n            'invoice_paid': ([NotificationChannel], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'invoice_created': 'invoice_created',  # noqa: E501\n        'invoice_reminder': 'invoice_reminder',  # noqa: E501\n        'invoice_paid': 'invoice_paid',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"NotificationPreference - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            invoice_created ([NotificationChannel]): Notification channels for when an invoice is created.. [optional]  # noqa: E501\n            invoice_reminder ([NotificationChannel]): Notification channels for invoice reminders.. [optional]  # noqa: E501\n            invoice_paid ([NotificationChannel]): Notification channels for when an invoice is paid.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        invoice_created: list | None = None,\n        invoice_reminder: list | None = None,\n        invoice_paid: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"NotificationPreference - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            invoice_created ([NotificationChannel]): Notification channels for when an invoice is created.. [optional]  # noqa: E501\n            invoice_reminder ([NotificationChannel]): Notification channels for invoice reminders.. [optional]  # noqa: E501\n            invoice_paid ([NotificationChannel]): Notification channels for when an invoice is paid.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if invoice_created is not None:\n            self.invoice_created = invoice_created\n        if invoice_reminder is not None:\n            self.invoice_reminder = invoice_reminder\n        if invoice_paid is not None:\n            self.invoice_paid = invoice_paid\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      93,
      148,
      149,
      150,
      151,
      152,
      154,
      156,
      157,
      158,
      159,
      160,
      161,
      163,
      172,
      173,
      174,
      175,
      176,
      177,
      179,
      180,
      185,
      186,
      187,
      244,
      245,
      246,
      247,
      248,
      250,
      251,
      252,
      253,
      254,
      255,
      257,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      285,
      286,
      287,
      288
    ]
  },
  {
    "file_path": "xendit/invoice/model/paylater.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.paylater_type import PaylaterType\nglobals()['PaylaterType'] = PaylaterType\n\ndef lazy_import():\n    pass\n\nclass Paylater(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'paylater_type': (PaylaterType,),  # noqa: E501\n            'should_exclude': (bool, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'paylater_type': 'paylater_type',  # noqa: E501\n        'should_exclude': 'should_exclude',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, paylater_type, *args, **kwargs):  # noqa: E501\n        \"\"\"Paylater - a model defined in OpenAPI\n\n        Args:\n            paylater_type (PaylaterType):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            should_exclude (bool): Indicates whether this paylater option should be excluded.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.paylater_type = paylater_type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        paylater_type: PaylaterType,\n        should_exclude: bool | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Paylater - a model defined in OpenAPI\n\n        Args:\n            paylater_type (PaylaterType):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            should_exclude (bool): Indicates whether this paylater option should be excluded.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.paylater_type = paylater_type\n        if should_exclude is not None:\n            self.should_exclude = should_exclude\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      92,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      180,
      185,
      186,
      187,
      244,
      245,
      246,
      247,
      248,
      250,
      251,
      252,
      253,
      254,
      255,
      257,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      274,
      275,
      276,
      277,
      282,
      283,
      284,
      285
    ]
  },
  {
    "file_path": "xendit/invoice/model/paylater_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaylaterType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'KREDIVO': \"KREDIVO\",\n            'AKULAKU': \"AKULAKU\",\n            'UANGME': \"UANGME\",\n            'BILLEASE': \"BILLEASE\",\n            'CASHALO': \"CASHALO\",\n            'ATOME': \"ATOME\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaylaterType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available paylater channels used for invoice-related transactions.., must be one of [\"KREDIVO\", \"AKULAKU\", \"UANGME\", \"BILLEASE\", \"CASHALO\", \"ATOME\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available paylater channels used for invoice-related transactions.., must be one of [\"KREDIVO\", \"AKULAKU\", \"UANGME\", \"BILLEASE\", \"CASHALO\", \"ATOME\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaylaterType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available paylater channels used for invoice-related transactions.., must be one of [\"KREDIVO\", \"AKULAKU\", \"UANGME\", \"BILLEASE\", \"CASHALO\", \"ATOME\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available paylater channels used for invoice-related transactions.., must be one of [\"KREDIVO\", \"AKULAKU\", \"UANGME\", \"BILLEASE\", \"CASHALO\", \"ATOME\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      80,
      86,
      147,
      149,
      150,
      151,
      152,
      153,
      155,
      161,
      162,
      163,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      243,
      245,
      247,
      248,
      249,
      250,
      251,
      253,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      271,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      300
    ]
  },
  {
    "file_path": "xendit/invoice/model/payment_details.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentDetails(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'receipt_id': (str, none_type),  # noqa: E501\n            'source': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'receipt_id': 'receipt_id',  # noqa: E501\n        'source': 'source',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentDetails - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            receipt_id (str): The unique identifier or reference ID associated with the payment receipt.. [optional]  # noqa: E501\n            source (str): The source or method of payment.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        receipt_id: str | None = None,\n        source: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentDetails - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            receipt_id (str): The unique identifier or reference ID associated with the payment receipt.. [optional]  # noqa: E501\n            source (str): The source or method of payment.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if receipt_id is not None:\n            self.receipt_id = receipt_id\n        if source is not None:\n            self.source = source\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/invoice/model/qr_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.qr_code_type import QrCodeType\nglobals()['QrCodeType'] = QrCodeType\n\ndef lazy_import():\n    pass\n\nclass QrCode(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'qr_code_type': (QrCodeType,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'qr_code_type': 'qr_code_type',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, qr_code_type, *args, **kwargs):  # noqa: E501\n        \"\"\"QrCode - a model defined in OpenAPI\n\n        Args:\n            qr_code_type (QrCodeType):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.qr_code_type = qr_code_type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        qr_code_type: QrCodeType,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"QrCode - a model defined in OpenAPI\n\n        Args:\n            qr_code_type (QrCodeType):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.qr_code_type = qr_code_type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      91,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      275,
      276,
      277,
      278
    ]
  },
  {
    "file_path": "xendit/invoice/model/qr_code_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass QrCodeType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'QRIS': \"QRIS\",\n            'PROMPTPAY': \"PROMPTPAY\",\n            'QRPH': \"QRPH\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"QrCodeType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available QR Code channels used for invoice-related transactions.., must be one of [\"QRIS\", \"PROMPTPAY\", \"QRPH\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available QR Code channels used for invoice-related transactions.., must be one of [\"QRIS\", \"PROMPTPAY\", \"QRPH\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"QrCodeType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available QR Code channels used for invoice-related transactions.., must be one of [\"QRIS\", \"PROMPTPAY\", \"QRPH\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available QR Code channels used for invoice-related transactions.., must be one of [\"QRIS\", \"PROMPTPAY\", \"QRPH\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      77,
      83,
      144,
      146,
      147,
      148,
      149,
      150,
      152,
      158,
      159,
      160,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      240,
      242,
      244,
      245,
      246,
      247,
      248,
      250,
      256,
      257,
      258,
      259,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      297
    ]
  },
  {
    "file_path": "xendit/invoice/model/retail_outlet.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.invoice.model.retail_outlet_name import RetailOutletName\nglobals()['RetailOutletName'] = RetailOutletName\n\ndef lazy_import():\n    pass\n\nclass RetailOutlet(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'retail_outlet_name': (RetailOutletName,),  # noqa: E501\n            'payment_code': (str, none_type),  # noqa: E501\n            'transfer_amount': (float, none_type),  # noqa: E501\n            'merchant_name': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'retail_outlet_name': 'retail_outlet_name',  # noqa: E501\n        'payment_code': 'payment_code',  # noqa: E501\n        'transfer_amount': 'transfer_amount',  # noqa: E501\n        'merchant_name': 'merchant_name',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, retail_outlet_name, *args, **kwargs):  # noqa: E501\n        \"\"\"RetailOutlet - a model defined in OpenAPI\n\n        Args:\n            retail_outlet_name (RetailOutletName):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_code (str): The payment code.. [optional]  # noqa: E501\n            transfer_amount (float): The transfer amount.. [optional]  # noqa: E501\n            merchant_name (str): The name of the merchant.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.retail_outlet_name = retail_outlet_name\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        retail_outlet_name: RetailOutletName,\n        payment_code: str | None = None,\n        transfer_amount: float | None = None,\n        merchant_name: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"RetailOutlet - a model defined in OpenAPI\n\n        Args:\n            retail_outlet_name (RetailOutletName):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_code (str): The payment code.. [optional]  # noqa: E501\n            transfer_amount (float): The transfer amount.. [optional]  # noqa: E501\n            merchant_name (str): The name of the merchant.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.retail_outlet_name = retail_outlet_name\n        if payment_code is not None:\n            self.payment_code = payment_code\n        if transfer_amount is not None:\n            self.transfer_amount = transfer_amount\n        if merchant_name is not None:\n            self.merchant_name = merchant_name\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      94,
      153,
      154,
      155,
      156,
      157,
      159,
      161,
      162,
      163,
      164,
      165,
      166,
      168,
      177,
      178,
      179,
      180,
      181,
      182,
      184,
      185,
      186,
      191,
      192,
      193,
      254,
      255,
      256,
      257,
      258,
      260,
      261,
      262,
      263,
      264,
      265,
      267,
      276,
      277,
      278,
      279,
      280,
      281,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      296,
      297,
      298,
      299
    ]
  },
  {
    "file_path": "xendit/invoice/model/retail_outlet_name.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass RetailOutletName(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'ALFAMART': \"ALFAMART\",\n            'INDOMARET': \"INDOMARET\",\n            '7ELEVEN': \"7ELEVEN\",\n            'CEBUANA': \"CEBUANA\",\n            'DP_ECPAY_LOAN': \"DP_ECPAY_LOAN\",\n            'DP_MLHUILLIER': \"DP_MLHUILLIER\",\n            'DP_PALAWAN': \"DP_PALAWAN\",\n            'DP_ECPAY_SCHOOL': \"DP_ECPAY_SCHOOL\",\n            'LBC': \"LBC\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"RetailOutletName - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available retail outlet channels used for invoice-related transactions.., must be one of [\"ALFAMART\", \"INDOMARET\", \"7ELEVEN\", \"CEBUANA\", \"DP_ECPAY_LOAN\", \"DP_MLHUILLIER\", \"DP_PALAWAN\", \"DP_ECPAY_SCHOOL\", \"LBC\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available retail outlet channels used for invoice-related transactions.., must be one of [\"ALFAMART\", \"INDOMARET\", \"7ELEVEN\", \"CEBUANA\", \"DP_ECPAY_LOAN\", \"DP_MLHUILLIER\", \"DP_PALAWAN\", \"DP_ECPAY_SCHOOL\", \"LBC\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"RetailOutletName - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Representing the available retail outlet channels used for invoice-related transactions.., must be one of [\"ALFAMART\", \"INDOMARET\", \"7ELEVEN\", \"CEBUANA\", \"DP_ECPAY_LOAN\", \"DP_MLHUILLIER\", \"DP_PALAWAN\", \"DP_ECPAY_SCHOOL\", \"LBC\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Representing the available retail outlet channels used for invoice-related transactions.., must be one of [\"ALFAMART\", \"INDOMARET\", \"7ELEVEN\", \"CEBUANA\", \"DP_ECPAY_LOAN\", \"DP_MLHUILLIER\", \"DP_PALAWAN\", \"DP_ECPAY_SCHOOL\", \"LBC\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      83,
      89,
      150,
      152,
      153,
      154,
      155,
      156,
      158,
      164,
      165,
      166,
      167,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      246,
      248,
      250,
      251,
      252,
      253,
      254,
      256,
      262,
      263,
      264,
      265,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      294,
      303
    ]
  },
  {
    "file_path": "xendit/invoice/model/server_error.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ServerError(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'SERVER_ERROR': \"SERVER_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str,),  # noqa: E501\n            'message': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, message, *args, **kwargs):  # noqa: E501\n        \"\"\"ServerError - a model defined in OpenAPI\n\n        Args:\n            message (str):\n\n        Keyword Args:\n            error_code (str): defaults to \"SERVER_ERROR\", must be one of [\"SERVER_ERROR\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        error_code = kwargs.get('error_code', \"SERVER_ERROR\")\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        message: str,\n        error_code: str = \"SERVER_ERROR\",\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ServerError - a model defined in OpenAPI\n\n        Args:\n            message (str):\n\n\n        Keyword Args:\n            error_code (str): defaults to \"SERVER_ERROR\", must be one of [\"SERVER_ERROR\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      91,
      146,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      180,
      181,
      186,
      187,
      188,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      282,
      283,
      284,
      285
    ]
  },
  {
    "file_path": "xendit/invoice/model/unauthorized_error.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.9.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass UnauthorizedError(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'INVALID_API_KEY': \"INVALID_API_KEY\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str,),  # noqa: E501\n            'message': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, message, *args, **kwargs):  # noqa: E501\n        \"\"\"UnauthorizedError - a model defined in OpenAPI\n\n        Args:\n            message (str): A human-readable error message providing additional context about the unauthorized access.\n\n        Keyword Args:\n            error_code (str): The specific error code associated with the unauthorized access.. defaults to \"INVALID_API_KEY\", must be one of [\"INVALID_API_KEY\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        error_code = kwargs.get('error_code', \"INVALID_API_KEY\")\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        message: str,\n        error_code: str = \"INVALID_API_KEY\",\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"UnauthorizedError - a model defined in OpenAPI\n\n        Args:\n            message (str): A human-readable error message providing additional context about the unauthorized access.\n\n\n        Keyword Args:\n            error_code (str): The specific error code associated with the unauthorized access.. defaults to \"INVALID_API_KEY\", must be one of [\"INVALID_API_KEY\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      91,
      146,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      180,
      181,
      186,
      187,
      188,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      282,
      283,
      284,
      285
    ]
  },
  {
    "file_path": "xendit/payment_method/payment_method_api.py",
    "code": "\"\"\"\n    Payment Method Service v2\n\n    This API is used for Payment Method Service v2  # noqa: E501\n\n    The version of the OpenAPI document: 2.128.0\n\"\"\"\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\n\nfrom xendit.api_client import ApiClient, Endpoint as _Endpoint\nfrom xendit.model_utils import (  # noqa: F401\n    check_allowed_values,\n    check_validations,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_and_convert_types\n)\nfrom typing import Optional, List # noqa: F401\n\nfrom xendit.payment_method.model import *  # noqa: F401,E501\n\nclass PaymentMethodApi(object):\n    \"\"\"NOTE: This class is auto generated by the OpenAPI Generator.\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None):\n        if api_client is None:\n            api_client = ApiClient()\n        self.api_client = api_client\n        self.create_payment_method_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentMethod,),\n                'auth': [],\n                'endpoint_path': '/v2/payment_methods',\n                'operation_id': 'create_payment_method',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'for_user_id',\n                    'payment_method_parameters',\n                ],\n                'required': [],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'for_user_id':\n                        (str,),\n                    'payment_method_parameters':\n                        (PaymentMethodParameters,),\n                },\n                'attribute_map': {\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'for_user_id': 'header',\n                    'payment_method_parameters': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n        self.get_payment_method_by_id_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentMethod,),\n                'auth': [],\n                'endpoint_path': '/v2/payment_methods/{paymentMethodId}',\n                'operation_id': 'get_payment_method_by_id',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_method_id',\n                    'for_user_id',\n                ],\n                'required': [\n                    'payment_method_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_method_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'payment_method_id': 'paymentMethodId',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'payment_method_id': 'path',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.get_payments_by_payment_method_id_endpoint = _Endpoint(\n            settings={\n                'response_type': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)},),\n                'auth': [],\n                'endpoint_path': '/v2/payment_methods/{paymentMethodId}/payments',\n                'operation_id': 'get_payments_by_payment_method_id',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_method_id',\n                    'for_user_id',\n                    'payment_request_id',\n                    'payment_method_id2',\n                    'reference_id',\n                    'payment_method_type',\n                    'channel_code',\n                    'status',\n                    'currency',\n                    'created_gte',\n                    'created_lte',\n                    'updated_gte',\n                    'updated_lte',\n                    'limit',\n                ],\n                'required': [\n                    'payment_method_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_method_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'payment_request_id':\n                        ([str],),\n                    'payment_method_id2':\n                        ([str],),\n                    'reference_id':\n                        ([str],),\n                    'payment_method_type':\n                        ([PaymentMethodType],),\n                    'channel_code':\n                        ([str],),\n                    'status':\n                        ([str],),\n                    'currency':\n                        ([str],),\n                    'created_gte':\n                        (datetime,),\n                    'created_lte':\n                        (datetime,),\n                    'updated_gte':\n                        (datetime,),\n                    'updated_lte':\n                        (datetime,),\n                    'limit':\n                        (int,),\n                },\n                'attribute_map': {\n                    'payment_method_id': 'paymentMethodId',\n                    'for_user_id': 'for-user-id',\n                    'payment_request_id': 'payment_request_id',\n                    'payment_method_id2': 'payment_method_id',\n                    'reference_id': 'reference_id',\n                    'payment_method_type': 'payment_method_type',\n                    'channel_code': 'channel_code',\n                    'status': 'status',\n                    'currency': 'currency',\n                    'created_gte': 'created[gte]',\n                    'created_lte': 'created[lte]',\n                    'updated_gte': 'updated[gte]',\n                    'updated_lte': 'updated[lte]',\n                    'limit': 'limit',\n                },\n                'location_map': {\n                    'payment_method_id': 'path',\n                    'for_user_id': 'header',\n                    'payment_request_id': 'query',\n                    'payment_method_id2': 'query',\n                    'reference_id': 'query',\n                    'payment_method_type': 'query',\n                    'channel_code': 'query',\n                    'status': 'query',\n                    'currency': 'query',\n                    'created_gte': 'query',\n                    'created_lte': 'query',\n                    'updated_gte': 'query',\n                    'updated_lte': 'query',\n                    'limit': 'query',\n                },\n                'collection_format_map': {\n                    'payment_request_id': 'multi',\n                    'payment_method_id2': 'multi',\n                    'reference_id': 'multi',\n                    'payment_method_type': 'multi',\n                    'channel_code': 'multi',\n                    'status': 'multi',\n                    'currency': 'multi',\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.patch_payment_method_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentMethod,),\n                'auth': [],\n                'endpoint_path': '/v2/payment_methods/{paymentMethodId}',\n                'operation_id': 'patch_payment_method',\n                'http_method': 'PATCH',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_method_id',\n                    'for_user_id',\n                    'payment_method_update_parameters',\n                ],\n                'required': [\n                    'payment_method_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_method_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'payment_method_update_parameters':\n                        (PaymentMethodUpdateParameters,),\n                },\n                'attribute_map': {\n                    'payment_method_id': 'paymentMethodId',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'payment_method_id': 'path',\n                    'for_user_id': 'header',\n                    'payment_method_update_parameters': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n        self.get_all_payment_methods_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentMethodList,),\n                'auth': [],\n                'endpoint_path': '/v2/payment_methods',\n                'operation_id': 'get_all_payment_methods',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'for_user_id',\n                    'id',\n                    'type',\n                    'status',\n                    'reusability',\n                    'customer_id',\n                    'reference_id',\n                    'after_id',\n                    'before_id',\n                    'limit',\n                ],\n                'required': [],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                    'limit',\n                ]\n            },\n            root_map={\n                'validations': {\n                    ('limit',): {\n\n                        'inclusive_minimum': 1,\n                    },\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'for_user_id':\n                        (str,),\n                    'id':\n                        ([str],),\n                    'type':\n                        ([str],),\n                    'status':\n                        ([PaymentMethodStatus],),\n                    'reusability':\n                        (PaymentMethodReusability,),\n                    'customer_id':\n                        (str,),\n                    'reference_id':\n                        (str,),\n                    'after_id':\n                        (str,),\n                    'before_id':\n                        (str,),\n                    'limit':\n                        (int,),\n                },\n                'attribute_map': {\n                    'for_user_id': 'for-user-id',\n                    'id': 'id',\n                    'type': 'type',\n                    'status': 'status',\n                    'reusability': 'reusability',\n                    'customer_id': 'customer_id',\n                    'reference_id': 'reference_id',\n                    'after_id': 'after_id',\n                    'before_id': 'before_id',\n                    'limit': 'limit',\n                },\n                'location_map': {\n                    'for_user_id': 'header',\n                    'id': 'query',\n                    'type': 'query',\n                    'status': 'query',\n                    'reusability': 'query',\n                    'customer_id': 'query',\n                    'reference_id': 'query',\n                    'after_id': 'query',\n                    'before_id': 'query',\n                    'limit': 'query',\n                },\n                'collection_format_map': {\n                    'id': 'multi',\n                    'type': 'multi',\n                    'status': 'multi',\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.expire_payment_method_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentMethod,),\n                'auth': [],\n                'endpoint_path': '/v2/payment_methods/{paymentMethodId}/expire',\n                'operation_id': 'expire_payment_method',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_method_id',\n                    'for_user_id',\n                    'payment_method_expire_parameters',\n                ],\n                'required': [\n                    'payment_method_id',\n                ],\n                'nullable': [\n                    'payment_method_expire_parameters',\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_method_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'payment_method_expire_parameters':\n                        (PaymentMethodExpireParameters,),\n                },\n                'attribute_map': {\n                    'payment_method_id': 'paymentMethodId',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'payment_method_id': 'path',\n                    'for_user_id': 'header',\n                    'payment_method_expire_parameters': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n        self.auth_payment_method_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentMethod,),\n                'auth': [],\n                'endpoint_path': '/v2/payment_methods/{paymentMethodId}/auth',\n                'operation_id': 'auth_payment_method',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_method_id',\n                    'for_user_id',\n                    'payment_method_auth_parameters',\n                ],\n                'required': [\n                    'payment_method_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_method_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'payment_method_auth_parameters':\n                        (PaymentMethodAuthParameters,),\n                },\n                'attribute_map': {\n                    'payment_method_id': 'paymentMethodId',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'payment_method_id': 'path',\n                    'for_user_id': 'header',\n                    'payment_method_auth_parameters': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n        self.simulate_payment_endpoint = _Endpoint(\n            settings={\n                'response_type': None,\n                'auth': [],\n                'endpoint_path': '/v2/payment_methods/{paymentMethodId}/payments/simulate',\n                'operation_id': 'simulate_payment',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_method_id',\n                    'simulate_payment_request',\n                ],\n                'required': [\n                    'payment_method_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_method_id':\n                        (str,),\n                    'simulate_payment_request':\n                        (SimulatePaymentRequest,),\n                },\n                'attribute_map': {\n                    'payment_method_id': 'paymentMethodId',\n                },\n                'location_map': {\n                    'payment_method_id': 'path',\n                    'simulate_payment_request': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n\n    def create_payment_method(\n        self,\n        for_user_id: Optional[str] = None,\n        payment_method_parameters: Optional[PaymentMethodParameters] = None,\n        **kwargs\n    ) -> PaymentMethod:\n        \"\"\"Creates payment method  # noqa: E501\n\n        This endpoint initiates creation of payment method  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.create_payment_method(for_user_id, payment_method_parameters, async_req=True)\n        >>> result = thread.get()\n\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            payment_method_parameters (PaymentMethodParameters): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentMethod\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if payment_method_parameters is not None:\n            kwargs['payment_method_parameters'] = payment_method_parameters\n        return self.create_payment_method_endpoint.call_with_http_info(**kwargs)\n\n    def get_payment_method_by_id(\n        self,\n        payment_method_id: str,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> PaymentMethod:\n        \"\"\"Get payment method by ID  # noqa: E501\n\n        Get payment method by ID  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_payment_method_by_id(payment_method_id, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_method_id (str):\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentMethod\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_method_id'] = payment_method_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.get_payment_method_by_id_endpoint.call_with_http_info(**kwargs)\n\n    def get_payments_by_payment_method_id(\n        self,\n        payment_method_id: str,\n        for_user_id: Optional[str] = None,\n        payment_request_id: Optional[List[str]] = None,\n        payment_method_id2: Optional[List[str]] = None,\n        reference_id: Optional[List[str]] = None,\n        payment_method_type: Optional[List[PaymentMethodType]] = None,\n        channel_code: Optional[List[str]] = None,\n        status: Optional[List[str]] = None,\n        currency: Optional[List[str]] = None,\n        created_gte: Optional[datetime] = None,\n        created_lte: Optional[datetime] = None,\n        updated_gte: Optional[datetime] = None,\n        updated_lte: Optional[datetime] = None,\n        limit: Optional[int] = None,\n        **kwargs\n    ) -> {str: (bool, date, datetime, dict, float, int, list, str, none_type)}:\n        \"\"\"Returns payments with matching PaymentMethodID.  # noqa: E501\n\n        Returns payments with matching PaymentMethodID.  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_payments_by_payment_method_id(payment_method_id, for_user_id, payment_request_id, payment_method_id2, reference_id, payment_method_type, channel_code, status, currency, created_gte, created_lte, updated_gte, updated_lte, limit, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_method_id (str):\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            payment_request_id ([str]): [optional]\n            payment_method_id2 ([str]): [optional]\n            reference_id ([str]): [optional]\n            payment_method_type ([PaymentMethodType]): [optional]\n            channel_code ([str]): [optional]\n            status ([str]): [optional]\n            currency ([str]): [optional]\n            created_gte (datetime): [optional]\n            created_lte (datetime): [optional]\n            updated_gte (datetime): [optional]\n            updated_lte (datetime): [optional]\n            limit (int): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            {str: (bool, date, datetime, dict, float, int, list, str, none_type)}\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_method_id'] = payment_method_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if payment_request_id is not None:\n            kwargs['payment_request_id'] = payment_request_id\n        if payment_method_id2 is not None:\n            kwargs['payment_method_id2'] = payment_method_id2\n        if reference_id is not None:\n            kwargs['reference_id'] = reference_id\n        if payment_method_type is not None:\n            kwargs['payment_method_type'] = payment_method_type\n        if channel_code is not None:\n            kwargs['channel_code'] = channel_code\n        if status is not None:\n            kwargs['status'] = status\n        if currency is not None:\n            kwargs['currency'] = currency\n        if created_gte is not None:\n            kwargs['created_gte'] = created_gte\n        if created_lte is not None:\n            kwargs['created_lte'] = created_lte\n        if updated_gte is not None:\n            kwargs['updated_gte'] = updated_gte\n        if updated_lte is not None:\n            kwargs['updated_lte'] = updated_lte\n        if limit is not None:\n            kwargs['limit'] = limit\n        return self.get_payments_by_payment_method_id_endpoint.call_with_http_info(**kwargs)\n\n    def patch_payment_method(\n        self,\n        payment_method_id: str,\n        for_user_id: Optional[str] = None,\n        payment_method_update_parameters: Optional[PaymentMethodUpdateParameters] = None,\n        **kwargs\n    ) -> PaymentMethod:\n        \"\"\"Patch payment methods  # noqa: E501\n\n        This endpoint is used to toggle the ```status``` of an e-Wallet or a Direct Debit payment method to ```ACTIVE``` or ```INACTIVE```. This is also used to update the details of an Over-the-Counter or a Virtual Account payment method.  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.patch_payment_method(payment_method_id, for_user_id, payment_method_update_parameters, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_method_id (str):\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            payment_method_update_parameters (PaymentMethodUpdateParameters): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentMethod\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_method_id'] = payment_method_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if payment_method_update_parameters is not None:\n            kwargs['payment_method_update_parameters'] = payment_method_update_parameters\n        return self.patch_payment_method_endpoint.call_with_http_info(**kwargs)\n\n    def get_all_payment_methods(\n        self,\n        for_user_id: Optional[str] = None,\n        id: Optional[List[str]] = None,\n        type: Optional[List[str]] = None,\n        status: Optional[List[PaymentMethodStatus]] = None,\n        reusability: Optional[PaymentMethodReusability] = None,\n        customer_id: Optional[str] = None,\n        reference_id: Optional[str] = None,\n        after_id: Optional[str] = None,\n        before_id: Optional[str] = None,\n        limit: Optional[int] = None,\n        **kwargs\n    ) -> PaymentMethodList:\n        \"\"\"Get all payment methods by filters  # noqa: E501\n\n        Get all payment methods by filters  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_all_payment_methods(for_user_id, id, type, status, reusability, customer_id, reference_id, after_id, before_id, limit, async_req=True)\n        >>> result = thread.get()\n\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            id ([str]): [optional]\n            type ([str]): [optional]\n            status ([PaymentMethodStatus]): [optional]\n            reusability (PaymentMethodReusability): [optional]\n            customer_id (str): [optional]\n            reference_id (str): [optional]\n            after_id (str): [optional]\n            before_id (str): [optional]\n            limit (int): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentMethodList\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if id is not None:\n            kwargs['id'] = id\n        if type is not None:\n            kwargs['type'] = type\n        if status is not None:\n            kwargs['status'] = status\n        if reusability is not None:\n            kwargs['reusability'] = reusability\n        if customer_id is not None:\n            kwargs['customer_id'] = customer_id\n        if reference_id is not None:\n            kwargs['reference_id'] = reference_id\n        if after_id is not None:\n            kwargs['after_id'] = after_id\n        if before_id is not None:\n            kwargs['before_id'] = before_id\n        if limit is not None:\n            kwargs['limit'] = limit\n        return self.get_all_payment_methods_endpoint.call_with_http_info(**kwargs)\n\n    def expire_payment_method(\n        self,\n        payment_method_id: str,\n        for_user_id: Optional[str] = None,\n        payment_method_expire_parameters: Optional[PaymentMethodExpireParameters] = None,\n        **kwargs\n    ) -> PaymentMethod:\n        \"\"\"Expires a payment method  # noqa: E501\n\n        This endpoint expires a payment method and performs unlinking if necessary  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.expire_payment_method(payment_method_id, for_user_id, payment_method_expire_parameters, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_method_id (str):\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            payment_method_expire_parameters (PaymentMethodExpireParameters): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentMethod\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_method_id'] = payment_method_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if payment_method_expire_parameters is not None:\n            kwargs['payment_method_expire_parameters'] = payment_method_expire_parameters\n        return self.expire_payment_method_endpoint.call_with_http_info(**kwargs)\n\n    def auth_payment_method(\n        self,\n        payment_method_id: str,\n        for_user_id: Optional[str] = None,\n        payment_method_auth_parameters: Optional[PaymentMethodAuthParameters] = None,\n        **kwargs\n    ) -> PaymentMethod:\n        \"\"\"Validate a payment method's linking OTP  # noqa: E501\n\n        This endpoint validates a payment method linking OTP  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.auth_payment_method(payment_method_id, for_user_id, payment_method_auth_parameters, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_method_id (str):\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            payment_method_auth_parameters (PaymentMethodAuthParameters): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentMethod\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_method_id'] = payment_method_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if payment_method_auth_parameters is not None:\n            kwargs['payment_method_auth_parameters'] = payment_method_auth_parameters\n        return self.auth_payment_method_endpoint.call_with_http_info(**kwargs)\n\n    def simulate_payment(\n        self,\n        payment_method_id: str,\n        simulate_payment_request: Optional[SimulatePaymentRequest] = None,\n        **kwargs\n    ) -> None:\n        \"\"\"Makes payment with matching PaymentMethodID.  # noqa: E501\n\n        Makes payment with matching PaymentMethodID.  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.simulate_payment(payment_method_id, simulate_payment_request, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_method_id (str):\n\n        Keyword Args:\n            simulate_payment_request (SimulatePaymentRequest): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            None\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_method_id'] = payment_method_id\n        if simulate_payment_request is not None:\n            kwargs['simulate_payment_request'] = simulate_payment_request\n        return self.simulate_payment_endpoint.call_with_http_info(**kwargs)\n\n",
    "uncovered_lines": [
      33,
      681,
      769,
      852,
      855,
      858,
      861,
      864,
      867,
      870,
      873,
      875,
      876,
      877,
      878,
      879,
      880,
      881,
      882,
      883,
      884,
      885,
      886,
      887,
      888,
      889,
      890,
      891,
      892,
      893,
      894,
      895,
      896,
      897,
      898,
      899,
      900,
      901,
      902,
      903,
      904,
      964,
      967,
      970,
      973,
      976,
      979,
      982,
      985,
      987,
      988,
      989,
      990,
      991,
      992,
      993,
      994,
      1067,
      1070,
      1073,
      1076,
      1079,
      1082,
      1085,
      1088,
      1090,
      1091,
      1092,
      1093,
      1094,
      1095,
      1096,
      1097,
      1098,
      1099,
      1100,
      1101,
      1102,
      1103,
      1104,
      1105,
      1106,
      1107,
      1108,
      1109,
      1110,
      1111,
      1112,
      1172,
      1175,
      1178,
      1181,
      1184,
      1187,
      1190,
      1193,
      1195,
      1196,
      1197,
      1198,
      1199,
      1200,
      1201,
      1202,
      1262,
      1265,
      1268,
      1271,
      1274,
      1277,
      1280,
      1283,
      1285,
      1286,
      1287,
      1288,
      1289,
      1290,
      1291,
      1292,
      1350,
      1353,
      1356,
      1359,
      1362,
      1365,
      1368,
      1371,
      1373,
      1374,
      1375,
      1376,
      1377,
      1378
    ]
  },
  {
    "file_path": "xendit/payment_method/model/billing_information.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass BillingInformation(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('country',): {\n            'max_length': 2,\n        },\n        ('street_line1',): {\n            'max_length': 255,\n        },\n        ('street_line2',): {\n            'max_length': 255,\n        },\n        ('city',): {\n            'max_length': 255,\n        },\n        ('province_state',): {\n            'max_length': 255,\n        },\n        ('postal_code',): {\n            'max_length': 255,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'country': (str,),  # noqa: E501\n            'street_line1': (str, none_type, none_type),  # noqa: E501\n            'street_line2': (str, none_type, none_type),  # noqa: E501\n            'city': (str, none_type, none_type),  # noqa: E501\n            'province_state': (str, none_type, none_type),  # noqa: E501\n            'postal_code': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'country': 'country',  # noqa: E501\n        'street_line1': 'street_line1',  # noqa: E501\n        'street_line2': 'street_line2',  # noqa: E501\n        'city': 'city',  # noqa: E501\n        'province_state': 'province_state',  # noqa: E501\n        'postal_code': 'postal_code',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, country, *args, **kwargs):  # noqa: E501\n        \"\"\"BillingInformation - a model defined in OpenAPI\n\n        Args:\n            country (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            street_line1 (str, none_type): [optional]  # noqa: E501\n            street_line2 (str, none_type): [optional]  # noqa: E501\n            city (str, none_type): [optional]  # noqa: E501\n            province_state (str, none_type): [optional]  # noqa: E501\n            postal_code (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.country = country\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        country: str,\n        street_line1: str | None = None,\n        street_line2: str | None = None,\n        city: str | None = None,\n        province_state: str | None = None,\n        postal_code: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"BillingInformation - a model defined in OpenAPI\n\n        Args:\n            country (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            street_line1 (str, none_type): [optional]  # noqa: E501\n            street_line2 (str, none_type): [optional]  # noqa: E501\n            city (str, none_type): [optional]  # noqa: E501\n            province_state (str, none_type): [optional]  # noqa: E501\n            postal_code (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.country = country\n        if street_line1 is not None:\n            self.street_line1 = street_line1\n        if street_line2 is not None:\n            self.street_line2 = street_line2\n        if city is not None:\n            self.city = city\n        if province_state is not None:\n            self.province_state = province_state\n        if postal_code is not None:\n            self.postal_code = postal_code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      85,
      99,
      110,
      173,
      174,
      175,
      176,
      177,
      179,
      181,
      182,
      183,
      184,
      185,
      186,
      188,
      197,
      198,
      199,
      200,
      201,
      202,
      204,
      205,
      206,
      211,
      212,
      213,
      278,
      279,
      280,
      281,
      282,
      284,
      285,
      286,
      287,
      288,
      289,
      291,
      300,
      301,
      302,
      303,
      304,
      305,
      307,
      308,
      309,
      310,
      311,
      312,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      324,
      325,
      326,
      327
    ]
  },
  {
    "file_path": "xendit/payment_method/model/card.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.card_channel_code import CardChannelCode\nfrom xendit.payment_method.model.card_channel_properties import CardChannelProperties\nfrom xendit.payment_method.model.card_verification_results import CardVerificationResults\nfrom xendit.payment_method.model.tokenized_card_information import TokenizedCardInformation\nglobals()['CardChannelCode'] = CardChannelCode\nglobals()['CardChannelProperties'] = CardChannelProperties\nglobals()['CardVerificationResults'] = CardVerificationResults\nglobals()['TokenizedCardInformation'] = TokenizedCardInformation\n\ndef lazy_import():\n    pass\n\nclass Card(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_properties': (CardChannelProperties,),  # noqa: E501\n            'channel_code': (CardChannelCode, none_type),  # noqa: E501\n            'currency': (str, none_type, none_type),  # noqa: E501\n            'card_information': (TokenizedCardInformation, none_type),  # noqa: E501\n            'card_verification_results': (CardVerificationResults, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'channel_code': 'channel_code',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'card_information': 'card_information',  # noqa: E501\n        'card_verification_results': 'card_verification_results',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, channel_properties, *args, **kwargs):  # noqa: E501\n        \"\"\"Card - a model defined in OpenAPI\n\n        Args:\n            channel_properties (CardChannelProperties):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (CardChannelCode): [optional]  # noqa: E501\n            currency (str, none_type): [optional]  # noqa: E501\n            card_information (TokenizedCardInformation): [optional]  # noqa: E501\n            card_verification_results (CardVerificationResults): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_properties: CardChannelProperties | None,\n        channel_code: CardChannelCode | None = None,\n        currency: str | None = None,\n        card_information: TokenizedCardInformation | None = None,\n        card_verification_results: CardVerificationResults | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Card - a model defined in OpenAPI\n\n        Args:\n            channel_properties (CardChannelProperties):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (CardChannelCode): [optional]  # noqa: E501\n            currency (str, none_type): [optional]  # noqa: E501\n            card_information (TokenizedCardInformation): [optional]  # noqa: E501\n            card_verification_results (CardVerificationResults): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_properties = channel_properties\n        if channel_code is not None:\n            self.channel_code = channel_code\n        if currency is not None:\n            self.currency = currency\n        if card_information is not None:\n            self.card_information = card_information\n        if card_verification_results is not None:\n            self.card_verification_results = card_verification_results\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      75,
      76,
      90,
      91,
      101,
      162,
      163,
      164,
      165,
      166,
      168,
      170,
      171,
      172,
      173,
      174,
      175,
      177,
      186,
      187,
      188,
      189,
      190,
      191,
      193,
      194,
      195,
      200,
      201,
      202,
      265,
      266,
      267,
      268,
      269,
      271,
      272,
      273,
      274,
      275,
      276,
      278,
      287,
      288,
      289,
      290,
      291,
      292,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      309,
      310,
      311,
      312
    ]
  },
  {
    "file_path": "xendit/payment_method/model/card_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CardChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BAY_CARD_INSTALLMENT': \"BAY_CARD_INSTALLMENT\",\n            'BBL_CARD_INSTALLMENT': \"BBL_CARD_INSTALLMENT\",\n            'GPN': \"GPN\",\n            'KBANK_CARD_INSTALLMENT': \"KBANK_CARD_INSTALLMENT\",\n            'KTB_CARD_INSTALLMENT': \"KTB_CARD_INSTALLMENT\",\n            'SCB_CARD_INSTALLMENT': \"SCB_CARD_INSTALLMENT\",\n            'TTB_CARD_INSTALLMENT': \"TTB_CARD_INSTALLMENT\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"CardChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Card Channel Code., must be one of [\"BAY_CARD_INSTALLMENT\", \"BBL_CARD_INSTALLMENT\", \"GPN\", \"KBANK_CARD_INSTALLMENT\", \"KTB_CARD_INSTALLMENT\", \"SCB_CARD_INSTALLMENT\", \"TTB_CARD_INSTALLMENT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Card Channel Code., must be one of [\"BAY_CARD_INSTALLMENT\", \"BBL_CARD_INSTALLMENT\", \"GPN\", \"KBANK_CARD_INSTALLMENT\", \"KTB_CARD_INSTALLMENT\", \"SCB_CARD_INSTALLMENT\", \"TTB_CARD_INSTALLMENT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"CardChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Card Channel Code., must be one of [\"BAY_CARD_INSTALLMENT\", \"BBL_CARD_INSTALLMENT\", \"GPN\", \"KBANK_CARD_INSTALLMENT\", \"KTB_CARD_INSTALLMENT\", \"SCB_CARD_INSTALLMENT\", \"TTB_CARD_INSTALLMENT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Card Channel Code., must be one of [\"BAY_CARD_INSTALLMENT\", \"BBL_CARD_INSTALLMENT\", \"GPN\", \"KBANK_CARD_INSTALLMENT\", \"KTB_CARD_INSTALLMENT\", \"SCB_CARD_INSTALLMENT\", \"TTB_CARD_INSTALLMENT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      81,
      87,
      148,
      150,
      151,
      152,
      153,
      154,
      156,
      162,
      163,
      164,
      165,
      167,
      168,
      169,
      170,
      171,
      172,
      174,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      244,
      246,
      248,
      249,
      250,
      251,
      252,
      254,
      260,
      261,
      262,
      263,
      265,
      266,
      267,
      268,
      269,
      270,
      272,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      301
    ]
  },
  {
    "file_path": "xendit/payment_method/model/card_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.card_installment_configuration import CardInstallmentConfiguration\nglobals()['CardInstallmentConfiguration'] = CardInstallmentConfiguration\n\ndef lazy_import():\n    pass\n\nclass CardChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('cardonfile_type',): {\n            'None': None,\n            'MERCHANT_UNSCHEDULED': \"MERCHANT_UNSCHEDULED\",\n            'CUSTOMER_UNSCHEDULED': \"CUSTOMER_UNSCHEDULED\",\n            'RECURRING': \"RECURRING\",\n        },\n    }\n\n    validations = {\n        ('success_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('failure_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'skip_three_d_secure': (bool, none_type, none_type),  # noqa: E501\n            'success_return_url': (str, none_type, none_type),  # noqa: E501\n            'failure_return_url': (str, none_type, none_type),  # noqa: E501\n            'cardonfile_type': (str, none_type, none_type),  # noqa: E501\n            'expires_at': (datetime, none_type),  # noqa: E501\n            'installment_configuration': (CardInstallmentConfiguration, none_type),  # noqa: E501\n            'merchant_id_tag': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'skip_three_d_secure': 'skip_three_d_secure',  # noqa: E501\n        'success_return_url': 'success_return_url',  # noqa: E501\n        'failure_return_url': 'failure_return_url',  # noqa: E501\n        'cardonfile_type': 'cardonfile_type',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n        'installment_configuration': 'installment_configuration',  # noqa: E501\n        'merchant_id_tag': 'merchant_id_tag',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CardChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            skip_three_d_secure (bool, none_type): This field value is only being used for reusability = MULTIPLE_USE. To indicate whether to perform 3DS during the linking phase. Defaults to false.. [optional]  # noqa: E501\n            success_return_url (str, none_type): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str, none_type): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            cardonfile_type (str, none_type): Type of credential-on-file / card-on-file payment being made. Indicate that this payment uses a previously linked Payment Method for charging.. [optional]  # noqa: E501\n            expires_at (datetime): [optional]  # noqa: E501\n            installment_configuration (CardInstallmentConfiguration): [optional]  # noqa: E501\n            merchant_id_tag (str): Tag for a Merchant ID that you want to associate this payment with. For merchants using their own MIDs to specify which MID they want to use. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        skip_three_d_secure: bool | None = None,\n        success_return_url: str | None = None,\n        failure_return_url: str | None = None,\n        cardonfile_type: str | None = None,\n        expires_at: datetime | None = None,\n        installment_configuration: CardInstallmentConfiguration | None = None,\n        merchant_id_tag: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardChannelProperties - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            skip_three_d_secure (bool, none_type): This field value is only being used for reusability = MULTIPLE_USE. To indicate whether to perform 3DS during the linking phase. Defaults to false.. [optional]  # noqa: E501\n            success_return_url (str, none_type): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str, none_type): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            cardonfile_type (str, none_type): Type of credential-on-file / card-on-file payment being made. Indicate that this payment uses a previously linked Payment Method for charging.. [optional]  # noqa: E501\n            expires_at (datetime): [optional]  # noqa: E501\n            installment_configuration (CardInstallmentConfiguration): [optional]  # noqa: E501\n            merchant_id_tag (str): Tag for a Merchant ID that you want to associate this payment with. For merchants using their own MIDs to specify which MID they want to use. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if skip_three_d_secure is not None:\n            self.skip_three_d_secure = skip_three_d_secure\n        if success_return_url is not None:\n            self.success_return_url = success_return_url\n        if failure_return_url is not None:\n            self.failure_return_url = failure_return_url\n        if cardonfile_type is not None:\n            self.cardonfile_type = cardonfile_type\n        if expires_at is not None:\n            self.expires_at = expires_at\n        if installment_configuration is not None:\n            self.installment_configuration = installment_configuration\n        if merchant_id_tag is not None:\n            self.merchant_id_tag = merchant_id_tag\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      85,
      86,
      185,
      186,
      187,
      188,
      189,
      191,
      213,
      280,
      281,
      282,
      283,
      284,
      286,
      287,
      288,
      289,
      290,
      291,
      293,
      302,
      303,
      304,
      305,
      306,
      307,
      309,
      310,
      311,
      312,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      322,
      323,
      324,
      329,
      330,
      331,
      332
    ]
  },
  {
    "file_path": "xendit/payment_method/model/card_installment_configuration.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CardInstallmentConfiguration(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'terms': (int, none_type),  # noqa: E501\n            'interval': (str, none_type),  # noqa: E501\n            'code': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'terms': 'terms',  # noqa: E501\n        'interval': 'interval',  # noqa: E501\n        'code': 'code',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CardInstallmentConfiguration - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            terms (int): [optional]  # noqa: E501\n            interval (str): [optional]  # noqa: E501\n            code (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        terms: int | None = None,\n        interval: str | None = None,\n        code: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardInstallmentConfiguration - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            terms (int): [optional]  # noqa: E501\n            interval (str): [optional]  # noqa: E501\n            code (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if terms is not None:\n            self.terms = terms\n        if interval is not None:\n            self.interval = interval\n        if code is not None:\n            self.code = code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      181,
      182,
      183,
      240,
      241,
      242,
      243,
      244,
      246,
      247,
      248,
      249,
      250,
      251,
      253,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      275,
      276,
      281,
      282,
      283,
      284
    ]
  },
  {
    "file_path": "xendit/payment_method/model/card_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.card_channel_properties import CardChannelProperties\nfrom xendit.payment_method.model.card_parameters_card_information import CardParametersCardInformation\nglobals()['CardChannelProperties'] = CardChannelProperties\nglobals()['CardParametersCardInformation'] = CardParametersCardInformation\n\ndef lazy_import():\n    pass\n\nclass CardParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'currency': (str,),  # noqa: E501\n            'channel_properties': (CardChannelProperties, none_type),  # noqa: E501\n            'card_information': (CardParametersCardInformation, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'currency': 'currency',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'card_information': 'card_information',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, currency, *args, **kwargs):  # noqa: E501\n        \"\"\"CardParameters - a model defined in OpenAPI\n\n        Args:\n            currency (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_properties (CardChannelProperties): [optional]  # noqa: E501\n            card_information (CardParametersCardInformation): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.currency = currency\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        currency: str,\n        channel_properties: CardChannelProperties | None = None,\n        card_information: CardParametersCardInformation | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardParameters - a model defined in OpenAPI\n\n        Args:\n            currency (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_properties (CardChannelProperties): [optional]  # noqa: E501\n            card_information (CardParametersCardInformation): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.currency = currency\n        if channel_properties is not None:\n            self.channel_properties = channel_properties\n        if card_information is not None:\n            self.card_information = card_information\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      161,
      162,
      163,
      164,
      165,
      167,
      190,
      251,
      252,
      253,
      254,
      255,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      273,
      274,
      275,
      276,
      277,
      278,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      291,
      292,
      293,
      294
    ]
  },
  {
    "file_path": "xendit/payment_method/model/card_parameters_card_information.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CardParametersCardInformation(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'card_number': (str,),  # noqa: E501\n            'expiry_month': (str,),  # noqa: E501\n            'expiry_year': (str,),  # noqa: E501\n            'cardholder_name': (str, none_type, none_type),  # noqa: E501\n            'cvv': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'card_number': 'card_number',  # noqa: E501\n        'expiry_month': 'expiry_month',  # noqa: E501\n        'expiry_year': 'expiry_year',  # noqa: E501\n        'cardholder_name': 'cardholder_name',  # noqa: E501\n        'cvv': 'cvv',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, card_number, expiry_month, expiry_year, *args, **kwargs):  # noqa: E501\n        \"\"\"CardParametersCardInformation - a model defined in OpenAPI\n\n        Args:\n            card_number (str):\n            expiry_month (str): Card expiry month in MM format\n            expiry_year (str): Card expiry month in YY format\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            cardholder_name (str, none_type): Cardholder name. [optional]  # noqa: E501\n            cvv (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.card_number = card_number\n        self.expiry_month = expiry_month\n        self.expiry_year = expiry_year\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        card_number: str,\n        expiry_month: str,\n        expiry_year: str,\n        cardholder_name: str | None = None,\n        cvv: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardParametersCardInformation - a model defined in OpenAPI\n\n        Args:\n            card_number (str):\n            expiry_month (str): Card expiry month in MM format\n            expiry_year (str): Card expiry month in YY format\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            cardholder_name (str, none_type): Cardholder name. [optional]  # noqa: E501\n            cvv (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.card_number = card_number\n        self.expiry_month = expiry_month\n        self.expiry_year = expiry_year\n        if cardholder_name is not None:\n            self.cardholder_name = cardholder_name\n        if cvv is not None:\n            self.cvv = cvv\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      161,
      162,
      163,
      164,
      165,
      167,
      192,
      257,
      258,
      259,
      260,
      261,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      279,
      280,
      281,
      282,
      283,
      284,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      294,
      299,
      300,
      301,
      302
    ]
  },
  {
    "file_path": "xendit/payment_method/model/card_verification_results.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.card_verification_results_three_d_secure import CardVerificationResultsThreeDSecure\nglobals()['CardVerificationResultsThreeDSecure'] = CardVerificationResultsThreeDSecure\n\ndef lazy_import():\n    pass\n\nclass CardVerificationResults(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'three_d_secure': (CardVerificationResultsThreeDSecure,),  # noqa: E501\n            'cvv_result': (str, none_type, none_type),  # noqa: E501\n            'address_verification_result': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'three_d_secure': 'three_d_secure',  # noqa: E501\n        'cvv_result': 'cvv_result',  # noqa: E501\n        'address_verification_result': 'address_verification_result',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, three_d_secure, *args, **kwargs):  # noqa: E501\n        \"\"\"CardVerificationResults - a model defined in OpenAPI\n\n        Args:\n            three_d_secure (CardVerificationResultsThreeDSecure):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            cvv_result (str, none_type): [optional]  # noqa: E501\n            address_verification_result (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.three_d_secure = three_d_secure\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        three_d_secure: CardVerificationResultsThreeDSecure | None,\n        cvv_result: str | None = None,\n        address_verification_result: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardVerificationResults - a model defined in OpenAPI\n\n        Args:\n            three_d_secure (CardVerificationResultsThreeDSecure):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            cvv_result (str, none_type): [optional]  # noqa: E501\n            address_verification_result (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.three_d_secure = three_d_secure\n        if cvv_result is not None:\n            self.cvv_result = cvv_result\n        if address_verification_result is not None:\n            self.address_verification_result = address_verification_result\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      93,
      150,
      151,
      152,
      153,
      154,
      156,
      158,
      159,
      160,
      161,
      162,
      163,
      165,
      174,
      175,
      176,
      177,
      178,
      179,
      181,
      182,
      183,
      188,
      189,
      190,
      249,
      250,
      251,
      252,
      253,
      255,
      256,
      257,
      258,
      259,
      260,
      262,
      271,
      272,
      273,
      274,
      275,
      276,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      289,
      290,
      291,
      292
    ]
  },
  {
    "file_path": "xendit/payment_method/model/card_verification_results_three_d_secure.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CardVerificationResultsThreeDSecure(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('three_d_secure_flow',): {\n            'None': None,\n            'CHALLENGE': \"CHALLENGE\",\n            'FRICTIONLESS': \"FRICTIONLESS\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'three_d_secure_flow': (str, none_type, none_type),  # noqa: E501\n            'eci_code': (str, none_type, none_type),  # noqa: E501\n            'three_d_secure_result': (str, none_type, none_type),  # noqa: E501\n            'three_d_secure_result_reason': (str, none_type, none_type),  # noqa: E501\n            'three_d_secure_version': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'three_d_secure_flow': 'three_d_secure_flow',  # noqa: E501\n        'eci_code': 'eci_code',  # noqa: E501\n        'three_d_secure_result': 'three_d_secure_result',  # noqa: E501\n        'three_d_secure_result_reason': 'three_d_secure_result_reason',  # noqa: E501\n        'three_d_secure_version': 'three_d_secure_version',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CardVerificationResultsThreeDSecure - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            three_d_secure_flow (str, none_type): [optional]  # noqa: E501\n            eci_code (str, none_type): [optional]  # noqa: E501\n            three_d_secure_result (str, none_type): [optional]  # noqa: E501\n            three_d_secure_result_reason (str, none_type): [optional]  # noqa: E501\n            three_d_secure_version (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        three_d_secure_flow: str | None = None,\n        eci_code: str | None = None,\n        three_d_secure_result: str | None = None,\n        three_d_secure_result_reason: str | None = None,\n        three_d_secure_version: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardVerificationResultsThreeDSecure - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            three_d_secure_flow (str, none_type): [optional]  # noqa: E501\n            eci_code (str, none_type): [optional]  # noqa: E501\n            three_d_secure_result (str, none_type): [optional]  # noqa: E501\n            three_d_secure_result_reason (str, none_type): [optional]  # noqa: E501\n            three_d_secure_version (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if three_d_secure_flow is not None:\n            self.three_d_secure_flow = three_d_secure_flow\n        if eci_code is not None:\n            self.eci_code = eci_code\n        if three_d_secure_result is not None:\n            self.three_d_secure_result = three_d_secure_result\n        if three_d_secure_result_reason is not None:\n            self.three_d_secure_result_reason = three_d_secure_result_reason\n        if three_d_secure_version is not None:\n            self.three_d_secure_version = three_d_secure_version\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      72,
      86,
      96,
      155,
      156,
      157,
      158,
      159,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      186,
      187,
      192,
      193,
      194,
      255,
      256,
      257,
      258,
      259,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      277,
      278,
      279,
      280,
      281,
      282,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      294,
      295,
      300,
      301,
      302,
      303
    ]
  },
  {
    "file_path": "xendit/payment_method/model/create_payment_method409_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CreatePaymentMethod409Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'PAYMENT_METHOD_ALREADY_ACTIVE': \"PAYMENT_METHOD_ALREADY_ACTIVE\",\n            'PAYMENT_METHOD_ALREADY_FAILED': \"PAYMENT_METHOD_ALREADY_FAILED\",\n            'DUPLICATE_ERROR': \"DUPLICATE_ERROR\",\n            'IDEMPOTENCY_ERROR': \"IDEMPOTENCY_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CreatePaymentMethod409Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CreatePaymentMethod409Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      73,
      87,
      94,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      184,
      185,
      186,
      241,
      242,
      243,
      244,
      245,
      247,
      248,
      249,
      250,
      251,
      252,
      254,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      271,
      272,
      273,
      274,
      275,
      280,
      281,
      282,
      283
    ]
  },
  {
    "file_path": "xendit/payment_method/model/create_payment_method503_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CreatePaymentMethod503Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'CHANNEL_UNAVAILABLE': \"CHANNEL_UNAVAILABLE\",\n            'OTP_DELIVERY_ERROR': \"OTP_DELIVERY_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CreatePaymentMethod503Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CreatePaymentMethod503Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      85,
      92,
      145,
      146,
      147,
      148,
      149,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      160,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/payment_method/model/direct_debit.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.direct_debit_all_of import DirectDebitAllOf\nfrom xendit.payment_method.model.direct_debit_bank_account import DirectDebitBankAccount\nfrom xendit.payment_method.model.direct_debit_channel_code import DirectDebitChannelCode\nfrom xendit.payment_method.model.direct_debit_channel_properties import DirectDebitChannelProperties\nfrom xendit.payment_method.model.direct_debit_debit_card import DirectDebitDebitCard\nfrom xendit.payment_method.model.direct_debit_parameters import DirectDebitParameters\nfrom xendit.payment_method.model.direct_debit_type import DirectDebitType\nglobals()['DirectDebitAllOf'] = DirectDebitAllOf\nglobals()['DirectDebitBankAccount'] = DirectDebitBankAccount\nglobals()['DirectDebitChannelCode'] = DirectDebitChannelCode\nglobals()['DirectDebitChannelProperties'] = DirectDebitChannelProperties\nglobals()['DirectDebitDebitCard'] = DirectDebitDebitCard\nglobals()['DirectDebitParameters'] = DirectDebitParameters\nglobals()['DirectDebitType'] = DirectDebitType\n\ndef lazy_import():\n    pass\n\nclass DirectDebit(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (DirectDebitChannelCode,),  # noqa: E501\n            'channel_properties': (DirectDebitChannelProperties,),  # noqa: E501\n            'type': (DirectDebitType,),  # noqa: E501\n            'bank_account': (DirectDebitBankAccount, none_type),  # noqa: E501\n            'debit_card': (DirectDebitDebitCard, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'bank_account': 'bank_account',  # noqa: E501\n        'debit_card': 'debit_card',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebit - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (DirectDebitChannelCode):\n            channel_properties (DirectDebitChannelProperties):\n            type (DirectDebitType):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            bank_account (DirectDebitBankAccount): [optional]  # noqa: E501\n            debit_card (DirectDebitDebitCard): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebit - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (DirectDebitChannelCode):\n            channel_properties (DirectDebitChannelProperties):\n            type (DirectDebitType):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            bank_account (DirectDebitBankAccount): [optional]  # noqa: E501\n            debit_card (DirectDebitDebitCard): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              DirectDebitAllOf,\n              DirectDebitParameters,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      81,
      82,
      96,
      97,
      107,
      164,
      165,
      166,
      167,
      168,
      170,
      172,
      173,
      174,
      175,
      176,
      177,
      179,
      188,
      189,
      190,
      191,
      192,
      193,
      195,
      202,
      204,
      205,
      206,
      207,
      209,
      210,
      215,
      216,
      218,
      274,
      275,
      276,
      277,
      278,
      280,
      281,
      282,
      283,
      284,
      285,
      287,
      296,
      297,
      298,
      299,
      300,
      301,
      303,
      310,
      312,
      313,
      314,
      315,
      317,
      318,
      323,
      324,
      325,
      326,
      338,
      339
    ]
  },
  {
    "file_path": "xendit/payment_method/model/direct_debit_all_of.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.direct_debit_bank_account import DirectDebitBankAccount\nfrom xendit.payment_method.model.direct_debit_debit_card import DirectDebitDebitCard\nfrom xendit.payment_method.model.direct_debit_type import DirectDebitType\nglobals()['DirectDebitBankAccount'] = DirectDebitBankAccount\nglobals()['DirectDebitDebitCard'] = DirectDebitDebitCard\nglobals()['DirectDebitType'] = DirectDebitType\n\ndef lazy_import():\n    pass\n\nclass DirectDebitAllOf(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'type': (DirectDebitType,),  # noqa: E501\n            'bank_account': (DirectDebitBankAccount, none_type),  # noqa: E501\n            'debit_card': (DirectDebitDebitCard, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'type': 'type',  # noqa: E501\n        'bank_account': 'bank_account',  # noqa: E501\n        'debit_card': 'debit_card',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, type, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitAllOf - a model defined in OpenAPI\n\n        Args:\n            type (DirectDebitType):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            bank_account (DirectDebitBankAccount): [optional]  # noqa: E501\n            debit_card (DirectDebitDebitCard): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        type: DirectDebitType,\n        bank_account: DirectDebitBankAccount | None = None,\n        debit_card: DirectDebitDebitCard | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitAllOf - a model defined in OpenAPI\n\n        Args:\n            type (DirectDebitType):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            bank_account (DirectDebitBankAccount): [optional]  # noqa: E501\n            debit_card (DirectDebitDebitCard): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        if bank_account is not None:\n            self.bank_account = bank_account\n        if debit_card is not None:\n            self.debit_card = debit_card\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      73,
      74,
      88,
      89,
      97,
      154,
      155,
      156,
      157,
      158,
      160,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      178,
      179,
      180,
      181,
      182,
      183,
      185,
      186,
      187,
      192,
      193,
      194,
      253,
      254,
      255,
      256,
      257,
      259,
      260,
      261,
      262,
      263,
      264,
      266,
      275,
      276,
      277,
      278,
      279,
      280,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      293,
      294,
      295,
      296
    ]
  },
  {
    "file_path": "xendit/payment_method/model/direct_debit_bank_account.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitBankAccount(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'masked_bank_account_number': (str, none_type, none_type),  # noqa: E501\n            'bank_account_hash': (str, none_type, none_type),  # noqa: E501\n            'mobile_number': (str, none_type, none_type),  # noqa: E501\n            'identity_document_number': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'masked_bank_account_number': 'masked_bank_account_number',  # noqa: E501\n        'bank_account_hash': 'bank_account_hash',  # noqa: E501\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'identity_document_number': 'identity_document_number',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitBankAccount - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            masked_bank_account_number (str, none_type): [optional]  # noqa: E501\n            bank_account_hash (str, none_type): [optional]  # noqa: E501\n            mobile_number (str, none_type): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            identity_document_number (str, none_type): Identity number of the customer registered to the partner channel. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        masked_bank_account_number: str | None = None,\n        bank_account_hash: str | None = None,\n        mobile_number: str | None = None,\n        identity_document_number: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitBankAccount - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            masked_bank_account_number (str, none_type): [optional]  # noqa: E501\n            bank_account_hash (str, none_type): [optional]  # noqa: E501\n            mobile_number (str, none_type): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            identity_document_number (str, none_type): Identity number of the customer registered to the partner channel. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if masked_bank_account_number is not None:\n            self.masked_bank_account_number = masked_bank_account_number\n        if bank_account_hash is not None:\n            self.bank_account_hash = bank_account_hash\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if identity_document_number is not None:\n            self.identity_document_number = identity_document_number\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      90,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      184,
      185,
      186,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      288,
      289,
      290,
      291
    ]
  },
  {
    "file_path": "xendit/payment_method/model/direct_debit_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BCA_KLIKPAY': \"BCA_KLIKPAY\",\n            'BCA_ONEKLIK': \"BCA_ONEKLIK\",\n            'BDO': \"BDO\",\n            'BPI': \"BPI\",\n            'BPI_RECURRING': \"BPI_RECURRING\",\n            'BRI': \"BRI\",\n            'BNI_AUTOPAY': \"BNI_AUTOPAY\",\n            'CHINABANK': \"CHINABANK\",\n            'CIMBNIAGA': \"CIMBNIAGA\",\n            'MTB': \"MTB\",\n            'RCBC': \"RCBC\",\n            'UBP': \"UBP\",\n            'MANDIRI': \"MANDIRI\",\n            'BBL': \"BBL\",\n            'SCB': \"SCB\",\n            'KTB': \"KTB\",\n            'BAY': \"BAY\",\n            'KBANK_MB': \"KBANK_MB\",\n            'BAY_MB': \"BAY_MB\",\n            'KTB_MB': \"KTB_MB\",\n            'BBL_MB': \"BBL_MB\",\n            'SCB_MB': \"SCB_MB\",\n            'BDO_EPAY': \"BDO_EPAY\",\n            'UBP_EADA': \"UBP_EADA\",\n            'UBP_DEBIT_PULL': \"UBP_DEBIT_PULL\",\n            'AFFIN_FPX': \"AFFIN_FPX\",\n            'AGRO_FPX': \"AGRO_FPX\",\n            'ALLIANCE_FPX': \"ALLIANCE_FPX\",\n            'AMBANK_FPX': \"AMBANK_FPX\",\n            'ISLAM_FPX': \"ISLAM_FPX\",\n            'MUAMALAT_FPX': \"MUAMALAT_FPX\",\n            'BOC_FPX': \"BOC_FPX\",\n            'RAKYAT_FPX': \"RAKYAT_FPX\",\n            'BSN_FPX': \"BSN_FPX\",\n            'CIMB_FPX': \"CIMB_FPX\",\n            'HLB_FPX': \"HLB_FPX\",\n            'HSBC_FPX': \"HSBC_FPX\",\n            'KFH_FPX': \"KFH_FPX\",\n            'MAYB2E_FPX': \"MAYB2E_FPX\",\n            'MAYB2U_FPX': \"MAYB2U_FPX\",\n            'OCBC_FPX': \"OCBC_FPX\",\n            'PUBLIC_FPX': \"PUBLIC_FPX\",\n            'RHB_FPX': \"RHB_FPX\",\n            'SCH_FPX': \"SCH_FPX\",\n            'UOB_FPX': \"UOB_FPX\",\n            'AFFIN_FPX_BUSINESS': \"AFFIN_FPX_BUSINESS\",\n            'AGRO_FPX_BUSINESS': \"AGRO_FPX_BUSINESS\",\n            'ALLIANCE_FPX_BUSINESS': \"ALLIANCE_FPX_BUSINESS\",\n            'AMBANK_FPX_BUSINESS': \"AMBANK_FPX_BUSINESS\",\n            'ISLAM_FPX_BUSINESS': \"ISLAM_FPX_BUSINESS\",\n            'MUAMALAT_FPX_BUSINESS': \"MUAMALAT_FPX_BUSINESS\",\n            'BNP_FPX_BUSINESS': \"BNP_FPX_BUSINESS\",\n            'CIMB_FPX_BUSINESS': \"CIMB_FPX_BUSINESS\",\n            'CITIBANK_FPX_BUSINESS': \"CITIBANK_FPX_BUSINESS\",\n            'DEUTSCHE_FPX_BUSINESS': \"DEUTSCHE_FPX_BUSINESS\",\n            'HLB_FPX_BUSINESS': \"HLB_FPX_BUSINESS\",\n            'HSBC_FPX_BUSINESS': \"HSBC_FPX_BUSINESS\",\n            'RAKYAT_FPX_BUSINESS': \"RAKYAT_FPX_BUSINESS\",\n            'KFH_FPX_BUSINESS': \"KFH_FPX_BUSINESS\",\n            'MAYB2E_FPX_BUSINESS': \"MAYB2E_FPX_BUSINESS\",\n            'OCBC_FPX_BUSINESS': \"OCBC_FPX_BUSINESS\",\n            'PUBLIC_FPX_BUSINESS': \"PUBLIC_FPX_BUSINESS\",\n            'RHB_FPX_BUSINESS': \"RHB_FPX_BUSINESS\",\n            'SCH_FPX_BUSINESS': \"SCH_FPX_BUSINESS\",\n            'UOB_FPX_BUSINESS': \"UOB_FPX_BUSINESS\",\n            'BDO_ONLINE_BANKING': \"BDO_ONLINE_BANKING\",\n            'BPI_ONLINE_BANKING': \"BPI_ONLINE_BANKING\",\n            'UNIONBANK_ONLINE_BANKING': \"UNIONBANK_ONLINE_BANKING\",\n            'BOC_ONLINE_BANKING': \"BOC_ONLINE_BANKING\",\n            'CHINABANK_ONLINE_BANKING': \"CHINABANK_ONLINE_BANKING\",\n            'INSTAPAY_ONLINE_BANKING': \"INSTAPAY_ONLINE_BANKING\",\n            'LANDBANK_ONLINE_BANKING': \"LANDBANK_ONLINE_BANKING\",\n            'MAYBANK_ONLINE_BANKING': \"MAYBANK_ONLINE_BANKING\",\n            'METROBANK_ONLINE_BANKING': \"METROBANK_ONLINE_BANKING\",\n            'PNB_ONLINE_BANKING': \"PNB_ONLINE_BANKING\",\n            'PSBANK_ONLINE_BANKING': \"PSBANK_ONLINE_BANKING\",\n            'PESONET_ONLINE_BANKING': \"PESONET_ONLINE_BANKING\",\n            'RCBC_ONLINE_BANKING': \"RCBC_ONLINE_BANKING\",\n            'ROBINSONS_BANK_ONLINE_BANKING': \"ROBINSONS_BANK_ONLINE_BANKING\",\n            'SECURITY_BANK_ONLINE_BANKING': \"SECURITY_BANK_ONLINE_BANKING\",\n            'AUTODEBIT_UBP': \"AUTODEBIT_UBP\",\n            'AUTODEBIT_BPI': \"AUTODEBIT_BPI\",\n            'GBW_BBL_MOBILE_BANKING': \"GBW_BBL_MOBILE_BANKING\",\n            'GBW_KBANK_MOBILE_BANKING': \"GBW_KBANK_MOBILE_BANKING\",\n            'GBW_KTB_MOBILE_BANKING': \"GBW_KTB_MOBILE_BANKING\",\n            'GBW_SCB_MOBILE_BANKING': \"GBW_SCB_MOBILE_BANKING\",\n            'GBW_BAY_MOBILE_BANKING': \"GBW_BAY_MOBILE_BANKING\",\n            'GBW_BBL': \"GBW_BBL\",\n            'GBW_KBANK': \"GBW_KBANK\",\n            'GBW_KTB': \"GBW_KTB\",\n            'GBW_SCB': \"GBW_SCB\",\n            'GBW_BAY': \"GBW_BAY\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"DirectDebitChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Direct Debit Channel Code., must be one of [\"BCA_KLIKPAY\", \"BCA_ONEKLIK\", \"BDO\", \"BPI\", \"BPI_RECURRING\", \"BRI\", \"BNI_AUTOPAY\", \"CHINABANK\", \"CIMBNIAGA\", \"MTB\", \"RCBC\", \"UBP\", \"MANDIRI\", \"BBL\", \"SCB\", \"KTB\", \"BAY\", \"KBANK_MB\", \"BAY_MB\", \"KTB_MB\", \"BBL_MB\", \"SCB_MB\", \"BDO_EPAY\", \"UBP_EADA\", \"UBP_DEBIT_PULL\", \"AFFIN_FPX\", \"AGRO_FPX\", \"ALLIANCE_FPX\", \"AMBANK_FPX\", \"ISLAM_FPX\", \"MUAMALAT_FPX\", \"BOC_FPX\", \"RAKYAT_FPX\", \"BSN_FPX\", \"CIMB_FPX\", \"HLB_FPX\", \"HSBC_FPX\", \"KFH_FPX\", \"MAYB2E_FPX\", \"MAYB2U_FPX\", \"OCBC_FPX\", \"PUBLIC_FPX\", \"RHB_FPX\", \"SCH_FPX\", \"UOB_FPX\", \"AFFIN_FPX_BUSINESS\", \"AGRO_FPX_BUSINESS\", \"ALLIANCE_FPX_BUSINESS\", \"AMBANK_FPX_BUSINESS\", \"ISLAM_FPX_BUSINESS\", \"MUAMALAT_FPX_BUSINESS\", \"BNP_FPX_BUSINESS\", \"CIMB_FPX_BUSINESS\", \"CITIBANK_FPX_BUSINESS\", \"DEUTSCHE_FPX_BUSINESS\", \"HLB_FPX_BUSINESS\", \"HSBC_FPX_BUSINESS\", \"RAKYAT_FPX_BUSINESS\", \"KFH_FPX_BUSINESS\", \"MAYB2E_FPX_BUSINESS\", \"OCBC_FPX_BUSINESS\", \"PUBLIC_FPX_BUSINESS\", \"RHB_FPX_BUSINESS\", \"SCH_FPX_BUSINESS\", \"UOB_FPX_BUSINESS\", \"BDO_ONLINE_BANKING\", \"BPI_ONLINE_BANKING\", \"UNIONBANK_ONLINE_BANKING\", \"BOC_ONLINE_BANKING\", \"CHINABANK_ONLINE_BANKING\", \"INSTAPAY_ONLINE_BANKING\", \"LANDBANK_ONLINE_BANKING\", \"MAYBANK_ONLINE_BANKING\", \"METROBANK_ONLINE_BANKING\", \"PNB_ONLINE_BANKING\", \"PSBANK_ONLINE_BANKING\", \"PESONET_ONLINE_BANKING\", \"RCBC_ONLINE_BANKING\", \"ROBINSONS_BANK_ONLINE_BANKING\", \"SECURITY_BANK_ONLINE_BANKING\", \"AUTODEBIT_UBP\", \"AUTODEBIT_BPI\", \"GBW_BBL_MOBILE_BANKING\", \"GBW_KBANK_MOBILE_BANKING\", \"GBW_KTB_MOBILE_BANKING\", \"GBW_SCB_MOBILE_BANKING\", \"GBW_BAY_MOBILE_BANKING\", \"GBW_BBL\", \"GBW_KBANK\", \"GBW_KTB\", \"GBW_SCB\", \"GBW_BAY\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Direct Debit Channel Code., must be one of [\"BCA_KLIKPAY\", \"BCA_ONEKLIK\", \"BDO\", \"BPI\", \"BPI_RECURRING\", \"BRI\", \"BNI_AUTOPAY\", \"CHINABANK\", \"CIMBNIAGA\", \"MTB\", \"RCBC\", \"UBP\", \"MANDIRI\", \"BBL\", \"SCB\", \"KTB\", \"BAY\", \"KBANK_MB\", \"BAY_MB\", \"KTB_MB\", \"BBL_MB\", \"SCB_MB\", \"BDO_EPAY\", \"UBP_EADA\", \"UBP_DEBIT_PULL\", \"AFFIN_FPX\", \"AGRO_FPX\", \"ALLIANCE_FPX\", \"AMBANK_FPX\", \"ISLAM_FPX\", \"MUAMALAT_FPX\", \"BOC_FPX\", \"RAKYAT_FPX\", \"BSN_FPX\", \"CIMB_FPX\", \"HLB_FPX\", \"HSBC_FPX\", \"KFH_FPX\", \"MAYB2E_FPX\", \"MAYB2U_FPX\", \"OCBC_FPX\", \"PUBLIC_FPX\", \"RHB_FPX\", \"SCH_FPX\", \"UOB_FPX\", \"AFFIN_FPX_BUSINESS\", \"AGRO_FPX_BUSINESS\", \"ALLIANCE_FPX_BUSINESS\", \"AMBANK_FPX_BUSINESS\", \"ISLAM_FPX_BUSINESS\", \"MUAMALAT_FPX_BUSINESS\", \"BNP_FPX_BUSINESS\", \"CIMB_FPX_BUSINESS\", \"CITIBANK_FPX_BUSINESS\", \"DEUTSCHE_FPX_BUSINESS\", \"HLB_FPX_BUSINESS\", \"HSBC_FPX_BUSINESS\", \"RAKYAT_FPX_BUSINESS\", \"KFH_FPX_BUSINESS\", \"MAYB2E_FPX_BUSINESS\", \"OCBC_FPX_BUSINESS\", \"PUBLIC_FPX_BUSINESS\", \"RHB_FPX_BUSINESS\", \"SCH_FPX_BUSINESS\", \"UOB_FPX_BUSINESS\", \"BDO_ONLINE_BANKING\", \"BPI_ONLINE_BANKING\", \"UNIONBANK_ONLINE_BANKING\", \"BOC_ONLINE_BANKING\", \"CHINABANK_ONLINE_BANKING\", \"INSTAPAY_ONLINE_BANKING\", \"LANDBANK_ONLINE_BANKING\", \"MAYBANK_ONLINE_BANKING\", \"METROBANK_ONLINE_BANKING\", \"PNB_ONLINE_BANKING\", \"PSBANK_ONLINE_BANKING\", \"PESONET_ONLINE_BANKING\", \"RCBC_ONLINE_BANKING\", \"ROBINSONS_BANK_ONLINE_BANKING\", \"SECURITY_BANK_ONLINE_BANKING\", \"AUTODEBIT_UBP\", \"AUTODEBIT_BPI\", \"GBW_BBL_MOBILE_BANKING\", \"GBW_KBANK_MOBILE_BANKING\", \"GBW_KTB_MOBILE_BANKING\", \"GBW_SCB_MOBILE_BANKING\", \"GBW_BAY_MOBILE_BANKING\", \"GBW_BBL\", \"GBW_KBANK\", \"GBW_KTB\", \"GBW_SCB\", \"GBW_BAY\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"DirectDebitChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Direct Debit Channel Code., must be one of [\"BCA_KLIKPAY\", \"BCA_ONEKLIK\", \"BDO\", \"BPI\", \"BPI_RECURRING\", \"BRI\", \"BNI_AUTOPAY\", \"CHINABANK\", \"CIMBNIAGA\", \"MTB\", \"RCBC\", \"UBP\", \"MANDIRI\", \"BBL\", \"SCB\", \"KTB\", \"BAY\", \"KBANK_MB\", \"BAY_MB\", \"KTB_MB\", \"BBL_MB\", \"SCB_MB\", \"BDO_EPAY\", \"UBP_EADA\", \"UBP_DEBIT_PULL\", \"AFFIN_FPX\", \"AGRO_FPX\", \"ALLIANCE_FPX\", \"AMBANK_FPX\", \"ISLAM_FPX\", \"MUAMALAT_FPX\", \"BOC_FPX\", \"RAKYAT_FPX\", \"BSN_FPX\", \"CIMB_FPX\", \"HLB_FPX\", \"HSBC_FPX\", \"KFH_FPX\", \"MAYB2E_FPX\", \"MAYB2U_FPX\", \"OCBC_FPX\", \"PUBLIC_FPX\", \"RHB_FPX\", \"SCH_FPX\", \"UOB_FPX\", \"AFFIN_FPX_BUSINESS\", \"AGRO_FPX_BUSINESS\", \"ALLIANCE_FPX_BUSINESS\", \"AMBANK_FPX_BUSINESS\", \"ISLAM_FPX_BUSINESS\", \"MUAMALAT_FPX_BUSINESS\", \"BNP_FPX_BUSINESS\", \"CIMB_FPX_BUSINESS\", \"CITIBANK_FPX_BUSINESS\", \"DEUTSCHE_FPX_BUSINESS\", \"HLB_FPX_BUSINESS\", \"HSBC_FPX_BUSINESS\", \"RAKYAT_FPX_BUSINESS\", \"KFH_FPX_BUSINESS\", \"MAYB2E_FPX_BUSINESS\", \"OCBC_FPX_BUSINESS\", \"PUBLIC_FPX_BUSINESS\", \"RHB_FPX_BUSINESS\", \"SCH_FPX_BUSINESS\", \"UOB_FPX_BUSINESS\", \"BDO_ONLINE_BANKING\", \"BPI_ONLINE_BANKING\", \"UNIONBANK_ONLINE_BANKING\", \"BOC_ONLINE_BANKING\", \"CHINABANK_ONLINE_BANKING\", \"INSTAPAY_ONLINE_BANKING\", \"LANDBANK_ONLINE_BANKING\", \"MAYBANK_ONLINE_BANKING\", \"METROBANK_ONLINE_BANKING\", \"PNB_ONLINE_BANKING\", \"PSBANK_ONLINE_BANKING\", \"PESONET_ONLINE_BANKING\", \"RCBC_ONLINE_BANKING\", \"ROBINSONS_BANK_ONLINE_BANKING\", \"SECURITY_BANK_ONLINE_BANKING\", \"AUTODEBIT_UBP\", \"AUTODEBIT_BPI\", \"GBW_BBL_MOBILE_BANKING\", \"GBW_KBANK_MOBILE_BANKING\", \"GBW_KTB_MOBILE_BANKING\", \"GBW_SCB_MOBILE_BANKING\", \"GBW_BAY_MOBILE_BANKING\", \"GBW_BBL\", \"GBW_KBANK\", \"GBW_KTB\", \"GBW_SCB\", \"GBW_BAY\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Direct Debit Channel Code., must be one of [\"BCA_KLIKPAY\", \"BCA_ONEKLIK\", \"BDO\", \"BPI\", \"BPI_RECURRING\", \"BRI\", \"BNI_AUTOPAY\", \"CHINABANK\", \"CIMBNIAGA\", \"MTB\", \"RCBC\", \"UBP\", \"MANDIRI\", \"BBL\", \"SCB\", \"KTB\", \"BAY\", \"KBANK_MB\", \"BAY_MB\", \"KTB_MB\", \"BBL_MB\", \"SCB_MB\", \"BDO_EPAY\", \"UBP_EADA\", \"UBP_DEBIT_PULL\", \"AFFIN_FPX\", \"AGRO_FPX\", \"ALLIANCE_FPX\", \"AMBANK_FPX\", \"ISLAM_FPX\", \"MUAMALAT_FPX\", \"BOC_FPX\", \"RAKYAT_FPX\", \"BSN_FPX\", \"CIMB_FPX\", \"HLB_FPX\", \"HSBC_FPX\", \"KFH_FPX\", \"MAYB2E_FPX\", \"MAYB2U_FPX\", \"OCBC_FPX\", \"PUBLIC_FPX\", \"RHB_FPX\", \"SCH_FPX\", \"UOB_FPX\", \"AFFIN_FPX_BUSINESS\", \"AGRO_FPX_BUSINESS\", \"ALLIANCE_FPX_BUSINESS\", \"AMBANK_FPX_BUSINESS\", \"ISLAM_FPX_BUSINESS\", \"MUAMALAT_FPX_BUSINESS\", \"BNP_FPX_BUSINESS\", \"CIMB_FPX_BUSINESS\", \"CITIBANK_FPX_BUSINESS\", \"DEUTSCHE_FPX_BUSINESS\", \"HLB_FPX_BUSINESS\", \"HSBC_FPX_BUSINESS\", \"RAKYAT_FPX_BUSINESS\", \"KFH_FPX_BUSINESS\", \"MAYB2E_FPX_BUSINESS\", \"OCBC_FPX_BUSINESS\", \"PUBLIC_FPX_BUSINESS\", \"RHB_FPX_BUSINESS\", \"SCH_FPX_BUSINESS\", \"UOB_FPX_BUSINESS\", \"BDO_ONLINE_BANKING\", \"BPI_ONLINE_BANKING\", \"UNIONBANK_ONLINE_BANKING\", \"BOC_ONLINE_BANKING\", \"CHINABANK_ONLINE_BANKING\", \"INSTAPAY_ONLINE_BANKING\", \"LANDBANK_ONLINE_BANKING\", \"MAYBANK_ONLINE_BANKING\", \"METROBANK_ONLINE_BANKING\", \"PNB_ONLINE_BANKING\", \"PSBANK_ONLINE_BANKING\", \"PESONET_ONLINE_BANKING\", \"RCBC_ONLINE_BANKING\", \"ROBINSONS_BANK_ONLINE_BANKING\", \"SECURITY_BANK_ONLINE_BANKING\", \"AUTODEBIT_UBP\", \"AUTODEBIT_BPI\", \"GBW_BBL_MOBILE_BANKING\", \"GBW_KBANK_MOBILE_BANKING\", \"GBW_KTB_MOBILE_BANKING\", \"GBW_SCB_MOBILE_BANKING\", \"GBW_BAY_MOBILE_BANKING\", \"GBW_BBL\", \"GBW_KBANK\", \"GBW_KTB\", \"GBW_SCB\", \"GBW_BAY\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      233,
      235,
      236,
      237,
      238,
      239,
      241,
      247,
      248,
      249,
      250,
      252,
      253,
      254,
      255,
      256,
      257,
      259,
      268,
      269,
      270,
      271,
      272,
      273,
      274,
      275,
      276,
      334,
      339,
      351,
      352,
      353,
      354,
      355,
      357,
      374,
      375,
      377
    ]
  },
  {
    "file_path": "xendit/payment_method/model/direct_debit_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'success_return_url': (str, none_type),  # noqa: E501\n            'failure_return_url': (str, none_type, none_type),  # noqa: E501\n            'mobile_number': (str, none_type, none_type),  # noqa: E501\n            'card_last_four': (str, none_type, none_type),  # noqa: E501\n            'card_expiry': (str, none_type, none_type),  # noqa: E501\n            'email': (str, none_type, none_type),  # noqa: E501\n            'identity_document_number': (str, none_type, none_type),  # noqa: E501\n            'require_auth': (bool, none_type, none_type),  # noqa: E501\n            'account_number': (str, none_type, none_type),  # noqa: E501\n            'destination_account_id': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'success_return_url': 'success_return_url',  # noqa: E501\n        'failure_return_url': 'failure_return_url',  # noqa: E501\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'card_last_four': 'card_last_four',  # noqa: E501\n        'card_expiry': 'card_expiry',  # noqa: E501\n        'email': 'email',  # noqa: E501\n        'identity_document_number': 'identity_document_number',  # noqa: E501\n        'require_auth': 'require_auth',  # noqa: E501\n        'account_number': 'account_number',  # noqa: E501\n        'destination_account_id': 'destination_account_id',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): [optional]  # noqa: E501\n            failure_return_url (str, none_type): [optional]  # noqa: E501\n            mobile_number (str, none_type): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            card_last_four (str, none_type): Last four digits of the debit card. [optional]  # noqa: E501\n            card_expiry (str, none_type): Expiry month and year of the debit card (in MM/YY format). [optional]  # noqa: E501\n            email (str, none_type): Email address of the customer that is registered to the partner channel. [optional]  # noqa: E501\n            identity_document_number (str, none_type): Identity number of the customer registered to the partner channel. [optional]  # noqa: E501\n            require_auth (bool, none_type): [optional]  # noqa: E501\n            account_number (str, none_type): Account number of the customer. [optional]  # noqa: E501\n            destination_account_id (str, none_type): Destination Account ID for BaaS topups. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        success_return_url: str | None = None,\n        failure_return_url: str | None = None,\n        mobile_number: str | None = None,\n        card_last_four: str | None = None,\n        card_expiry: str | None = None,\n        email: str | None = None,\n        identity_document_number: str | None = None,\n        require_auth: bool | None = None,\n        account_number: str | None = None,\n        destination_account_id: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitChannelProperties - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): [optional]  # noqa: E501\n            failure_return_url (str, none_type): [optional]  # noqa: E501\n            mobile_number (str, none_type): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            card_last_four (str, none_type): Last four digits of the debit card. [optional]  # noqa: E501\n            card_expiry (str, none_type): Expiry month and year of the debit card (in MM/YY format). [optional]  # noqa: E501\n            email (str, none_type): Email address of the customer that is registered to the partner channel. [optional]  # noqa: E501\n            identity_document_number (str, none_type): Identity number of the customer registered to the partner channel. [optional]  # noqa: E501\n            require_auth (bool, none_type): [optional]  # noqa: E501\n            account_number (str, none_type): Account number of the customer. [optional]  # noqa: E501\n            destination_account_id (str, none_type): Destination Account ID for BaaS topups. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if success_return_url is not None:\n            self.success_return_url = success_return_url\n        if failure_return_url is not None:\n            self.failure_return_url = failure_return_url\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if card_last_four is not None:\n            self.card_last_four = card_last_four\n        if card_expiry is not None:\n            self.card_expiry = card_expiry\n        if email is not None:\n            self.email = email\n        if identity_document_number is not None:\n            self.identity_document_number = identity_document_number\n        if require_auth is not None:\n            self.require_auth = require_auth\n        if account_number is not None:\n            self.account_number = account_number\n        if destination_account_id is not None:\n            self.destination_account_id = destination_account_id\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      174,
      175,
      176,
      177,
      178,
      180,
      202,
      275,
      276,
      277,
      278,
      279,
      281,
      282,
      283,
      284,
      285,
      286,
      288,
      297,
      298,
      299,
      300,
      301,
      302,
      304,
      305,
      306,
      307,
      308,
      309,
      310,
      311,
      312,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      322,
      323,
      324,
      325,
      330,
      331,
      332,
      333
    ]
  },
  {
    "file_path": "xendit/payment_method/model/direct_debit_debit_card.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitDebitCard(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'mobile_number': (str, none_type, none_type),  # noqa: E501\n            'card_last_four': (str, none_type, none_type),  # noqa: E501\n            'card_expiry': (str, none_type, none_type),  # noqa: E501\n            'email': (str, none_type, none_type),  # noqa: E501\n            'account_number': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'card_last_four': 'card_last_four',  # noqa: E501\n        'card_expiry': 'card_expiry',  # noqa: E501\n        'email': 'email',  # noqa: E501\n        'account_number': 'account_number',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitDebitCard - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            mobile_number (str, none_type): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            card_last_four (str, none_type): Last four digits of the debit card. [optional]  # noqa: E501\n            card_expiry (str, none_type): Expiry month and year of the debit card (in MM/YY format). [optional]  # noqa: E501\n            email (str, none_type): Email address of the customer that is registered to the partner channel. [optional]  # noqa: E501\n            account_number (str, none_type): Account number of the customer. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        mobile_number: str | None = None,\n        card_last_four: str | None = None,\n        card_expiry: str | None = None,\n        email: str | None = None,\n        account_number: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitDebitCard - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            mobile_number (str, none_type): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            card_last_four (str, none_type): Last four digits of the debit card. [optional]  # noqa: E501\n            card_expiry (str, none_type): Expiry month and year of the debit card (in MM/YY format). [optional]  # noqa: E501\n            email (str, none_type): Email address of the customer that is registered to the partner channel. [optional]  # noqa: E501\n            account_number (str, none_type): Account number of the customer. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if card_last_four is not None:\n            self.card_last_four = card_last_four\n        if card_expiry is not None:\n            self.card_expiry = card_expiry\n        if email is not None:\n            self.email = email\n        if account_number is not None:\n            self.account_number = account_number\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      91,
      150,
      151,
      152,
      153,
      154,
      156,
      158,
      159,
      160,
      161,
      162,
      163,
      165,
      174,
      175,
      176,
      177,
      178,
      179,
      181,
      182,
      187,
      188,
      189,
      250,
      251,
      252,
      253,
      254,
      256,
      257,
      258,
      259,
      260,
      261,
      263,
      272,
      273,
      274,
      275,
      276,
      277,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      295,
      296,
      297,
      298
    ]
  },
  {
    "file_path": "xendit/payment_method/model/direct_debit_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.direct_debit_channel_code import DirectDebitChannelCode\nfrom xendit.payment_method.model.direct_debit_channel_properties import DirectDebitChannelProperties\nglobals()['DirectDebitChannelCode'] = DirectDebitChannelCode\nglobals()['DirectDebitChannelProperties'] = DirectDebitChannelProperties\n\ndef lazy_import():\n    pass\n\nclass DirectDebitParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (DirectDebitChannelCode,),  # noqa: E501\n            'channel_properties': (DirectDebitChannelProperties,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, channel_code, channel_properties, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (DirectDebitChannelCode):\n            channel_properties (DirectDebitChannelProperties):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_code: DirectDebitChannelCode,\n        channel_properties: DirectDebitChannelProperties | None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (DirectDebitChannelCode):\n            channel_properties (DirectDebitChannelProperties):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      158,
      159,
      160,
      161,
      162,
      164,
      183,
      188,
      189,
      247,
      248,
      249,
      250,
      251,
      253,
      254,
      255,
      256,
      257,
      258,
      260,
      269,
      270,
      271,
      272,
      273,
      274,
      276,
      277,
      278,
      279,
      284,
      285,
      286,
      287
    ]
  },
  {
    "file_path": "xendit/payment_method/model/direct_debit_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'DEBIT_CARD': \"DEBIT_CARD\",\n            'BANK_ACCOUNT': \"BANK_ACCOUNT\",\n            'BANK_REDIRECT': \"BANK_REDIRECT\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"DirectDebitType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"DEBIT_CARD\", \"BANK_ACCOUNT\", \"BANK_REDIRECT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"DEBIT_CARD\", \"BANK_ACCOUNT\", \"BANK_REDIRECT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"DirectDebitType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"DEBIT_CARD\", \"BANK_ACCOUNT\", \"BANK_REDIRECT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"DEBIT_CARD\", \"BANK_ACCOUNT\", \"BANK_REDIRECT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      77,
      83,
      144,
      146,
      147,
      148,
      149,
      150,
      152,
      158,
      159,
      160,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      240,
      242,
      244,
      245,
      246,
      247,
      248,
      250,
      256,
      257,
      258,
      259,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      297
    ]
  },
  {
    "file_path": "xendit/payment_method/model/e_wallet.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.e_wallet_account import EWalletAccount\nfrom xendit.payment_method.model.e_wallet_channel_code import EWalletChannelCode\nfrom xendit.payment_method.model.e_wallet_channel_properties import EWalletChannelProperties\nfrom xendit.payment_method.model.e_wallet_parameters import EWalletParameters\nglobals()['EWalletAccount'] = EWalletAccount\nglobals()['EWalletChannelCode'] = EWalletChannelCode\nglobals()['EWalletChannelProperties'] = EWalletChannelProperties\nglobals()['EWalletParameters'] = EWalletParameters\n\ndef lazy_import():\n    pass\n\nclass EWallet(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (EWalletChannelCode,),  # noqa: E501\n            'channel_properties': (EWalletChannelProperties, none_type),  # noqa: E501\n            'account': (EWalletAccount, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'account': 'account',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"EWallet - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (EWalletChannelCode):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_properties (EWalletChannelProperties): [optional]  # noqa: E501\n            account (EWalletAccount): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"EWallet - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (EWalletChannelCode):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_properties (EWalletChannelProperties): [optional]  # noqa: E501\n            account (EWalletAccount): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              EWalletParameters,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      75,
      76,
      90,
      91,
      99,
      152,
      153,
      154,
      155,
      156,
      158,
      160,
      161,
      162,
      163,
      164,
      165,
      167,
      176,
      177,
      178,
      179,
      180,
      181,
      183,
      190,
      192,
      193,
      194,
      195,
      197,
      198,
      203,
      204,
      206,
      260,
      261,
      262,
      263,
      264,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      282,
      283,
      284,
      285,
      286,
      287,
      289,
      296,
      298,
      299,
      300,
      301,
      303,
      304,
      309,
      310,
      311,
      312,
      324,
      325
    ]
  },
  {
    "file_path": "xendit/payment_method/model/e_wallet_account.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass EWalletAccount(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'name': (str, none_type, none_type),  # noqa: E501\n            'account_details': (str, none_type, none_type),  # noqa: E501\n            'balance': (float, none_type, none_type),  # noqa: E501\n            'point_balance': (float, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'name': 'name',  # noqa: E501\n        'account_details': 'account_details',  # noqa: E501\n        'balance': 'balance',  # noqa: E501\n        'point_balance': 'point_balance',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"EWalletAccount - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            name (str, none_type): Name of the eWallet account holder. The value is null if unavailableName of the eWallet account holder. The value is null if unavailable. [optional]  # noqa: E501\n            account_details (str, none_type): Identifier from eWallet provider e.g. phone number. The value is null if unavailable. [optional]  # noqa: E501\n            balance (float, none_type): The main balance amount on eWallet account provided from eWallet provider. The value is null if unavailable. [optional]  # noqa: E501\n            point_balance (float, none_type): The point balance amount on eWallet account. Applicable only on some eWallet provider that has point system. The value is null if unavailabl. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        name: str | None = None,\n        account_details: str | None = None,\n        balance: float | None = None,\n        point_balance: float | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"EWalletAccount - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            name (str, none_type): Name of the eWallet account holder. The value is null if unavailableName of the eWallet account holder. The value is null if unavailable. [optional]  # noqa: E501\n            account_details (str, none_type): Identifier from eWallet provider e.g. phone number. The value is null if unavailable. [optional]  # noqa: E501\n            balance (float, none_type): The main balance amount on eWallet account provided from eWallet provider. The value is null if unavailable. [optional]  # noqa: E501\n            point_balance (float, none_type): The point balance amount on eWallet account. Applicable only on some eWallet provider that has point system. The value is null if unavailabl. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if name is not None:\n            self.name = name\n        if account_details is not None:\n            self.account_details = account_details\n        if balance is not None:\n            self.balance = balance\n        if point_balance is not None:\n            self.point_balance = point_balance\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      90,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      184,
      185,
      186,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      288,
      289,
      290,
      291
    ]
  },
  {
    "file_path": "xendit/payment_method/model/e_wallet_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass EWalletChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'GCASH': \"GCASH\",\n            'GRABPAY': \"GRABPAY\",\n            'PAYMAYA': \"PAYMAYA\",\n            'OVO': \"OVO\",\n            'DANA': \"DANA\",\n            'LINKAJA': \"LINKAJA\",\n            'SHOPEEPAY': \"SHOPEEPAY\",\n            'SAKUKU': \"SAKUKU\",\n            'NEXCASH': \"NEXCASH\",\n            'ASTRAPAY': \"ASTRAPAY\",\n            'JENIUSPAY': \"JENIUSPAY\",\n            'APPOTA': \"APPOTA\",\n            'MOMO': \"MOMO\",\n            'VNPTWALLET': \"VNPTWALLET\",\n            'VIETTELPAY': \"VIETTELPAY\",\n            'ZALOPAY': \"ZALOPAY\",\n            'WECHATPAY': \"WECHATPAY\",\n            'LINEPAY': \"LINEPAY\",\n            'TRUEMONEY': \"TRUEMONEY\",\n            'ALIPAY': \"ALIPAY\",\n            'TOUCHNGO': \"TOUCHNGO\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"EWalletChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): EWallet Channel Code., must be one of [\"GCASH\", \"GRABPAY\", \"PAYMAYA\", \"OVO\", \"DANA\", \"LINKAJA\", \"SHOPEEPAY\", \"SAKUKU\", \"NEXCASH\", \"ASTRAPAY\", \"JENIUSPAY\", \"APPOTA\", \"MOMO\", \"VNPTWALLET\", \"VIETTELPAY\", \"ZALOPAY\", \"WECHATPAY\", \"LINEPAY\", \"TRUEMONEY\", \"ALIPAY\", \"TOUCHNGO\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): EWallet Channel Code., must be one of [\"GCASH\", \"GRABPAY\", \"PAYMAYA\", \"OVO\", \"DANA\", \"LINKAJA\", \"SHOPEEPAY\", \"SAKUKU\", \"NEXCASH\", \"ASTRAPAY\", \"JENIUSPAY\", \"APPOTA\", \"MOMO\", \"VNPTWALLET\", \"VIETTELPAY\", \"ZALOPAY\", \"WECHATPAY\", \"LINEPAY\", \"TRUEMONEY\", \"ALIPAY\", \"TOUCHNGO\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"EWalletChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): EWallet Channel Code., must be one of [\"GCASH\", \"GRABPAY\", \"PAYMAYA\", \"OVO\", \"DANA\", \"LINKAJA\", \"SHOPEEPAY\", \"SAKUKU\", \"NEXCASH\", \"ASTRAPAY\", \"JENIUSPAY\", \"APPOTA\", \"MOMO\", \"VNPTWALLET\", \"VIETTELPAY\", \"ZALOPAY\", \"WECHATPAY\", \"LINEPAY\", \"TRUEMONEY\", \"ALIPAY\", \"TOUCHNGO\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): EWallet Channel Code., must be one of [\"GCASH\", \"GRABPAY\", \"PAYMAYA\", \"OVO\", \"DANA\", \"LINKAJA\", \"SHOPEEPAY\", \"SAKUKU\", \"NEXCASH\", \"ASTRAPAY\", \"JENIUSPAY\", \"APPOTA\", \"MOMO\", \"VNPTWALLET\", \"VIETTELPAY\", \"ZALOPAY\", \"WECHATPAY\", \"LINEPAY\", \"TRUEMONEY\", \"ALIPAY\", \"TOUCHNGO\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      162,
      164,
      165,
      166,
      167,
      168,
      170,
      176,
      177,
      178,
      179,
      181,
      182,
      183,
      184,
      185,
      186,
      188,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      263,
      268,
      280,
      281,
      282,
      283,
      284,
      286,
      303,
      304,
      306
    ]
  },
  {
    "file_path": "xendit/payment_method/model/e_wallet_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass EWalletChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('success_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('failure_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('pending_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('cancel_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('cashtag',): {\n            'regex': {\n                'pattern': r'^[$][a-zA-Z0-9_]{3,15}$',  # noqa: E501\n            },\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'success_return_url': (str, none_type),  # noqa: E501\n            'failure_return_url': (str, none_type),  # noqa: E501\n            'pending_return_url': (str, none_type),  # noqa: E501\n            'cancel_return_url': (str, none_type),  # noqa: E501\n            'mobile_number': (str, none_type),  # noqa: E501\n            'redeem_points': (str, none_type),  # noqa: E501\n            'cashtag': (str, none_type),  # noqa: E501\n            'promotion_label': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'success_return_url': 'success_return_url',  # noqa: E501\n        'failure_return_url': 'failure_return_url',  # noqa: E501\n        'pending_return_url': 'pending_return_url',  # noqa: E501\n        'cancel_return_url': 'cancel_return_url',  # noqa: E501\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'redeem_points': 'redeem_points',  # noqa: E501\n        'cashtag': 'cashtag',  # noqa: E501\n        'promotion_label': 'promotion_label',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"EWalletChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            pending_return_url (str): URL where the end-customer is redirected if the authorization is pending. [optional]  # noqa: E501\n            cancel_return_url (str): URL where the end-customer is redirected if the authorization cancelled. [optional]  # noqa: E501\n            mobile_number (str): Mobile number of customer in E.164 format (e.g. +628123123123). For OVO one time payment use only.. [optional]  # noqa: E501\n            redeem_points (str): REDEEM_NONE will not use any point, REDEEM_ALL will use all available points before cash balance is used. For OVO and ShopeePay tokenized payment use only.. [optional]  # noqa: E501\n            cashtag (str): Available for JENIUSPAY only. [optional]  # noqa: E501\n            promotion_label (str): Available only for OVO. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        success_return_url: str | None = None,\n        failure_return_url: str | None = None,\n        pending_return_url: str | None = None,\n        cancel_return_url: str | None = None,\n        mobile_number: str | None = None,\n        redeem_points: str | None = None,\n        cashtag: str | None = None,\n        promotion_label: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"EWalletChannelProperties - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            pending_return_url (str): URL where the end-customer is redirected if the authorization is pending. [optional]  # noqa: E501\n            cancel_return_url (str): URL where the end-customer is redirected if the authorization cancelled. [optional]  # noqa: E501\n            mobile_number (str): Mobile number of customer in E.164 format (e.g. +628123123123). For OVO one time payment use only.. [optional]  # noqa: E501\n            redeem_points (str): REDEEM_NONE will not use any point, REDEEM_ALL will use all available points before cash balance is used. For OVO and ShopeePay tokenized payment use only.. [optional]  # noqa: E501\n            cashtag (str): Available for JENIUSPAY only. [optional]  # noqa: E501\n            promotion_label (str): Available only for OVO. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if success_return_url is not None:\n            self.success_return_url = success_return_url\n        if failure_return_url is not None:\n            self.failure_return_url = failure_return_url\n        if pending_return_url is not None:\n            self.pending_return_url = pending_return_url\n        if cancel_return_url is not None:\n            self.cancel_return_url = cancel_return_url\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if redeem_points is not None:\n            self.redeem_points = redeem_points\n        if cashtag is not None:\n            self.cashtag = cashtag\n        if promotion_label is not None:\n            self.promotion_label = promotion_label\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      92,
      193,
      194,
      195,
      196,
      197,
      199,
      221,
      290,
      291,
      292,
      293,
      294,
      296,
      297,
      298,
      299,
      300,
      301,
      303,
      312,
      313,
      314,
      315,
      316,
      317,
      319,
      320,
      321,
      322,
      323,
      324,
      325,
      326,
      327,
      328,
      329,
      330,
      331,
      332,
      333,
      334,
      335,
      336,
      341,
      342,
      343,
      344
    ]
  },
  {
    "file_path": "xendit/payment_method/model/e_wallet_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.e_wallet_account import EWalletAccount\nfrom xendit.payment_method.model.e_wallet_channel_code import EWalletChannelCode\nfrom xendit.payment_method.model.e_wallet_channel_properties import EWalletChannelProperties\nglobals()['EWalletAccount'] = EWalletAccount\nglobals()['EWalletChannelCode'] = EWalletChannelCode\nglobals()['EWalletChannelProperties'] = EWalletChannelProperties\n\ndef lazy_import():\n    pass\n\nclass EWalletParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (EWalletChannelCode,),  # noqa: E501\n            'channel_properties': (EWalletChannelProperties, none_type),  # noqa: E501\n            'account': (EWalletAccount, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'account': 'account',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, channel_code, *args, **kwargs):  # noqa: E501\n        \"\"\"EWalletParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (EWalletChannelCode):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_properties (EWalletChannelProperties): [optional]  # noqa: E501\n            account (EWalletAccount): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_code: EWalletChannelCode,\n        channel_properties: EWalletChannelProperties | None = None,\n        account: EWalletAccount | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"EWalletParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (EWalletChannelCode):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_properties (EWalletChannelProperties): [optional]  # noqa: E501\n            account (EWalletAccount): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        if channel_properties is not None:\n            self.channel_properties = channel_properties\n        if account is not None:\n            self.account = account\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      73,
      74,
      163,
      164,
      165,
      166,
      167,
      169,
      192,
      253,
      254,
      255,
      256,
      257,
      259,
      260,
      261,
      262,
      263,
      264,
      266,
      275,
      276,
      277,
      278,
      279,
      280,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      293,
      294,
      295,
      296
    ]
  },
  {
    "file_path": "xendit/payment_method/model/get_all_payment_methods400_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass GetAllPaymentMethods400Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'ACCOUNT_ACCESS_BLOCKED': \"ACCOUNT_ACCESS_BLOCKED\",\n            'ADDRESS_VALIDATION_FAILED': \"ADDRESS_VALIDATION_FAILED\",\n            'AMOUNT_MISMATCHED': \"AMOUNT_MISMATCHED\",\n            'API_VALIDATION_ERROR': \"API_VALIDATION_ERROR\",\n            'AUTHENTICATION_FAILED': \"AUTHENTICATION_FAILED\",\n            'AUTHENTICATION_REQUIRED': \"AUTHENTICATION_REQUIRED\",\n            'BRAND_NOT_SUPPORTED': \"BRAND_NOT_SUPPORTED\",\n            'CARD_DECLINED': \"CARD_DECLINED\",\n            'CHANNEL_CODE_NOT_SUPPORTED_ERROR': \"CHANNEL_CODE_NOT_SUPPORTED_ERROR\",\n            'COF_COMBINATION_NOT_ALLOWED_ERROR': \"COF_COMBINATION_NOT_ALLOWED_ERROR\",\n            'CURRENCY_MISMATCHED': \"CURRENCY_MISMATCHED\",\n            'CUSTOMER_NOT_FOUND_ERROR': \"CUSTOMER_NOT_FOUND_ERROR\",\n            'CUSTOMER_PAYMENT_METHOD_MISMATCHED': \"CUSTOMER_PAYMENT_METHOD_MISMATCHED\",\n            'DECLINED_BY_ISSUER': \"DECLINED_BY_ISSUER\",\n            'DECLINED_BY_PROCESSOR': \"DECLINED_BY_PROCESSOR\",\n            'DUPLICATED_FIXED_PAYMENT_INSTRUMENT': \"DUPLICATED_FIXED_PAYMENT_INSTRUMENT\",\n            'DUPLICATE_REFERENCE': \"DUPLICATE_REFERENCE\",\n            'EXPIRED_CARD': \"EXPIRED_CARD\",\n            'EXPIRED_OTP_ERROR': \"EXPIRED_OTP_ERROR\",\n            'FEATURE_NOT_ACTIVATED': \"FEATURE_NOT_ACTIVATED\",\n            'INACTIVE_OR_UNAUTHORIZED_CARD': \"INACTIVE_OR_UNAUTHORIZED_CARD\",\n            'INACTIVE_PAYMENT_METHOD': \"INACTIVE_PAYMENT_METHOD\",\n            'INCORRECT_AMOUNT': \"INCORRECT_AMOUNT\",\n            'INSUFFICIENT_BALANCE': \"INSUFFICIENT_BALANCE\",\n            'INVALID_ACCOUNT_DETAILS': \"INVALID_ACCOUNT_DETAILS\",\n            'INVALID_CVV': \"INVALID_CVV\",\n            'INVALID_LINKED_ACCOUNT': \"INVALID_LINKED_ACCOUNT\",\n            'INVALID_OTP_ERROR': \"INVALID_OTP_ERROR\",\n            'INVALID_PAYMENT_METHOD': \"INVALID_PAYMENT_METHOD\",\n            'INVALID_TOKEN': \"INVALID_TOKEN\",\n            'LINKED_ACCOUNT_NOT_FOUND_ERROR': \"LINKED_ACCOUNT_NOT_FOUND_ERROR\",\n            'MAX_ACCOUNT_LINKING': \"MAX_ACCOUNT_LINKING\",\n            'MAX_AMOUNT_LIMIT_ERROR': \"MAX_AMOUNT_LIMIT_ERROR\",\n            'MAX_OTP_ATTEMPTS_ERROR': \"MAX_OTP_ATTEMPTS_ERROR\",\n            'NOT_SUPPORTED_BY_CHANNEL': \"NOT_SUPPORTED_BY_CHANNEL\",\n            'OPERATION_NOT_ALLOWED': \"OPERATION_NOT_ALLOWED\",\n            'OTP_DELIVERY_ERROR': \"OTP_DELIVERY_ERROR\",\n            'PARTNER_CHANNEL_ERROR': \"PARTNER_CHANNEL_ERROR\",\n            'PAYMENT_METHOD_NOT_FOUND_ERROR': \"PAYMENT_METHOD_NOT_FOUND_ERROR\",\n            'PAYMENT_METHOD_NOT_SUPPORTED': \"PAYMENT_METHOD_NOT_SUPPORTED\",\n            'PAYMENT_METHOD_REUSABILITY_INVALID': \"PAYMENT_METHOD_REUSABILITY_INVALID\",\n            'PAYMENT_METHOD_STATUS_INVALID': \"PAYMENT_METHOD_STATUS_INVALID\",\n            'PAYMENT_METHOD_TYPE_INVALID': \"PAYMENT_METHOD_TYPE_INVALID\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"GetAllPaymentMethods400Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"GetAllPaymentMethods400Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      112,
      126,
      133,
      186,
      187,
      188,
      189,
      190,
      192,
      194,
      195,
      196,
      197,
      198,
      199,
      201,
      210,
      211,
      212,
      213,
      214,
      215,
      217,
      218,
      223,
      224,
      225,
      280,
      281,
      282,
      283,
      284,
      286,
      287,
      288,
      289,
      290,
      291,
      293,
      302,
      303,
      304,
      305,
      306,
      307,
      309,
      310,
      311,
      312,
      313,
      314,
      319,
      320,
      321,
      322
    ]
  },
  {
    "file_path": "xendit/payment_method/model/get_all_payment_methods403_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass GetAllPaymentMethods403Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'UNAUTHORIZED': \"UNAUTHORIZED\",\n            'CHANNEL_NOT_ACTIVATED': \"CHANNEL_NOT_ACTIVATED\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"GetAllPaymentMethods403Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"GetAllPaymentMethods403Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      85,
      92,
      145,
      146,
      147,
      148,
      149,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      160,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/payment_method/model/get_all_payment_methods404_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass GetAllPaymentMethods404Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'DATA_NOT_FOUND': \"DATA_NOT_FOUND\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"GetAllPaymentMethods404Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional] if omitted the server will use the default value of \"DATA_NOT_FOUND\"  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        message: str | None = None,\n        error_code: str | None = \"DATA_NOT_FOUND\",\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"GetAllPaymentMethods404Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional] if omitted the server will use the default value of \"DATA_NOT_FOUND\"  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      91,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      181,
      182,
      183,
      238,
      239,
      240,
      241,
      242,
      244,
      245,
      246,
      247,
      248,
      249,
      251,
      260,
      261,
      262,
      263,
      264,
      265,
      267,
      268,
      269,
      270,
      271,
      272,
      277,
      278,
      279,
      280
    ]
  },
  {
    "file_path": "xendit/payment_method/model/get_all_payment_methods_default_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass GetAllPaymentMethodsDefaultResponse(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"GetAllPaymentMethodsDefaultResponse - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"GetAllPaymentMethodsDefaultResponse - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/payment_method/model/over_the_counter.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.over_the_counter_channel_code import OverTheCounterChannelCode\nfrom xendit.payment_method.model.over_the_counter_channel_properties import OverTheCounterChannelProperties\nfrom xendit.payment_method.model.over_the_counter_parameters import OverTheCounterParameters\nglobals()['OverTheCounterChannelCode'] = OverTheCounterChannelCode\nglobals()['OverTheCounterChannelProperties'] = OverTheCounterChannelProperties\nglobals()['OverTheCounterParameters'] = OverTheCounterParameters\n\ndef lazy_import():\n    pass\n\nclass OverTheCounter(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (OverTheCounterChannelCode,),  # noqa: E501\n            'channel_properties': (OverTheCounterChannelProperties,),  # noqa: E501\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'currency': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"OverTheCounter - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (OverTheCounterChannelCode):\n            channel_properties (OverTheCounterChannelProperties):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"OverTheCounter - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (OverTheCounterChannelCode):\n            channel_properties (OverTheCounterChannelProperties):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              OverTheCounterParameters,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      73,
      74,
      88,
      89,
      98,
      153,
      154,
      155,
      156,
      157,
      159,
      161,
      162,
      163,
      164,
      165,
      166,
      168,
      177,
      178,
      179,
      180,
      181,
      182,
      184,
      191,
      193,
      194,
      195,
      196,
      198,
      199,
      204,
      205,
      207,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      275,
      284,
      285,
      286,
      287,
      288,
      289,
      291,
      298,
      300,
      301,
      302,
      303,
      305,
      306,
      311,
      312,
      313,
      314,
      326,
      327
    ]
  },
  {
    "file_path": "xendit/payment_method/model/over_the_counter_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass OverTheCounterChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            '7ELEVEN': \"7ELEVEN\",\n            '7ELEVEN_CLIQQ': \"7ELEVEN_CLIQQ\",\n            'CEBUANA': \"CEBUANA\",\n            'ECPAY': \"ECPAY\",\n            'PALAWAN': \"PALAWAN\",\n            'MLHUILLIER': \"MLHUILLIER\",\n            'ECPAY_DRAGONLOAN': \"ECPAY_DRAGONLOAN\",\n            'LBC': \"LBC\",\n            'ECPAY_SCHOOL': \"ECPAY_SCHOOL\",\n            'RD_PAWNSHOP': \"RD_PAWNSHOP\",\n            'CVM': \"CVM\",\n            'USSC': \"USSC\",\n            'SM_BILLS': \"SM_BILLS\",\n            'ROBINSONS_BILLS': \"ROBINSONS_BILLS\",\n            'ALFAMART': \"ALFAMART\",\n            'INDOMARET': \"INDOMARET\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"OverTheCounterChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Over The Counter Channel Code., must be one of [\"7ELEVEN\", \"7ELEVEN_CLIQQ\", \"CEBUANA\", \"ECPAY\", \"PALAWAN\", \"MLHUILLIER\", \"ECPAY_DRAGONLOAN\", \"LBC\", \"ECPAY_SCHOOL\", \"RD_PAWNSHOP\", \"CVM\", \"USSC\", \"SM_BILLS\", \"ROBINSONS_BILLS\", \"ALFAMART\", \"INDOMARET\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Over The Counter Channel Code., must be one of [\"7ELEVEN\", \"7ELEVEN_CLIQQ\", \"CEBUANA\", \"ECPAY\", \"PALAWAN\", \"MLHUILLIER\", \"ECPAY_DRAGONLOAN\", \"LBC\", \"ECPAY_SCHOOL\", \"RD_PAWNSHOP\", \"CVM\", \"USSC\", \"SM_BILLS\", \"ROBINSONS_BILLS\", \"ALFAMART\", \"INDOMARET\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"OverTheCounterChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Over The Counter Channel Code., must be one of [\"7ELEVEN\", \"7ELEVEN_CLIQQ\", \"CEBUANA\", \"ECPAY\", \"PALAWAN\", \"MLHUILLIER\", \"ECPAY_DRAGONLOAN\", \"LBC\", \"ECPAY_SCHOOL\", \"RD_PAWNSHOP\", \"CVM\", \"USSC\", \"SM_BILLS\", \"ROBINSONS_BILLS\", \"ALFAMART\", \"INDOMARET\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Over The Counter Channel Code., must be one of [\"7ELEVEN\", \"7ELEVEN_CLIQQ\", \"CEBUANA\", \"ECPAY\", \"PALAWAN\", \"MLHUILLIER\", \"ECPAY_DRAGONLOAN\", \"LBC\", \"ECPAY_SCHOOL\", \"RD_PAWNSHOP\", \"CVM\", \"USSC\", \"SM_BILLS\", \"ROBINSONS_BILLS\", \"ALFAMART\", \"INDOMARET\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      90,
      96,
      157,
      159,
      160,
      161,
      162,
      163,
      165,
      171,
      172,
      173,
      174,
      176,
      177,
      178,
      179,
      180,
      181,
      183,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      253,
      255,
      257,
      258,
      259,
      260,
      261,
      263,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      281,
      290,
      291,
      292,
      293,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      301,
      310
    ]
  },
  {
    "file_path": "xendit/payment_method/model/over_the_counter_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass OverTheCounterChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'customer_name': (str,),  # noqa: E501\n            'payment_code': (str, none_type),  # noqa: E501\n            'expires_at': (datetime, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'customer_name': 'customer_name',  # noqa: E501\n        'payment_code': 'payment_code',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, customer_name, *args, **kwargs):  # noqa: E501\n        \"\"\"OverTheCounterChannelProperties - a model defined in OpenAPI\n\n        Args:\n            customer_name (str): Name of customer.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_code (str): The payment code that you want to assign, e.g 12345. If you do not send one, one will be picked at random.. [optional]  # noqa: E501\n            expires_at (datetime): The time when the payment code will be expired. The minimum is 2 hours and the maximum is 9 days for 7ELEVEN. Default expired date will be 2 days from payment code generated.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.customer_name = customer_name\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        customer_name: str,\n        payment_code: str | None = None,\n        expires_at: datetime | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"OverTheCounterChannelProperties - a model defined in OpenAPI\n\n        Args:\n            customer_name (str): Name of customer.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_code (str): The payment code that you want to assign, e.g 12345. If you do not send one, one will be picked at random.. [optional]  # noqa: E501\n            expires_at (datetime): The time when the payment code will be expired. The minimum is 2 hours and the maximum is 9 days for 7ELEVEN. Default expired date will be 2 days from payment code generated.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.customer_name = customer_name\n        if payment_code is not None:\n            self.payment_code = payment_code\n        if expires_at is not None:\n            self.expires_at = expires_at\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      146,
      147,
      148,
      149,
      150,
      152,
      154,
      155,
      156,
      157,
      158,
      159,
      161,
      170,
      171,
      172,
      173,
      174,
      175,
      177,
      178,
      179,
      184,
      185,
      186,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      285,
      286,
      287,
      288
    ]
  },
  {
    "file_path": "xendit/payment_method/model/over_the_counter_channel_properties_update.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass OverTheCounterChannelPropertiesUpdate(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'customer_name': (str, none_type),  # noqa: E501\n            'expires_at': (datetime, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'customer_name': 'customer_name',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"OverTheCounterChannelPropertiesUpdate - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            customer_name (str): Name of customer.. [optional]  # noqa: E501\n            expires_at (datetime): The time when the payment code will be expired. The minimum is 2 hours and the maximum is 9 days for 7ELEVEN. Default expired date will be 2 days from payment code generated.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        customer_name: str | None = None,\n        expires_at: datetime | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"OverTheCounterChannelPropertiesUpdate - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            customer_name (str): Name of customer.. [optional]  # noqa: E501\n            expires_at (datetime): The time when the payment code will be expired. The minimum is 2 hours and the maximum is 9 days for 7ELEVEN. Default expired date will be 2 days from payment code generated.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if customer_name is not None:\n            self.customer_name = customer_name\n        if expires_at is not None:\n            self.expires_at = expires_at\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/payment_method/model/over_the_counter_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.over_the_counter_channel_code import OverTheCounterChannelCode\nfrom xendit.payment_method.model.over_the_counter_channel_properties import OverTheCounterChannelProperties\nglobals()['OverTheCounterChannelCode'] = OverTheCounterChannelCode\nglobals()['OverTheCounterChannelProperties'] = OverTheCounterChannelProperties\n\ndef lazy_import():\n    pass\n\nclass OverTheCounterParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (OverTheCounterChannelCode,),  # noqa: E501\n            'channel_properties': (OverTheCounterChannelProperties,),  # noqa: E501\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'currency': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, channel_code, channel_properties, *args, **kwargs):  # noqa: E501\n        \"\"\"OverTheCounterParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (OverTheCounterChannelCode):\n            channel_properties (OverTheCounterChannelProperties):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_code: OverTheCounterChannelCode,\n        channel_properties: OverTheCounterChannelProperties,\n        amount: float | None = None,\n        currency: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"OverTheCounterParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (OverTheCounterChannelCode):\n            channel_properties (OverTheCounterChannelProperties):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        if amount is not None:\n            self.amount = amount\n        if currency is not None:\n            self.currency = currency\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      86,
      87,
      96,
      155,
      156,
      157,
      158,
      159,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      186,
      187,
      188,
      189,
      194,
      195,
      196,
      257,
      258,
      259,
      260,
      261,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      279,
      280,
      281,
      282,
      283,
      284,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      298,
      299,
      300,
      301
    ]
  },
  {
    "file_path": "xendit/payment_method/model/over_the_counter_update_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.over_the_counter_channel_properties_update import OverTheCounterChannelPropertiesUpdate\nglobals()['OverTheCounterChannelPropertiesUpdate'] = OverTheCounterChannelPropertiesUpdate\n\ndef lazy_import():\n    pass\n\nclass OverTheCounterUpdateParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'channel_properties': (OverTheCounterChannelPropertiesUpdate, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'amount': 'amount',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"OverTheCounterUpdateParameters - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            channel_properties (OverTheCounterChannelPropertiesUpdate): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        amount: float | None = None,\n        channel_properties: OverTheCounterChannelPropertiesUpdate | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"OverTheCounterUpdateParameters - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            channel_properties (OverTheCounterChannelPropertiesUpdate): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if amount is not None:\n            self.amount = amount\n        if channel_properties is not None:\n            self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      92,
      145,
      146,
      147,
      148,
      149,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      160,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.billing_information import BillingInformation\nfrom xendit.payment_method.model.card import Card\nfrom xendit.payment_method.model.direct_debit import DirectDebit\nfrom xendit.payment_method.model.e_wallet import EWallet\nfrom xendit.payment_method.model.over_the_counter import OverTheCounter\nfrom xendit.payment_method.model.payment_method_action import PaymentMethodAction\nfrom xendit.payment_method.model.payment_method_country import PaymentMethodCountry\nfrom xendit.payment_method.model.payment_method_reusability import PaymentMethodReusability\nfrom xendit.payment_method.model.payment_method_status import PaymentMethodStatus\nfrom xendit.payment_method.model.payment_method_type import PaymentMethodType\nfrom xendit.payment_method.model.qr_code import QRCode\nfrom xendit.payment_method.model.virtual_account import VirtualAccount\nglobals()['BillingInformation'] = BillingInformation\nglobals()['Card'] = Card\nglobals()['DirectDebit'] = DirectDebit\nglobals()['EWallet'] = EWallet\nglobals()['OverTheCounter'] = OverTheCounter\nglobals()['PaymentMethodAction'] = PaymentMethodAction\nglobals()['PaymentMethodCountry'] = PaymentMethodCountry\nglobals()['PaymentMethodReusability'] = PaymentMethodReusability\nglobals()['PaymentMethodStatus'] = PaymentMethodStatus\nglobals()['PaymentMethodType'] = PaymentMethodType\nglobals()['QRCode'] = QRCode\nglobals()['VirtualAccount'] = VirtualAccount\n\ndef lazy_import():\n    pass\n\nclass PaymentMethod(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'id': (str,),  # noqa: E501\n            'business_id': (str, none_type),  # noqa: E501\n            'type': (PaymentMethodType, none_type),  # noqa: E501\n            'country': (PaymentMethodCountry, none_type),  # noqa: E501\n            'customer_id': (str, none_type, none_type),  # noqa: E501\n            'customer': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n            'reference_id': (str, none_type),  # noqa: E501\n            'description': (str, none_type, none_type),  # noqa: E501\n            'status': (PaymentMethodStatus, none_type),  # noqa: E501\n            'reusability': (PaymentMethodReusability, none_type),  # noqa: E501\n            'actions': ([PaymentMethodAction], none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n            'billing_information': (BillingInformation, none_type),  # noqa: E501\n            'failure_code': (str, none_type, none_type),  # noqa: E501\n            'created': (datetime, none_type),  # noqa: E501\n            'updated': (datetime, none_type),  # noqa: E501\n            'ewallet': (EWallet, none_type),  # noqa: E501\n            'direct_debit': (DirectDebit, none_type),  # noqa: E501\n            'over_the_counter': (OverTheCounter, none_type),  # noqa: E501\n            'card': (Card, none_type),  # noqa: E501\n            'qr_code': (QRCode, none_type),  # noqa: E501\n            'virtual_account': (VirtualAccount, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'id': 'id',  # noqa: E501\n        'business_id': 'business_id',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'country': 'country',  # noqa: E501\n        'customer_id': 'customer_id',  # noqa: E501\n        'customer': 'customer',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'reusability': 'reusability',  # noqa: E501\n        'actions': 'actions',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n        'billing_information': 'billing_information',  # noqa: E501\n        'failure_code': 'failure_code',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'ewallet': 'ewallet',  # noqa: E501\n        'direct_debit': 'direct_debit',  # noqa: E501\n        'over_the_counter': 'over_the_counter',  # noqa: E501\n        'card': 'card',  # noqa: E501\n        'qr_code': 'qr_code',  # noqa: E501\n        'virtual_account': 'virtual_account',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, id, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentMethod - a model defined in OpenAPI\n\n        Args:\n            id (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            business_id (str): [optional]  # noqa: E501\n            type (PaymentMethodType): [optional]  # noqa: E501\n            country (PaymentMethodCountry): [optional]  # noqa: E501\n            customer_id (str, none_type): [optional]  # noqa: E501\n            customer ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            status (PaymentMethodStatus): [optional]  # noqa: E501\n            reusability (PaymentMethodReusability): [optional]  # noqa: E501\n            actions ([PaymentMethodAction]): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            billing_information (BillingInformation): [optional]  # noqa: E501\n            failure_code (str, none_type): [optional]  # noqa: E501\n            created (datetime): [optional]  # noqa: E501\n            updated (datetime): [optional]  # noqa: E501\n            ewallet (EWallet): [optional]  # noqa: E501\n            direct_debit (DirectDebit): [optional]  # noqa: E501\n            over_the_counter (OverTheCounter): [optional]  # noqa: E501\n            card (Card): [optional]  # noqa: E501\n            qr_code (QRCode): [optional]  # noqa: E501\n            virtual_account (VirtualAccount): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        id: str,\n        business_id: str | None = None,\n        type: PaymentMethodType | None = None,\n        country: PaymentMethodCountry | None = None,\n        customer_id: str | None = None,\n        customer: dict | None = None,\n        reference_id: str | None = None,\n        description: str | None = None,\n        status: PaymentMethodStatus | None = None,\n        reusability: PaymentMethodReusability | None = None,\n        actions: list | None = None,\n        metadata: dict | None = None,\n        billing_information: BillingInformation | None = None,\n        failure_code: str | None = None,\n        created: datetime | None = None,\n        updated: datetime | None = None,\n        ewallet: EWallet | None = None,\n        direct_debit: DirectDebit | None = None,\n        over_the_counter: OverTheCounter | None = None,\n        card: Card | None = None,\n        qr_code: QRCode | None = None,\n        virtual_account: VirtualAccount | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentMethod - a model defined in OpenAPI\n\n        Args:\n            id (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            business_id (str): [optional]  # noqa: E501\n            type (PaymentMethodType): [optional]  # noqa: E501\n            country (PaymentMethodCountry): [optional]  # noqa: E501\n            customer_id (str, none_type): [optional]  # noqa: E501\n            customer ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            status (PaymentMethodStatus): [optional]  # noqa: E501\n            reusability (PaymentMethodReusability): [optional]  # noqa: E501\n            actions ([PaymentMethodAction]): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            billing_information (BillingInformation): [optional]  # noqa: E501\n            failure_code (str, none_type): [optional]  # noqa: E501\n            created (datetime): [optional]  # noqa: E501\n            updated (datetime): [optional]  # noqa: E501\n            ewallet (EWallet): [optional]  # noqa: E501\n            direct_debit (DirectDebit): [optional]  # noqa: E501\n            over_the_counter (OverTheCounter): [optional]  # noqa: E501\n            card (Card): [optional]  # noqa: E501\n            qr_code (QRCode): [optional]  # noqa: E501\n            virtual_account (VirtualAccount): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        if business_id is not None:\n            self.business_id = business_id\n        if type is not None:\n            self.type = type\n        if country is not None:\n            self.country = country\n        if customer_id is not None:\n            self.customer_id = customer_id\n        if customer is not None:\n            self.customer = customer\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if description is not None:\n            self.description = description\n        if status is not None:\n            self.status = status\n        if reusability is not None:\n            self.reusability = reusability\n        if actions is not None:\n            self.actions = actions\n        if metadata is not None:\n            self.metadata = metadata\n        if billing_information is not None:\n            self.billing_information = billing_information\n        if failure_code is not None:\n            self.failure_code = failure_code\n        if created is not None:\n            self.created = created\n        if updated is not None:\n            self.updated = updated\n        if ewallet is not None:\n            self.ewallet = ewallet\n        if direct_debit is not None:\n            self.direct_debit = direct_debit\n        if over_the_counter is not None:\n            self.over_the_counter = over_the_counter\n        if card is not None:\n            self.card = card\n        if qr_code is not None:\n            self.qr_code = qr_code\n        if virtual_account is not None:\n            self.virtual_account = virtual_account\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      91,
      92,
      106,
      107,
      134,
      229,
      230,
      231,
      232,
      233,
      235,
      237,
      238,
      239,
      240,
      241,
      242,
      244,
      253,
      254,
      255,
      256,
      257,
      258,
      260,
      261,
      262,
      267,
      268,
      269,
      366,
      367,
      368,
      369,
      370,
      372,
      373,
      374,
      375,
      376,
      377,
      379,
      388,
      389,
      390,
      391,
      392,
      393,
      395,
      396,
      397,
      398,
      399,
      400,
      401,
      402,
      403,
      404,
      405,
      406,
      407,
      408,
      409,
      410,
      411,
      412,
      413,
      414,
      415,
      416,
      417,
      418,
      419,
      420,
      421,
      422,
      423,
      424,
      425,
      426,
      427,
      428,
      429,
      430,
      431,
      432,
      433,
      434,
      435,
      436,
      437,
      438,
      439,
      444,
      445,
      446,
      447
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method_action.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodAction(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'action': (str, none_type),  # noqa: E501\n            'method': (str, none_type),  # noqa: E501\n            'url': (str, none_type),  # noqa: E501\n            'url_type': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'action': 'action',  # noqa: E501\n        'method': 'method',  # noqa: E501\n        'url': 'url',  # noqa: E501\n        'url_type': 'url_type',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentMethodAction - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            action (str): [optional]  # noqa: E501\n            method (str): [optional]  # noqa: E501\n            url (str): [optional]  # noqa: E501\n            url_type (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        action: str | None = None,\n        method: str | None = None,\n        url: str | None = None,\n        url_type: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentMethodAction - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            action (str): [optional]  # noqa: E501\n            method (str): [optional]  # noqa: E501\n            url (str): [optional]  # noqa: E501\n            url_type (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if action is not None:\n            self.action = action\n        if method is not None:\n            self.method = method\n        if url is not None:\n            self.url = url\n        if url_type is not None:\n            self.url_type = url_type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      90,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      184,
      185,
      186,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      288,
      289,
      290,
      291
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method_auth_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodAuthParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('auth_code',): {\n            'max_length': 6,\n            'min_length': 6,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'auth_code': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'auth_code': 'auth_code',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, auth_code, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentMethodAuthParameters - a model defined in OpenAPI\n\n        Args:\n            auth_code (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.auth_code = auth_code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        auth_code: str,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentMethodAuthParameters - a model defined in OpenAPI\n\n        Args:\n            auth_code (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.auth_code = auth_code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      85,
      91,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      275,
      276,
      277,
      278
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method_callback.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.payment_method import PaymentMethod\nglobals()['PaymentMethod'] = PaymentMethod\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodCallback(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'event': (str,),  # noqa: E501\n            'business_id': (str,),  # noqa: E501\n            'created': (str,),  # noqa: E501\n            'data': (PaymentMethod, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'event': 'event',  # noqa: E501\n        'business_id': 'business_id',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'data': 'data',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, event, business_id, created, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentMethodCallback - a model defined in OpenAPI\n\n        Args:\n            event (str): Identifies the event that triggered a notification to the merchant\n            business_id (str): business_id\n            created (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            data (PaymentMethod): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.event = event\n        self.business_id = business_id\n        self.created = created\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        event: str,\n        business_id: str,\n        created: str,\n        data: PaymentMethod | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentMethodCallback - a model defined in OpenAPI\n\n        Args:\n            event (str): Identifies the event that triggered a notification to the merchant\n            business_id (str): business_id\n            created (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            data (PaymentMethod): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.event = event\n        self.business_id = business_id\n        self.created = created\n        if data is not None:\n            self.data = data\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      94,
      153,
      154,
      155,
      156,
      157,
      159,
      161,
      162,
      163,
      164,
      165,
      166,
      168,
      177,
      178,
      179,
      180,
      181,
      182,
      184,
      185,
      186,
      187,
      188,
      193,
      194,
      195,
      256,
      257,
      258,
      259,
      260,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      278,
      279,
      280,
      281,
      282,
      283,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      296,
      297,
      298,
      299
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method_country.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodCountry(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'PH': \"PH\",\n            'ID': \"ID\",\n            'VN': \"VN\",\n            'TH': \"TH\",\n            'MY': \"MY\",\n            'US': \"US\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentMethodCountry - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"PH\", \"ID\", \"VN\", \"TH\", \"MY\", \"US\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"PH\", \"ID\", \"VN\", \"TH\", \"MY\", \"US\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentMethodCountry - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"PH\", \"ID\", \"VN\", \"TH\", \"MY\", \"US\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"PH\", \"ID\", \"VN\", \"TH\", \"MY\", \"US\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      80,
      86,
      147,
      149,
      150,
      151,
      152,
      153,
      155,
      161,
      162,
      163,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      243,
      245,
      247,
      248,
      249,
      250,
      251,
      253,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      271,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      300
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method_expire_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodExpireParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'success_return_url': (str, none_type, none_type),  # noqa: E501\n            'failure_return_url': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'success_return_url': 'success_return_url',  # noqa: E501\n        'failure_return_url': 'failure_return_url',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentMethodExpireParameters - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str, none_type): URL where the end customer is redirected if the unlinking authorization is successful.. [optional]  # noqa: E501\n            failure_return_url (str, none_type): URL where the end customer is redirected if the unlinking authorization is failed.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        success_return_url: str | None = None,\n        failure_return_url: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentMethodExpireParameters - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str, none_type): URL where the end customer is redirected if the unlinking authorization is successful.. [optional]  # noqa: E501\n            failure_return_url (str, none_type): URL where the end customer is redirected if the unlinking authorization is failed.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if success_return_url is not None:\n            self.success_return_url = success_return_url\n        if failure_return_url is not None:\n            self.failure_return_url = failure_return_url\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method_list.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.payment_method import PaymentMethod\nglobals()['PaymentMethod'] = PaymentMethod\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodList(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'data': ([PaymentMethod],),  # noqa: E501\n            'has_more': (bool, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'data': 'data',  # noqa: E501\n        'has_more': 'has_more',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, data, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentMethodList - a model defined in OpenAPI\n\n        Args:\n            data ([PaymentMethod]):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            has_more (bool): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.data = data\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        data: list,\n        has_more: bool | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentMethodList - a model defined in OpenAPI\n\n        Args:\n            data ([PaymentMethod]):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            has_more (bool): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.data = data\n        if has_more is not None:\n            self.has_more = has_more\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      92,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      180,
      185,
      186,
      187,
      244,
      245,
      246,
      247,
      248,
      250,
      251,
      252,
      253,
      254,
      255,
      257,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      274,
      275,
      276,
      277,
      282,
      283,
      284,
      285
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.billing_information import BillingInformation\nfrom xendit.payment_method.model.card_parameters import CardParameters\nfrom xendit.payment_method.model.direct_debit_parameters import DirectDebitParameters\nfrom xendit.payment_method.model.e_wallet_parameters import EWalletParameters\nfrom xendit.payment_method.model.over_the_counter_parameters import OverTheCounterParameters\nfrom xendit.payment_method.model.payment_method_reusability import PaymentMethodReusability\nfrom xendit.payment_method.model.payment_method_type import PaymentMethodType\nfrom xendit.payment_method.model.qr_code_parameters import QRCodeParameters\nfrom xendit.payment_method.model.virtual_account_parameters import VirtualAccountParameters\nglobals()['BillingInformation'] = BillingInformation\nglobals()['CardParameters'] = CardParameters\nglobals()['DirectDebitParameters'] = DirectDebitParameters\nglobals()['EWalletParameters'] = EWalletParameters\nglobals()['OverTheCounterParameters'] = OverTheCounterParameters\nglobals()['PaymentMethodReusability'] = PaymentMethodReusability\nglobals()['PaymentMethodType'] = PaymentMethodType\nglobals()['QRCodeParameters'] = QRCodeParameters\nglobals()['VirtualAccountParameters'] = VirtualAccountParameters\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'type': (PaymentMethodType,),  # noqa: E501\n            'reusability': (PaymentMethodReusability,),  # noqa: E501\n            'country': (str, none_type, none_type),  # noqa: E501\n            'customer_id': (str, none_type, none_type),  # noqa: E501\n            'reference_id': (str, none_type),  # noqa: E501\n            'description': (str, none_type, none_type),  # noqa: E501\n            'card': (CardParameters, none_type),  # noqa: E501\n            'direct_debit': (DirectDebitParameters, none_type),  # noqa: E501\n            'ewallet': (EWalletParameters, none_type),  # noqa: E501\n            'over_the_counter': (OverTheCounterParameters, none_type),  # noqa: E501\n            'virtual_account': (VirtualAccountParameters, none_type),  # noqa: E501\n            'qr_code': (QRCodeParameters, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n            'billing_information': (BillingInformation, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'type': 'type',  # noqa: E501\n        'reusability': 'reusability',  # noqa: E501\n        'country': 'country',  # noqa: E501\n        'customer_id': 'customer_id',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'card': 'card',  # noqa: E501\n        'direct_debit': 'direct_debit',  # noqa: E501\n        'ewallet': 'ewallet',  # noqa: E501\n        'over_the_counter': 'over_the_counter',  # noqa: E501\n        'virtual_account': 'virtual_account',  # noqa: E501\n        'qr_code': 'qr_code',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n        'billing_information': 'billing_information',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, type, reusability, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentMethodParameters - a model defined in OpenAPI\n\n        Args:\n            type (PaymentMethodType):\n            reusability (PaymentMethodReusability):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            country (str, none_type): [optional]  # noqa: E501\n            customer_id (str, none_type): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            card (CardParameters): [optional]  # noqa: E501\n            direct_debit (DirectDebitParameters): [optional]  # noqa: E501\n            ewallet (EWalletParameters): [optional]  # noqa: E501\n            over_the_counter (OverTheCounterParameters): [optional]  # noqa: E501\n            virtual_account (VirtualAccountParameters): [optional]  # noqa: E501\n            qr_code (QRCodeParameters): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            billing_information (BillingInformation): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        self.reusability = reusability\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        type: PaymentMethodType,\n        reusability: PaymentMethodReusability,\n        country: str | None = None,\n        customer_id: str | None = None,\n        reference_id: str | None = None,\n        description: str | None = None,\n        card: CardParameters | None = None,\n        direct_debit: DirectDebitParameters | None = None,\n        ewallet: EWalletParameters | None = None,\n        over_the_counter: OverTheCounterParameters | None = None,\n        virtual_account: VirtualAccountParameters | None = None,\n        qr_code: QRCodeParameters | None = None,\n        metadata: dict | None = None,\n        billing_information: BillingInformation | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentMethodParameters - a model defined in OpenAPI\n\n        Args:\n            type (PaymentMethodType):\n            reusability (PaymentMethodReusability):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            country (str, none_type): [optional]  # noqa: E501\n            customer_id (str, none_type): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            card (CardParameters): [optional]  # noqa: E501\n            direct_debit (DirectDebitParameters): [optional]  # noqa: E501\n            ewallet (EWalletParameters): [optional]  # noqa: E501\n            over_the_counter (OverTheCounterParameters): [optional]  # noqa: E501\n            virtual_account (VirtualAccountParameters): [optional]  # noqa: E501\n            qr_code (QRCodeParameters): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            billing_information (BillingInformation): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        self.reusability = reusability\n        if country is not None:\n            self.country = country\n        if customer_id is not None:\n            self.customer_id = customer_id\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if description is not None:\n            self.description = description\n        if card is not None:\n            self.card = card\n        if direct_debit is not None:\n            self.direct_debit = direct_debit\n        if ewallet is not None:\n            self.ewallet = ewallet\n        if over_the_counter is not None:\n            self.over_the_counter = over_the_counter\n        if virtual_account is not None:\n            self.virtual_account = virtual_account\n        if qr_code is not None:\n            self.qr_code = qr_code\n        if metadata is not None:\n            self.metadata = metadata\n        if billing_information is not None:\n            self.billing_information = billing_information\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      85,
      86,
      208,
      209,
      210,
      211,
      212,
      214,
      238,
      321,
      322,
      323,
      324,
      325,
      327,
      328,
      329,
      330,
      331,
      332,
      334,
      343,
      344,
      345,
      346,
      347,
      348,
      350,
      351,
      352,
      353,
      354,
      355,
      356,
      357,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      368,
      369,
      370,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      382,
      383,
      384,
      385
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method_reusability.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodReusability(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'MULTIPLE_USE': \"MULTIPLE_USE\",\n            'ONE_TIME_USE': \"ONE_TIME_USE\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentMethodReusability - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"MULTIPLE_USE\", \"ONE_TIME_USE\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"MULTIPLE_USE\", \"ONE_TIME_USE\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentMethodReusability - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"MULTIPLE_USE\", \"ONE_TIME_USE\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"MULTIPLE_USE\", \"ONE_TIME_USE\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      143,
      145,
      146,
      147,
      148,
      149,
      151,
      157,
      158,
      159,
      160,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      244,
      249,
      261,
      262,
      263,
      264,
      265,
      267,
      284,
      285,
      287
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method_status.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodStatus(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'ACTIVE': \"ACTIVE\",\n            'EXPIRED': \"EXPIRED\",\n            'INACTIVE': \"INACTIVE\",\n            'PENDING': \"PENDING\",\n            'REQUIRES_ACTION': \"REQUIRES_ACTION\",\n            'FAILED': \"FAILED\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentMethodStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"ACTIVE\", \"EXPIRED\", \"INACTIVE\", \"PENDING\", \"REQUIRES_ACTION\", \"FAILED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"ACTIVE\", \"EXPIRED\", \"INACTIVE\", \"PENDING\", \"REQUIRES_ACTION\", \"FAILED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentMethodStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"ACTIVE\", \"EXPIRED\", \"INACTIVE\", \"PENDING\", \"REQUIRES_ACTION\", \"FAILED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"ACTIVE\", \"EXPIRED\", \"INACTIVE\", \"PENDING\", \"REQUIRES_ACTION\", \"FAILED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      80,
      86,
      147,
      149,
      150,
      151,
      152,
      153,
      155,
      161,
      162,
      163,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      243,
      245,
      247,
      248,
      249,
      250,
      251,
      253,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      271,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      300
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'CARD': \"CARD\",\n            'CRYPTOCURRENCY': \"CRYPTOCURRENCY\",\n            'DIRECT_BANK_TRANSFER': \"DIRECT_BANK_TRANSFER\",\n            'DIRECT_DEBIT': \"DIRECT_DEBIT\",\n            'EWALLET': \"EWALLET\",\n            'OVER_THE_COUNTER': \"OVER_THE_COUNTER\",\n            'QR_CODE': \"QR_CODE\",\n            'VIRTUAL_ACCOUNT': \"VIRTUAL_ACCOUNT\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentMethodType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"CARD\", \"CRYPTOCURRENCY\", \"DIRECT_BANK_TRANSFER\", \"DIRECT_DEBIT\", \"EWALLET\", \"OVER_THE_COUNTER\", \"QR_CODE\", \"VIRTUAL_ACCOUNT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"CARD\", \"CRYPTOCURRENCY\", \"DIRECT_BANK_TRANSFER\", \"DIRECT_DEBIT\", \"EWALLET\", \"OVER_THE_COUNTER\", \"QR_CODE\", \"VIRTUAL_ACCOUNT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentMethodType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"CARD\", \"CRYPTOCURRENCY\", \"DIRECT_BANK_TRANSFER\", \"DIRECT_DEBIT\", \"EWALLET\", \"OVER_THE_COUNTER\", \"QR_CODE\", \"VIRTUAL_ACCOUNT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"CARD\", \"CRYPTOCURRENCY\", \"DIRECT_BANK_TRANSFER\", \"DIRECT_DEBIT\", \"EWALLET\", \"OVER_THE_COUNTER\", \"QR_CODE\", \"VIRTUAL_ACCOUNT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      149,
      151,
      152,
      153,
      154,
      155,
      157,
      163,
      164,
      165,
      166,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      250,
      255,
      267,
      268,
      269,
      270,
      271,
      273,
      290,
      291,
      293
    ]
  },
  {
    "file_path": "xendit/payment_method/model/payment_method_update_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.over_the_counter_update_parameters import OverTheCounterUpdateParameters\nfrom xendit.payment_method.model.payment_method_reusability import PaymentMethodReusability\nfrom xendit.payment_method.model.payment_method_status import PaymentMethodStatus\nfrom xendit.payment_method.model.virtual_account_update_parameters import VirtualAccountUpdateParameters\nglobals()['OverTheCounterUpdateParameters'] = OverTheCounterUpdateParameters\nglobals()['PaymentMethodReusability'] = PaymentMethodReusability\nglobals()['PaymentMethodStatus'] = PaymentMethodStatus\nglobals()['VirtualAccountUpdateParameters'] = VirtualAccountUpdateParameters\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodUpdateParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('reference_id',): {\n            'max_length': 255,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'description': (str, none_type),  # noqa: E501\n            'reference_id': (str, none_type),  # noqa: E501\n            'reusability': (PaymentMethodReusability, none_type),  # noqa: E501\n            'status': (PaymentMethodStatus, none_type),  # noqa: E501\n            'over_the_counter': (OverTheCounterUpdateParameters, none_type),  # noqa: E501\n            'virtual_account': (VirtualAccountUpdateParameters, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'description': 'description',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'reusability': 'reusability',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'over_the_counter': 'over_the_counter',  # noqa: E501\n        'virtual_account': 'virtual_account',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentMethodUpdateParameters - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            description (str): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            reusability (PaymentMethodReusability): [optional]  # noqa: E501\n            status (PaymentMethodStatus): [optional]  # noqa: E501\n            over_the_counter (OverTheCounterUpdateParameters): [optional]  # noqa: E501\n            virtual_account (VirtualAccountUpdateParameters): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        description: str | None = None,\n        reference_id: str | None = None,\n        reusability: PaymentMethodReusability | None = None,\n        status: PaymentMethodStatus | None = None,\n        over_the_counter: OverTheCounterUpdateParameters | None = None,\n        virtual_account: VirtualAccountUpdateParameters | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentMethodUpdateParameters - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            description (str): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            reusability (PaymentMethodReusability): [optional]  # noqa: E501\n            status (PaymentMethodStatus): [optional]  # noqa: E501\n            over_the_counter (OverTheCounterUpdateParameters): [optional]  # noqa: E501\n            virtual_account (VirtualAccountUpdateParameters): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if description is not None:\n            self.description = description\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if reusability is not None:\n            self.reusability = reusability\n        if status is not None:\n            self.status = status\n        if over_the_counter is not None:\n            self.over_the_counter = over_the_counter\n        if virtual_account is not None:\n            self.virtual_account = virtual_account\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      78,
      79,
      93,
      94,
      105,
      166,
      167,
      168,
      169,
      170,
      172,
      174,
      175,
      176,
      177,
      178,
      179,
      181,
      190,
      191,
      192,
      193,
      194,
      195,
      197,
      198,
      203,
      204,
      205,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      281,
      290,
      291,
      292,
      293,
      294,
      295,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      305,
      306,
      307,
      308,
      309,
      310,
      315,
      316,
      317,
      318
    ]
  },
  {
    "file_path": "xendit/payment_method/model/qr_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.qr_code_channel_code import QRCodeChannelCode\nfrom xendit.payment_method.model.qr_code_channel_properties import QRCodeChannelProperties\nfrom xendit.payment_method.model.qr_code_parameters import QRCodeParameters\nglobals()['QRCodeChannelCode'] = QRCodeChannelCode\nglobals()['QRCodeChannelProperties'] = QRCodeChannelProperties\nglobals()['QRCodeParameters'] = QRCodeParameters\n\ndef lazy_import():\n    pass\n\nclass QRCode(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'currency': (str, none_type),  # noqa: E501\n            'channel_code': (QRCodeChannelCode, none_type),  # noqa: E501\n            'channel_properties': (QRCodeChannelProperties, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"QRCode - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            channel_code (QRCodeChannelCode): [optional]  # noqa: E501\n            channel_properties (QRCodeChannelProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"QRCode - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            channel_code (QRCodeChannelCode): [optional]  # noqa: E501\n            channel_properties (QRCodeChannelProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              QRCodeParameters,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      73,
      74,
      88,
      89,
      98,
      153,
      154,
      155,
      156,
      157,
      159,
      161,
      162,
      163,
      164,
      165,
      166,
      168,
      177,
      178,
      179,
      180,
      181,
      182,
      184,
      191,
      193,
      194,
      195,
      196,
      198,
      199,
      204,
      205,
      207,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      275,
      284,
      285,
      286,
      287,
      288,
      289,
      291,
      298,
      300,
      301,
      302,
      303,
      305,
      306,
      311,
      312,
      313,
      314,
      326,
      327
    ]
  },
  {
    "file_path": "xendit/payment_method/model/qr_code_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass QRCodeChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'None': None,\n            'QRIS': \"QRIS\",\n            'DANA': \"DANA\",\n            'RCBC': \"RCBC\",\n            'PROMPTPAY': \"PROMPTPAY\",\n            'LINKAJA': \"LINKAJA\",\n            'XENDIT': \"XENDIT\",\n            'QRPH': \"QRPH\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"QRCodeChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): QR Code Channel Code., must be one of [\"QRIS\", \"DANA\", \"RCBC\", \"PROMPTPAY\", \"LINKAJA\", \"XENDIT\", \"QRPH\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): QR Code Channel Code., must be one of [\"QRIS\", \"DANA\", \"RCBC\", \"PROMPTPAY\", \"LINKAJA\", \"XENDIT\", \"QRPH\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"QRCodeChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): QR Code Channel Code., must be one of [\"QRIS\", \"DANA\", \"RCBC\", \"PROMPTPAY\", \"LINKAJA\", \"XENDIT\", \"QRPH\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): QR Code Channel Code., must be one of [\"QRIS\", \"DANA\", \"RCBC\", \"PROMPTPAY\", \"LINKAJA\", \"XENDIT\", \"QRPH\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      82,
      88,
      149,
      151,
      152,
      153,
      154,
      155,
      157,
      163,
      164,
      165,
      166,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      245,
      247,
      249,
      250,
      251,
      252,
      253,
      255,
      261,
      262,
      263,
      264,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      302
    ]
  },
  {
    "file_path": "xendit/payment_method/model/qr_code_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass QRCodeChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'qr_string': (str, none_type),  # noqa: E501\n            'expires_at': (datetime, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'qr_string': 'qr_string',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"QRCodeChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            qr_string (str): QR string to be rendered for display to end users. QR string to image rendering are commonly available in software libraries (e.g Nodejs, PHP, Java). [optional]  # noqa: E501\n            expires_at (datetime): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        qr_string: str | None = None,\n        expires_at: datetime | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"QRCodeChannelProperties - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            qr_string (str): QR string to be rendered for display to end users. QR string to image rendering are commonly available in software libraries (e.g Nodejs, PHP, Java). [optional]  # noqa: E501\n            expires_at (datetime): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if qr_string is not None:\n            self.qr_string = qr_string\n        if expires_at is not None:\n            self.expires_at = expires_at\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/payment_method/model/qr_code_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.qr_code_channel_code import QRCodeChannelCode\nfrom xendit.payment_method.model.qr_code_channel_properties import QRCodeChannelProperties\nglobals()['QRCodeChannelCode'] = QRCodeChannelCode\nglobals()['QRCodeChannelProperties'] = QRCodeChannelProperties\n\ndef lazy_import():\n    pass\n\nclass QRCodeParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'currency': (str, none_type),  # noqa: E501\n            'channel_code': (QRCodeChannelCode, none_type),  # noqa: E501\n            'channel_properties': (QRCodeChannelProperties, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"QRCodeParameters - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            channel_code (QRCodeChannelCode): [optional]  # noqa: E501\n            channel_properties (QRCodeChannelProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        amount: float | None = None,\n        currency: str | None = None,\n        channel_code: QRCodeChannelCode | None = None,\n        channel_properties: QRCodeChannelProperties | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"QRCodeParameters - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            channel_code (QRCodeChannelCode): [optional]  # noqa: E501\n            channel_properties (QRCodeChannelProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if amount is not None:\n            self.amount = amount\n        if currency is not None:\n            self.currency = currency\n        if channel_code is not None:\n            self.channel_code = channel_code\n        if channel_properties is not None:\n            self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      86,
      87,
      96,
      153,
      154,
      155,
      156,
      157,
      159,
      161,
      162,
      163,
      164,
      165,
      166,
      168,
      177,
      178,
      179,
      180,
      181,
      182,
      184,
      185,
      190,
      191,
      192,
      251,
      252,
      253,
      254,
      255,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      273,
      274,
      275,
      276,
      277,
      278,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      294,
      295,
      296,
      297
    ]
  },
  {
    "file_path": "xendit/payment_method/model/simulate_payment_request.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass SimulatePaymentRequest(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'amount': (float, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'amount': 'amount',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"SimulatePaymentRequest - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        amount: float | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"SimulatePaymentRequest - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if amount is not None:\n            self.amount = amount\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      87,
      138,
      139,
      140,
      141,
      142,
      144,
      146,
      147,
      148,
      149,
      150,
      151,
      153,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      170,
      175,
      176,
      177,
      230,
      231,
      232,
      233,
      234,
      236,
      237,
      238,
      239,
      240,
      241,
      243,
      252,
      253,
      254,
      255,
      256,
      257,
      259,
      260,
      261,
      262,
      267,
      268,
      269,
      270
    ]
  },
  {
    "file_path": "xendit/payment_method/model/tokenized_card_information.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass TokenizedCardInformation(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'token_id': (str, none_type),  # noqa: E501\n            'masked_card_number': (str, none_type),  # noqa: E501\n            'cardholder_name': (str, none_type, none_type),  # noqa: E501\n            'expiry_month': (str, none_type),  # noqa: E501\n            'expiry_year': (str, none_type),  # noqa: E501\n            'fingerprint': (str, none_type),  # noqa: E501\n            'type': (str, none_type),  # noqa: E501\n            'network': (str, none_type),  # noqa: E501\n            'country': (str, none_type),  # noqa: E501\n            'issuer': (str, none_type),  # noqa: E501\n            'card_number': (str, none_type),  # noqa: E501\n            'one_time_token': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'token_id': 'token_id',  # noqa: E501\n        'masked_card_number': 'masked_card_number',  # noqa: E501\n        'cardholder_name': 'cardholder_name',  # noqa: E501\n        'expiry_month': 'expiry_month',  # noqa: E501\n        'expiry_year': 'expiry_year',  # noqa: E501\n        'fingerprint': 'fingerprint',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'network': 'network',  # noqa: E501\n        'country': 'country',  # noqa: E501\n        'issuer': 'issuer',  # noqa: E501\n        'card_number': 'card_number',  # noqa: E501\n        'one_time_token': 'one_time_token',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"TokenizedCardInformation - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            token_id (str): [optional]  # noqa: E501\n            masked_card_number (str): 1st 6 and last 4 digits of the card. [optional]  # noqa: E501\n            cardholder_name (str, none_type): Cardholder name is optional but recommended for 3DS 2 / AVS verification. [optional]  # noqa: E501\n            expiry_month (str): Card expiry month in MM format. [optional]  # noqa: E501\n            expiry_year (str): Card expiry month in YY format. [optional]  # noqa: E501\n            fingerprint (str): Xendit-generated identifier for the unique card number. Multiple payment method objects can be created for the same account - e.g. if the user first creates a one-time payment request, and then later on creates a multiple-use payment method using the same account.   The fingerprint helps to identify the unique account being used.. [optional]  # noqa: E501\n            type (str): Whether the card is a credit or debit card. [optional]  # noqa: E501\n            network (str): Card network - VISA, MASTERCARD, JCB, AMEX, DISCOVER, BCA. [optional]  # noqa: E501\n            country (str): Country where the card was issued ISO 3166-1 Alpha-2. [optional]  # noqa: E501\n            issuer (str): Issuer of the card, most often an issuing bank For example, BCA, MANDIRI. [optional]  # noqa: E501\n            card_number (str): [optional]  # noqa: E501\n            one_time_token (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        token_id: str | None = None,\n        masked_card_number: str | None = None,\n        cardholder_name: str | None = None,\n        expiry_month: str | None = None,\n        expiry_year: str | None = None,\n        fingerprint: str | None = None,\n        type: str | None = None,\n        network: str | None = None,\n        country: str | None = None,\n        issuer: str | None = None,\n        card_number: str | None = None,\n        one_time_token: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"TokenizedCardInformation - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            token_id (str): [optional]  # noqa: E501\n            masked_card_number (str): 1st 6 and last 4 digits of the card. [optional]  # noqa: E501\n            cardholder_name (str, none_type): Cardholder name is optional but recommended for 3DS 2 / AVS verification. [optional]  # noqa: E501\n            expiry_month (str): Card expiry month in MM format. [optional]  # noqa: E501\n            expiry_year (str): Card expiry month in YY format. [optional]  # noqa: E501\n            fingerprint (str): Xendit-generated identifier for the unique card number. Multiple payment method objects can be created for the same account - e.g. if the user first creates a one-time payment request, and then later on creates a multiple-use payment method using the same account.   The fingerprint helps to identify the unique account being used.. [optional]  # noqa: E501\n            type (str): Whether the card is a credit or debit card. [optional]  # noqa: E501\n            network (str): Card network - VISA, MASTERCARD, JCB, AMEX, DISCOVER, BCA. [optional]  # noqa: E501\n            country (str): Country where the card was issued ISO 3166-1 Alpha-2. [optional]  # noqa: E501\n            issuer (str): Issuer of the card, most often an issuing bank For example, BCA, MANDIRI. [optional]  # noqa: E501\n            card_number (str): [optional]  # noqa: E501\n            one_time_token (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if token_id is not None:\n            self.token_id = token_id\n        if masked_card_number is not None:\n            self.masked_card_number = masked_card_number\n        if cardholder_name is not None:\n            self.cardholder_name = cardholder_name\n        if expiry_month is not None:\n            self.expiry_month = expiry_month\n        if expiry_year is not None:\n            self.expiry_year = expiry_year\n        if fingerprint is not None:\n            self.fingerprint = fingerprint\n        if type is not None:\n            self.type = type\n        if network is not None:\n            self.network = network\n        if country is not None:\n            self.country = country\n        if issuer is not None:\n            self.issuer = issuer\n        if card_number is not None:\n            self.card_number = card_number\n        if one_time_token is not None:\n            self.one_time_token = one_time_token\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      98,
      171,
      172,
      173,
      174,
      175,
      177,
      179,
      180,
      181,
      182,
      183,
      184,
      186,
      195,
      196,
      197,
      198,
      199,
      200,
      202,
      203,
      208,
      209,
      210,
      285,
      286,
      287,
      288,
      289,
      291,
      292,
      293,
      294,
      295,
      296,
      298,
      307,
      308,
      309,
      310,
      311,
      312,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      322,
      323,
      324,
      325,
      326,
      327,
      328,
      329,
      330,
      331,
      332,
      333,
      334,
      335,
      336,
      337,
      338,
      339,
      344,
      345,
      346,
      347
    ]
  },
  {
    "file_path": "xendit/payment_method/model/virtual_account.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.virtual_account_all_of import VirtualAccountAllOf\nfrom xendit.payment_method.model.virtual_account_alternative_display import VirtualAccountAlternativeDisplay\nfrom xendit.payment_method.model.virtual_account_channel_code import VirtualAccountChannelCode\nfrom xendit.payment_method.model.virtual_account_channel_properties import VirtualAccountChannelProperties\nfrom xendit.payment_method.model.virtual_account_parameters import VirtualAccountParameters\nglobals()['VirtualAccountAllOf'] = VirtualAccountAllOf\nglobals()['VirtualAccountAlternativeDisplay'] = VirtualAccountAlternativeDisplay\nglobals()['VirtualAccountChannelCode'] = VirtualAccountChannelCode\nglobals()['VirtualAccountChannelProperties'] = VirtualAccountChannelProperties\nglobals()['VirtualAccountParameters'] = VirtualAccountParameters\n\ndef lazy_import():\n    pass\n\nclass VirtualAccount(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('alternative_display_types',): {\n            'QR_STRING': \"QR_STRING\",\n        },\n    }\n\n    validations = {\n        ('min_amount',): {\n            'inclusive_minimum': 1,\n        },\n        ('max_amount',): {\n            'inclusive_minimum': 1,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (VirtualAccountChannelCode,),  # noqa: E501\n            'channel_properties': (VirtualAccountChannelProperties,),  # noqa: E501\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'min_amount': (float, none_type, none_type),  # noqa: E501\n            'max_amount': (float, none_type, none_type),  # noqa: E501\n            'currency': (str, none_type),  # noqa: E501\n            'alternative_display_types': ([str], none_type),  # noqa: E501\n            'alternative_displays': ([VirtualAccountAlternativeDisplay], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'min_amount': 'min_amount',  # noqa: E501\n        'max_amount': 'max_amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'alternative_display_types': 'alternative_display_types',  # noqa: E501\n        'alternative_displays': 'alternative_displays',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccount - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (VirtualAccountChannelCode):\n            channel_properties (VirtualAccountChannelProperties):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            alternative_display_types ([str]): For payments in Vietnam only, alternative display requested for the virtual account. [optional]  # noqa: E501\n            alternative_displays ([VirtualAccountAlternativeDisplay]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccount - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (VirtualAccountChannelCode):\n            channel_properties (VirtualAccountChannelProperties):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            alternative_display_types ([str]): For payments in Vietnam only, alternative display requested for the virtual account. [optional]  # noqa: E501\n            alternative_displays ([VirtualAccountAlternativeDisplay]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              VirtualAccountAllOf,\n              VirtualAccountParameters,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      86,
      87,
      101,
      102,
      115,
      178,
      179,
      180,
      181,
      182,
      184,
      186,
      187,
      188,
      189,
      190,
      191,
      193,
      202,
      203,
      204,
      205,
      206,
      207,
      209,
      216,
      218,
      219,
      220,
      221,
      223,
      224,
      229,
      230,
      232,
      291,
      292,
      293,
      294,
      295,
      297,
      298,
      299,
      300,
      301,
      302,
      304,
      313,
      314,
      315,
      316,
      317,
      318,
      320,
      327,
      329,
      330,
      331,
      332,
      334,
      335,
      340,
      341,
      342,
      343,
      355,
      356
    ]
  },
  {
    "file_path": "xendit/payment_method/model/virtual_account_all_of.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.virtual_account_alternative_display import VirtualAccountAlternativeDisplay\nglobals()['VirtualAccountAlternativeDisplay'] = VirtualAccountAlternativeDisplay\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountAllOf(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'alternative_displays': ([VirtualAccountAlternativeDisplay], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'alternative_displays': 'alternative_displays',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccountAllOf - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            alternative_displays ([VirtualAccountAlternativeDisplay]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        alternative_displays: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"VirtualAccountAllOf - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            alternative_displays ([VirtualAccountAlternativeDisplay]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if alternative_displays is not None:\n            self.alternative_displays = alternative_displays\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      91,
      142,
      143,
      144,
      145,
      146,
      148,
      150,
      151,
      152,
      153,
      154,
      155,
      157,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      174,
      179,
      180,
      181,
      234,
      235,
      236,
      237,
      238,
      240,
      241,
      242,
      243,
      244,
      245,
      247,
      256,
      257,
      258,
      259,
      260,
      261,
      263,
      264,
      265,
      266,
      271,
      272,
      273,
      274
    ]
  },
  {
    "file_path": "xendit/payment_method/model/virtual_account_alternative_display.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountAlternativeDisplay(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('type',): {\n            'QR_STRING': \"QR_STRING\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'type': (str, none_type),  # noqa: E501\n            'data': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'type': 'type',  # noqa: E501\n        'data': 'data',  # noqa: E501\n    }\n\n    read_only_vars = {\n        'type',  # noqa: E501\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccountAlternativeDisplay - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            type (str): Type of the alternative display. [optional] if omitted the server will use the default value of \"QR_STRING\"  # noqa: E501\n            data (str): Data payload of the given alternative display. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        data: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"VirtualAccountAlternativeDisplay - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            type (str): Type of the alternative display. [optional] if omitted the server will use the default value of \"QR_STRING\"  # noqa: E501\n            data (str): Data payload of the given alternative display. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if data is not None:\n            self.data = data\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      91,
      145,
      146,
      147,
      148,
      149,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      160,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      177,
      182,
      183,
      184,
      238,
      239,
      240,
      241,
      242,
      244,
      245,
      246,
      247,
      248,
      249,
      251,
      260,
      261,
      262,
      263,
      264,
      265,
      267,
      268,
      269,
      270,
      275,
      276,
      277,
      278
    ]
  },
  {
    "file_path": "xendit/payment_method/model/virtual_account_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BCA': \"BCA\",\n            'BJB': \"BJB\",\n            'BNI': \"BNI\",\n            'BRI': \"BRI\",\n            'MANDIRI': \"MANDIRI\",\n            'PERMATA': \"PERMATA\",\n            'BSI': \"BSI\",\n            'CIMB': \"CIMB\",\n            'SAHABAT_SAMPOERNA': \"SAHABAT_SAMPOERNA\",\n            'ARTAJASA': \"ARTAJASA\",\n            'PV': \"PV\",\n            'VIETCAPITAL': \"VIETCAPITAL\",\n            'WOORI': \"WOORI\",\n            'MSB': \"MSB\",\n            'VPB': \"VPB\",\n            'BIDV': \"BIDV\",\n            'CAKE': \"CAKE\",\n            'STANDARD_CHARTERED': \"STANDARD_CHARTERED\",\n            'AMBANK': \"AMBANK\",\n            'UOB': \"UOB\",\n            'BNC': \"BNC\",\n            'HANA': \"HANA\",\n            'MUAMALAT': \"MUAMALAT\",\n            'BANK_TRANSFER': \"BANK_TRANSFER\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"VirtualAccountChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Virtual Account Channel Code., must be one of [\"BCA\", \"BJB\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"CIMB\", \"SAHABAT_SAMPOERNA\", \"ARTAJASA\", \"PV\", \"VIETCAPITAL\", \"WOORI\", \"MSB\", \"VPB\", \"BIDV\", \"CAKE\", \"STANDARD_CHARTERED\", \"AMBANK\", \"UOB\", \"BNC\", \"HANA\", \"MUAMALAT\", \"BANK_TRANSFER\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Virtual Account Channel Code., must be one of [\"BCA\", \"BJB\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"CIMB\", \"SAHABAT_SAMPOERNA\", \"ARTAJASA\", \"PV\", \"VIETCAPITAL\", \"WOORI\", \"MSB\", \"VPB\", \"BIDV\", \"CAKE\", \"STANDARD_CHARTERED\", \"AMBANK\", \"UOB\", \"BNC\", \"HANA\", \"MUAMALAT\", \"BANK_TRANSFER\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"VirtualAccountChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Virtual Account Channel Code., must be one of [\"BCA\", \"BJB\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"CIMB\", \"SAHABAT_SAMPOERNA\", \"ARTAJASA\", \"PV\", \"VIETCAPITAL\", \"WOORI\", \"MSB\", \"VPB\", \"BIDV\", \"CAKE\", \"STANDARD_CHARTERED\", \"AMBANK\", \"UOB\", \"BNC\", \"HANA\", \"MUAMALAT\", \"BANK_TRANSFER\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Virtual Account Channel Code., must be one of [\"BCA\", \"BJB\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"CIMB\", \"SAHABAT_SAMPOERNA\", \"ARTAJASA\", \"PV\", \"VIETCAPITAL\", \"WOORI\", \"MSB\", \"VPB\", \"BIDV\", \"CAKE\", \"STANDARD_CHARTERED\", \"AMBANK\", \"UOB\", \"BNC\", \"HANA\", \"MUAMALAT\", \"BANK_TRANSFER\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      98,
      104,
      165,
      167,
      168,
      169,
      170,
      171,
      173,
      179,
      180,
      181,
      182,
      184,
      185,
      186,
      187,
      188,
      189,
      191,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      261,
      263,
      265,
      266,
      267,
      268,
      269,
      271,
      277,
      278,
      279,
      280,
      282,
      283,
      284,
      285,
      286,
      287,
      289,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      305,
      306,
      307,
      308,
      309,
      318
    ]
  },
  {
    "file_path": "xendit/payment_method/model/virtual_account_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'customer_name': (str, none_type),  # noqa: E501\n            'virtual_account_number': (str, none_type),  # noqa: E501\n            'expires_at': (datetime, none_type),  # noqa: E501\n            'suggested_amount': (float, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'customer_name': 'customer_name',  # noqa: E501\n        'virtual_account_number': 'virtual_account_number',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n        'suggested_amount': 'suggested_amount',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccountChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            customer_name (str): Name of customer.. [optional]  # noqa: E501\n            virtual_account_number (str): You can assign specific Virtual Account number using this parameter. If you do not send one, one will be picked at random. Make sure the number you specify is within your Virtual Account range.. [optional]  # noqa: E501\n            expires_at (datetime): The date and time in ISO 8601 UTC+0 when the virtual account number will be expired. Default: The default expiration date will be 31 years from creation date.. [optional]  # noqa: E501\n            suggested_amount (float): The suggested amount you want to assign. Note: Suggested amounts is the amounts that can see as a suggestion, but user can still put any numbers (only supported for Mandiri and BRI). [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        customer_name: str | None = None,\n        virtual_account_number: str | None = None,\n        expires_at: datetime | None = None,\n        suggested_amount: float | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"VirtualAccountChannelProperties - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            customer_name (str): Name of customer.. [optional]  # noqa: E501\n            virtual_account_number (str): You can assign specific Virtual Account number using this parameter. If you do not send one, one will be picked at random. Make sure the number you specify is within your Virtual Account range.. [optional]  # noqa: E501\n            expires_at (datetime): The date and time in ISO 8601 UTC+0 when the virtual account number will be expired. Default: The default expiration date will be 31 years from creation date.. [optional]  # noqa: E501\n            suggested_amount (float): The suggested amount you want to assign. Note: Suggested amounts is the amounts that can see as a suggestion, but user can still put any numbers (only supported for Mandiri and BRI). [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if customer_name is not None:\n            self.customer_name = customer_name\n        if virtual_account_number is not None:\n            self.virtual_account_number = virtual_account_number\n        if expires_at is not None:\n            self.expires_at = expires_at\n        if suggested_amount is not None:\n            self.suggested_amount = suggested_amount\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      90,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      184,
      185,
      186,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      288,
      289,
      290,
      291
    ]
  },
  {
    "file_path": "xendit/payment_method/model/virtual_account_channel_properties_patch.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountChannelPropertiesPatch(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('suggested_amount',): {\n            'inclusive_minimum': 1,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'expires_at': (datetime, none_type),  # noqa: E501\n            'suggested_amount': (float, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'expires_at': 'expires_at',  # noqa: E501\n        'suggested_amount': 'suggested_amount',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccountChannelPropertiesPatch - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            expires_at (datetime): The date and time in ISO 8601 UTC+0 when the virtual account number will be expired. Default: The default expiration date will be 31 years from creation date.. [optional]  # noqa: E501\n            suggested_amount (float): The suggested amount you want to assign. Note: Suggested amounts is the amounts that can see as a suggestion, but user can still put any numbers (only supported for Mandiri and BRI). [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        expires_at: datetime | None = None,\n        suggested_amount: float | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"VirtualAccountChannelPropertiesPatch - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            expires_at (datetime): The date and time in ISO 8601 UTC+0 when the virtual account number will be expired. Default: The default expiration date will be 31 years from creation date.. [optional]  # noqa: E501\n            suggested_amount (float): The suggested amount you want to assign. Note: Suggested amounts is the amounts that can see as a suggestion, but user can still put any numbers (only supported for Mandiri and BRI). [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if expires_at is not None:\n            self.expires_at = expires_at\n        if suggested_amount is not None:\n            self.suggested_amount = suggested_amount\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      91,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      181,
      182,
      183,
      238,
      239,
      240,
      241,
      242,
      244,
      245,
      246,
      247,
      248,
      249,
      251,
      260,
      261,
      262,
      263,
      264,
      265,
      267,
      268,
      269,
      270,
      271,
      272,
      277,
      278,
      279,
      280
    ]
  },
  {
    "file_path": "xendit/payment_method/model/virtual_account_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.virtual_account_channel_code import VirtualAccountChannelCode\nfrom xendit.payment_method.model.virtual_account_channel_properties import VirtualAccountChannelProperties\nglobals()['VirtualAccountChannelCode'] = VirtualAccountChannelCode\nglobals()['VirtualAccountChannelProperties'] = VirtualAccountChannelProperties\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('alternative_display_types',): {\n            'QR_STRING': \"QR_STRING\",\n        },\n    }\n\n    validations = {\n        ('min_amount',): {\n            'inclusive_minimum': 1,\n        },\n        ('max_amount',): {\n            'inclusive_minimum': 1,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (VirtualAccountChannelCode,),  # noqa: E501\n            'channel_properties': (VirtualAccountChannelProperties,),  # noqa: E501\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'min_amount': (float, none_type, none_type),  # noqa: E501\n            'max_amount': (float, none_type, none_type),  # noqa: E501\n            'currency': (str, none_type),  # noqa: E501\n            'alternative_display_types': ([str], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'min_amount': 'min_amount',  # noqa: E501\n        'max_amount': 'max_amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'alternative_display_types': 'alternative_display_types',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, channel_code, channel_properties, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccountParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (VirtualAccountChannelCode):\n            channel_properties (VirtualAccountChannelProperties):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            alternative_display_types ([str]): For payments in Vietnam only, alternative display requested for the virtual account. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_code: VirtualAccountChannelCode,\n        channel_properties: VirtualAccountChannelProperties,\n        amount: float | None = None,\n        min_amount: float | None = None,\n        max_amount: float | None = None,\n        currency: str | None = None,\n        alternative_display_types: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"VirtualAccountParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (VirtualAccountChannelCode):\n            channel_properties (VirtualAccountChannelProperties):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            alternative_display_types ([str]): For payments in Vietnam only, alternative display requested for the virtual account. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        if amount is not None:\n            self.amount = amount\n        if min_amount is not None:\n            self.min_amount = min_amount\n        if max_amount is not None:\n            self.max_amount = max_amount\n        if currency is not None:\n            self.currency = currency\n        if alternative_display_types is not None:\n            self.alternative_display_types = alternative_display_types\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      80,
      81,
      95,
      96,
      108,
      173,
      174,
      175,
      176,
      177,
      179,
      181,
      182,
      183,
      184,
      185,
      186,
      188,
      197,
      198,
      199,
      200,
      201,
      202,
      204,
      205,
      206,
      207,
      212,
      213,
      214,
      281,
      282,
      283,
      284,
      285,
      287,
      288,
      289,
      290,
      291,
      292,
      294,
      303,
      304,
      305,
      306,
      307,
      308,
      310,
      311,
      312,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      322,
      323,
      328,
      329,
      330,
      331
    ]
  },
  {
    "file_path": "xendit/payment_method/model/virtual_account_update_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 2.128.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_method.model.virtual_account_channel_properties_patch import VirtualAccountChannelPropertiesPatch\nglobals()['VirtualAccountChannelPropertiesPatch'] = VirtualAccountChannelPropertiesPatch\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountUpdateParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('alternative_display_types',): {\n            'QR_STRING': \"QR_STRING\",\n        },\n    }\n\n    validations = {\n        ('min_amount',): {\n            'inclusive_minimum': 1,\n        },\n        ('max_amount',): {\n            'inclusive_minimum': 1,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'min_amount': (float, none_type, none_type),  # noqa: E501\n            'max_amount': (float, none_type, none_type),  # noqa: E501\n            'channel_properties': (VirtualAccountChannelPropertiesPatch, none_type),  # noqa: E501\n            'alternative_display_types': ([str], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'amount': 'amount',  # noqa: E501\n        'min_amount': 'min_amount',  # noqa: E501\n        'max_amount': 'max_amount',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'alternative_display_types': 'alternative_display_types',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccountUpdateParameters - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            channel_properties (VirtualAccountChannelPropertiesPatch): [optional]  # noqa: E501\n            alternative_display_types ([str]): For payments in Vietnam only, alternative display requested for the virtual account. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        amount: float | None = None,\n        min_amount: float | None = None,\n        max_amount: float | None = None,\n        channel_properties: VirtualAccountChannelPropertiesPatch | None = None,\n        alternative_display_types: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"VirtualAccountUpdateParameters - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            channel_properties (VirtualAccountChannelPropertiesPatch): [optional]  # noqa: E501\n            alternative_display_types ([str]): For payments in Vietnam only, alternative display requested for the virtual account. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if amount is not None:\n            self.amount = amount\n        if min_amount is not None:\n            self.min_amount = min_amount\n        if max_amount is not None:\n            self.max_amount = max_amount\n        if channel_properties is not None:\n            self.channel_properties = channel_properties\n        if alternative_display_types is not None:\n            self.alternative_display_types = alternative_display_types\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      78,
      79,
      93,
      94,
      104,
      163,
      164,
      165,
      166,
      167,
      169,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      187,
      188,
      189,
      190,
      191,
      192,
      194,
      195,
      200,
      201,
      202,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      276,
      285,
      286,
      287,
      288,
      289,
      290,
      292,
      293,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      308,
      309,
      310,
      311
    ]
  },
  {
    "file_path": "xendit/payment_request/payment_request_api.py",
    "code": "\"\"\"\n    Payment Requests\n\n    This API is used for Payment Requests  # noqa: E501\n\n    The version of the OpenAPI document: 1.70.0\n\"\"\"\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\n\nfrom xendit.api_client import ApiClient, Endpoint as _Endpoint\nfrom xendit.model_utils import (  # noqa: F401\n    check_allowed_values,\n    check_validations,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_and_convert_types\n)\nfrom typing import Optional, List # noqa: F401\n\nfrom xendit.payment_request.model import *  # noqa: F401,E501\n\nclass PaymentRequestApi(object):\n    \"\"\"NOTE: This class is auto generated by the OpenAPI Generator.\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None):\n        if api_client is None:\n            api_client = ApiClient()\n        self.api_client = api_client\n        self.create_payment_request_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentRequest,),\n                'auth': [],\n                'endpoint_path': '/payment_requests',\n                'operation_id': 'create_payment_request',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'idempotency_key',\n                    'for_user_id',\n                    'with_split_rule',\n                    'payment_request_parameters',\n                ],\n                'required': [],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'idempotency_key':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'with_split_rule':\n                        (str,),\n                    'payment_request_parameters':\n                        (PaymentRequestParameters,),\n                },\n                'attribute_map': {\n                    'idempotency_key': 'idempotency-key',\n                    'for_user_id': 'for-user-id',\n                    'with_split_rule': 'with-split-rule',\n                },\n                'location_map': {\n                    'idempotency_key': 'header',\n                    'for_user_id': 'header',\n                    'with_split_rule': 'header',\n                    'payment_request_parameters': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n        self.get_payment_request_by_id_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentRequest,),\n                'auth': [],\n                'endpoint_path': '/payment_requests/{paymentRequestId}',\n                'operation_id': 'get_payment_request_by_id',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_request_id',\n                    'for_user_id',\n                ],\n                'required': [\n                    'payment_request_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_request_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'payment_request_id': 'paymentRequestId',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'payment_request_id': 'path',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.get_payment_request_captures_endpoint = _Endpoint(\n            settings={\n                'response_type': (CaptureListResponse,),\n                'auth': [],\n                'endpoint_path': '/payment_requests/{paymentRequestId}/captures',\n                'operation_id': 'get_payment_request_captures',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_request_id',\n                    'for_user_id',\n                    'limit',\n                ],\n                'required': [\n                    'payment_request_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_request_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'limit':\n                        (int,),\n                },\n                'attribute_map': {\n                    'payment_request_id': 'paymentRequestId',\n                    'for_user_id': 'for-user-id',\n                    'limit': 'limit',\n                },\n                'location_map': {\n                    'payment_request_id': 'path',\n                    'for_user_id': 'header',\n                    'limit': 'query',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.get_all_payment_requests_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentRequestListResponse,),\n                'auth': [],\n                'endpoint_path': '/payment_requests',\n                'operation_id': 'get_all_payment_requests',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'for_user_id',\n                    'reference_id',\n                    'id',\n                    'customer_id',\n                    'limit',\n                    'before_id',\n                    'after_id',\n                ],\n                'required': [],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'for_user_id':\n                        (str,),\n                    'reference_id':\n                        ([str],),\n                    'id':\n                        ([str],),\n                    'customer_id':\n                        ([str],),\n                    'limit':\n                        (int,),\n                    'before_id':\n                        (str,),\n                    'after_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'for_user_id': 'for-user-id',\n                    'reference_id': 'reference_id',\n                    'id': 'id',\n                    'customer_id': 'customer_id',\n                    'limit': 'limit',\n                    'before_id': 'before_id',\n                    'after_id': 'after_id',\n                },\n                'location_map': {\n                    'for_user_id': 'header',\n                    'reference_id': 'query',\n                    'id': 'query',\n                    'customer_id': 'query',\n                    'limit': 'query',\n                    'before_id': 'query',\n                    'after_id': 'query',\n                },\n                'collection_format_map': {\n                    'reference_id': 'multi',\n                    'id': 'multi',\n                    'customer_id': 'multi',\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.capture_payment_request_endpoint = _Endpoint(\n            settings={\n                'response_type': (Capture,),\n                'auth': [],\n                'endpoint_path': '/payment_requests/{paymentRequestId}/captures',\n                'operation_id': 'capture_payment_request',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_request_id',\n                    'for_user_id',\n                    'capture_parameters',\n                ],\n                'required': [\n                    'payment_request_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_request_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'capture_parameters':\n                        (CaptureParameters,),\n                },\n                'attribute_map': {\n                    'payment_request_id': 'paymentRequestId',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'payment_request_id': 'path',\n                    'for_user_id': 'header',\n                    'capture_parameters': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n        self.authorize_payment_request_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentRequest,),\n                'auth': [],\n                'endpoint_path': '/payment_requests/{paymentRequestId}/auth',\n                'operation_id': 'authorize_payment_request',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_request_id',\n                    'for_user_id',\n                    'payment_request_auth_parameters',\n                ],\n                'required': [\n                    'payment_request_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_request_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'payment_request_auth_parameters':\n                        (PaymentRequestAuthParameters,),\n                },\n                'attribute_map': {\n                    'payment_request_id': 'paymentRequestId',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'payment_request_id': 'path',\n                    'for_user_id': 'header',\n                    'payment_request_auth_parameters': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n        self.resend_payment_request_auth_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentRequest,),\n                'auth': [],\n                'endpoint_path': '/payment_requests/{paymentRequestId}/auth/resend',\n                'operation_id': 'resend_payment_request_auth',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_request_id',\n                    'for_user_id',\n                ],\n                'required': [\n                    'payment_request_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_request_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'payment_request_id': 'paymentRequestId',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'payment_request_id': 'path',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.simulate_payment_request_payment_endpoint = _Endpoint(\n            settings={\n                'response_type': (PaymentSimulation,),\n                'auth': [],\n                'endpoint_path': '/payment_requests/{paymentRequestId}/payments/simulate',\n                'operation_id': 'simulate_payment_request_payment',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'payment_request_id',\n                ],\n                'required': [\n                    'payment_request_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'payment_request_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'payment_request_id': 'paymentRequestId',\n                },\n                'location_map': {\n                    'payment_request_id': 'path',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n\n    def create_payment_request(\n        self,\n        idempotency_key: Optional[str] = None,\n        for_user_id: Optional[str] = None,\n        with_split_rule: Optional[str] = None,\n        payment_request_parameters: Optional[PaymentRequestParameters] = None,\n        **kwargs\n    ) -> PaymentRequest:\n        \"\"\"Create Payment Request  # noqa: E501\n\n        Create Payment Request  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.create_payment_request(idempotency_key, for_user_id, with_split_rule, payment_request_parameters, async_req=True)\n        >>> result = thread.get()\n\n\n        Keyword Args:\n            idempotency_key (str): [optional]\n            for_user_id (str): [optional]\n            with_split_rule (str): [optional]\n            payment_request_parameters (PaymentRequestParameters): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentRequest\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        if idempotency_key is not None:\n            kwargs['idempotency_key'] = idempotency_key\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if with_split_rule is not None:\n            kwargs['with_split_rule'] = with_split_rule\n        if payment_request_parameters is not None:\n            kwargs['payment_request_parameters'] = payment_request_parameters\n        return self.create_payment_request_endpoint.call_with_http_info(**kwargs)\n\n    def get_payment_request_by_id(\n        self,\n        payment_request_id: str,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> PaymentRequest:\n        \"\"\"Get payment request by ID  # noqa: E501\n\n        Get payment request by ID  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_payment_request_by_id(payment_request_id, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_request_id (str):\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentRequest\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_request_id'] = payment_request_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.get_payment_request_by_id_endpoint.call_with_http_info(**kwargs)\n\n    def get_payment_request_captures(\n        self,\n        payment_request_id: str,\n        for_user_id: Optional[str] = None,\n        limit: Optional[int] = None,\n        **kwargs\n    ) -> CaptureListResponse:\n        \"\"\"Get Payment Request Capture  # noqa: E501\n\n        Get Payment Request Capture  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_payment_request_captures(payment_request_id, for_user_id, limit, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_request_id (str):\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            limit (int): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            CaptureListResponse\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_request_id'] = payment_request_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if limit is not None:\n            kwargs['limit'] = limit\n        return self.get_payment_request_captures_endpoint.call_with_http_info(**kwargs)\n\n    def get_all_payment_requests(\n        self,\n        for_user_id: Optional[str] = None,\n        reference_id: Optional[List[str]] = None,\n        id: Optional[List[str]] = None,\n        customer_id: Optional[List[str]] = None,\n        limit: Optional[int] = None,\n        before_id: Optional[str] = None,\n        after_id: Optional[str] = None,\n        **kwargs\n    ) -> PaymentRequestListResponse:\n        \"\"\"Get all payment requests by filter  # noqa: E501\n\n        Get all payment requests by filter  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_all_payment_requests(for_user_id, reference_id, id, customer_id, limit, before_id, after_id, async_req=True)\n        >>> result = thread.get()\n\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            reference_id ([str]): [optional]\n            id ([str]): [optional]\n            customer_id ([str]): [optional]\n            limit (int): [optional]\n            before_id (str): [optional]\n            after_id (str): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentRequestListResponse\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if reference_id is not None:\n            kwargs['reference_id'] = reference_id\n        if id is not None:\n            kwargs['id'] = id\n        if customer_id is not None:\n            kwargs['customer_id'] = customer_id\n        if limit is not None:\n            kwargs['limit'] = limit\n        if before_id is not None:\n            kwargs['before_id'] = before_id\n        if after_id is not None:\n            kwargs['after_id'] = after_id\n        return self.get_all_payment_requests_endpoint.call_with_http_info(**kwargs)\n\n    def capture_payment_request(\n        self,\n        payment_request_id: str,\n        for_user_id: Optional[str] = None,\n        capture_parameters: Optional[CaptureParameters] = None,\n        **kwargs\n    ) -> Capture:\n        \"\"\"Payment Request Capture  # noqa: E501\n\n        Payment Request Capture  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.capture_payment_request(payment_request_id, for_user_id, capture_parameters, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_request_id (str):\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            capture_parameters (CaptureParameters): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            Capture\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_request_id'] = payment_request_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if capture_parameters is not None:\n            kwargs['capture_parameters'] = capture_parameters\n        return self.capture_payment_request_endpoint.call_with_http_info(**kwargs)\n\n    def authorize_payment_request(\n        self,\n        payment_request_id: str,\n        for_user_id: Optional[str] = None,\n        payment_request_auth_parameters: Optional[PaymentRequestAuthParameters] = None,\n        **kwargs\n    ) -> PaymentRequest:\n        \"\"\"Payment Request Authorize  # noqa: E501\n\n        Payment Request Authorize  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.authorize_payment_request(payment_request_id, for_user_id, payment_request_auth_parameters, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_request_id (str):\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            payment_request_auth_parameters (PaymentRequestAuthParameters): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentRequest\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_request_id'] = payment_request_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if payment_request_auth_parameters is not None:\n            kwargs['payment_request_auth_parameters'] = payment_request_auth_parameters\n        return self.authorize_payment_request_endpoint.call_with_http_info(**kwargs)\n\n    def resend_payment_request_auth(\n        self,\n        payment_request_id: str,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> PaymentRequest:\n        \"\"\"Payment Request Resend Auth  # noqa: E501\n\n        Payment Request Resend Auth  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.resend_payment_request_auth(payment_request_id, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_request_id (str):\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentRequest\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_request_id'] = payment_request_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.resend_payment_request_auth_endpoint.call_with_http_info(**kwargs)\n\n    def simulate_payment_request_payment(\n        self,\n        payment_request_id: str,\n        **kwargs\n    ) -> PaymentSimulation:\n        \"\"\"Payment Request Simulate Payment  # noqa: E501\n\n        Payment Request Simulate Payment  # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.simulate_payment_request_payment(payment_request_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            payment_request_id (str):\n\n        Keyword Args:\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            PaymentSimulation\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['payment_request_id'] = payment_request_id\n        return self.simulate_payment_request_payment_endpoint.call_with_http_info(**kwargs)\n\n",
    "uncovered_lines": [
      33,
      600,
      602,
      604,
      692,
      753,
      756,
      759,
      762,
      765,
      768,
      771,
      774,
      776,
      777,
      778,
      779,
      780,
      781,
      782,
      783,
      850,
      853,
      856,
      859,
      862,
      865,
      868,
      871,
      873,
      874,
      875,
      876,
      877,
      878,
      879,
      880,
      881,
      882,
      883,
      884,
      885,
      886,
      887,
      888,
      889,
      949,
      952,
      955,
      958,
      961,
      964,
      967,
      970,
      972,
      973,
      974,
      975,
      976,
      977,
      978,
      979,
      1039,
      1042,
      1045,
      1048,
      1051,
      1054,
      1057,
      1060,
      1062,
      1063,
      1064,
      1065,
      1066,
      1067,
      1068,
      1069,
      1127,
      1130,
      1133,
      1136,
      1139,
      1142,
      1145,
      1148,
      1150,
      1151,
      1152,
      1153,
      1154,
      1155,
      1211,
      1214,
      1217,
      1220,
      1223,
      1226,
      1229,
      1232,
      1234,
      1235,
      1236,
      1237
    ]
  },
  {
    "file_path": "xendit/payment_request/model/capture.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.payment_method import PaymentMethod\nglobals()['PaymentMethod'] = PaymentMethod\n\ndef lazy_import():\n    pass\n\nclass Capture(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('status',): {\n            'SUCCEEDED': \"SUCCEEDED\",\n            'FAILED': \"FAILED\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'id': (str,),  # noqa: E501\n            'payment_request_id': (str,),  # noqa: E501\n            'payment_id': (str,),  # noqa: E501\n            'reference_id': (str,),  # noqa: E501\n            'currency': (str,),  # noqa: E501\n            'authorized_amount': (float,),  # noqa: E501\n            'captured_amount': (float,),  # noqa: E501\n            'status': (str,),  # noqa: E501\n            'payment_method': (PaymentMethod,),  # noqa: E501\n            'failure_code': (str, none_type,),  # noqa: E501\n            'customer_id': (str, none_type,),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type,),  # noqa: E501\n            'channel_properties': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type,),  # noqa: E501\n            'created': (str,),  # noqa: E501\n            'updated': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'id': 'id',  # noqa: E501\n        'payment_request_id': 'payment_request_id',  # noqa: E501\n        'payment_id': 'payment_id',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'authorized_amount': 'authorized_amount',  # noqa: E501\n        'captured_amount': 'captured_amount',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'payment_method': 'payment_method',  # noqa: E501\n        'failure_code': 'failure_code',  # noqa: E501\n        'customer_id': 'customer_id',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, id, payment_request_id, payment_id, reference_id, currency, authorized_amount, captured_amount, status, payment_method, failure_code, customer_id, metadata, channel_properties, created, updated, *args, **kwargs):  # noqa: E501\n        \"\"\"Capture - a model defined in OpenAPI\n\n        Args:\n            id (str):\n            payment_request_id (str):\n            payment_id (str):\n            reference_id (str):\n            currency (str):\n            authorized_amount (float):\n            captured_amount (float):\n            status (str):\n            payment_method (PaymentMethod):\n            failure_code (str, none_type):\n            customer_id (str, none_type):\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type):\n            channel_properties ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type):\n            created (str):\n            updated (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.payment_request_id = payment_request_id\n        self.payment_id = payment_id\n        self.reference_id = reference_id\n        self.currency = currency\n        self.authorized_amount = authorized_amount\n        self.captured_amount = captured_amount\n        self.status = status\n        self.payment_method = payment_method\n        self.failure_code = failure_code\n        self.customer_id = customer_id\n        self.metadata = metadata\n        self.channel_properties = channel_properties\n        self.created = created\n        self.updated = updated\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        id: str,\n        payment_request_id: str,\n        payment_id: str,\n        reference_id: str,\n        currency: str,\n        authorized_amount: float,\n        captured_amount: float,\n        status: str,\n        payment_method: PaymentMethod,\n        failure_code: str | None,\n        customer_id: str | None,\n        metadata: dict | None,\n        channel_properties: dict | None,\n        created: str,\n        updated: str,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Capture - a model defined in OpenAPI\n\n        Args:\n            id (str):\n            payment_request_id (str):\n            payment_id (str):\n            reference_id (str):\n            currency (str):\n            authorized_amount (float):\n            captured_amount (float):\n            status (str):\n            payment_method (PaymentMethod):\n            failure_code (str, none_type):\n            customer_id (str, none_type):\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type):\n            channel_properties ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type):\n            created (str):\n            updated (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.payment_request_id = payment_request_id\n        self.payment_id = payment_id\n        self.reference_id = reference_id\n        self.currency = currency\n        self.authorized_amount = authorized_amount\n        self.captured_amount = captured_amount\n        self.status = status\n        self.payment_method = payment_method\n        self.failure_code = failure_code\n        self.customer_id = customer_id\n        self.metadata = metadata\n        self.channel_properties = channel_properties\n        self.created = created\n        self.updated = updated\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      73,
      74,
      88,
      89,
      109,
      190,
      191,
      192,
      193,
      194,
      196,
      198,
      199,
      200,
      201,
      202,
      203,
      205,
      214,
      215,
      216,
      217,
      218,
      219,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      242,
      243,
      244,
      327,
      328,
      329,
      330,
      331,
      333,
      334,
      335,
      336,
      337,
      338,
      340,
      349,
      350,
      351,
      352,
      353,
      354,
      356,
      357,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      368,
      369,
      370,
      371,
      372,
      377,
      378,
      379,
      380
    ]
  },
  {
    "file_path": "xendit/payment_request/model/capture_list.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.capture import Capture\nglobals()['Capture'] = Capture\n\ndef lazy_import():\n    pass\n\nclass CaptureList(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'value': ([Capture],),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"CaptureList - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] ([Capture]):  # noqa: E501\n\n        Keyword Args:\n            value ([Capture]):  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"CaptureList - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] ([Capture]):  # noqa: E501\n\n        Keyword Args:\n            value ([Capture]):  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      73,
      74,
      80,
      141,
      143,
      144,
      145,
      146,
      147,
      149,
      155,
      156,
      157,
      158,
      160,
      161,
      162,
      163,
      164,
      165,
      167,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      237,
      239,
      241,
      242,
      243,
      244,
      245,
      247,
      253,
      254,
      255,
      256,
      258,
      259,
      260,
      261,
      262,
      263,
      265,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      291
    ]
  },
  {
    "file_path": "xendit/payment_request/model/capture_list_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.capture_list import CaptureList\nglobals()['CaptureList'] = CaptureList\n\ndef lazy_import():\n    pass\n\nclass CaptureListResponse(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'data': (CaptureList,),  # noqa: E501\n            'has_more': (bool,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'data': 'data',  # noqa: E501\n        'has_more': 'has_more',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, data, has_more, *args, **kwargs):  # noqa: E501\n        \"\"\"CaptureListResponse - a model defined in OpenAPI\n\n        Args:\n            data (CaptureList):\n            has_more (bool):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.data = data\n        self.has_more = has_more\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        data: CaptureList,\n        has_more: bool,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CaptureListResponse - a model defined in OpenAPI\n\n        Args:\n            data (CaptureList):\n            has_more (bool):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.data = data\n        self.has_more = has_more\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      92,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      180,
      181,
      186,
      187,
      188,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      282,
      283,
      284,
      285
    ]
  },
  {
    "file_path": "xendit/payment_request/model/capture_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CaptureParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'capture_amount': (float,),  # noqa: E501\n            'reference_id': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'capture_amount': 'capture_amount',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, capture_amount, *args, **kwargs):  # noqa: E501\n        \"\"\"CaptureParameters - a model defined in OpenAPI\n\n        Args:\n            capture_amount (float):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            reference_id (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.capture_amount = capture_amount\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        capture_amount: float,\n        reference_id: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CaptureParameters - a model defined in OpenAPI\n\n        Args:\n            capture_amount (float):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            reference_id (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.capture_amount = capture_amount\n        if reference_id is not None:\n            self.reference_id = reference_id\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      143,
      144,
      145,
      146,
      147,
      149,
      151,
      152,
      153,
      154,
      155,
      156,
      158,
      167,
      168,
      169,
      170,
      171,
      172,
      174,
      175,
      176,
      181,
      182,
      183,
      240,
      241,
      242,
      243,
      244,
      246,
      247,
      248,
      249,
      250,
      251,
      253,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/payment_request/model/card.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.card_channel_code import CardChannelCode\nfrom xendit.payment_request.model.card_channel_properties import CardChannelProperties\nfrom xendit.payment_request.model.card_information import CardInformation\nfrom xendit.payment_request.model.card_verification_results import CardVerificationResults\nfrom xendit.payment_request.model.payment_request_currency import PaymentRequestCurrency\nglobals()['CardChannelCode'] = CardChannelCode\nglobals()['CardChannelProperties'] = CardChannelProperties\nglobals()['CardInformation'] = CardInformation\nglobals()['CardVerificationResults'] = CardVerificationResults\nglobals()['PaymentRequestCurrency'] = PaymentRequestCurrency\n\ndef lazy_import():\n    pass\n\nclass Card(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_properties': (CardChannelProperties,),  # noqa: E501\n            'channel_code': (CardChannelCode, none_type),  # noqa: E501\n            'currency': (PaymentRequestCurrency, none_type),  # noqa: E501\n            'card_information': (CardInformation, none_type),  # noqa: E501\n            'card_verification_results': (CardVerificationResults, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'channel_code': 'channel_code',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'card_information': 'card_information',  # noqa: E501\n        'card_verification_results': 'card_verification_results',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, channel_properties, *args, **kwargs):  # noqa: E501\n        \"\"\"Card - a model defined in OpenAPI\n\n        Args:\n            channel_properties (CardChannelProperties):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (CardChannelCode): [optional]  # noqa: E501\n            currency (PaymentRequestCurrency): [optional]  # noqa: E501\n            card_information (CardInformation): [optional]  # noqa: E501\n            card_verification_results (CardVerificationResults): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_properties: CardChannelProperties,\n        channel_code: CardChannelCode | None = None,\n        currency: PaymentRequestCurrency | None = None,\n        card_information: CardInformation | None = None,\n        card_verification_results: CardVerificationResults | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Card - a model defined in OpenAPI\n\n        Args:\n            channel_properties (CardChannelProperties):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (CardChannelCode): [optional]  # noqa: E501\n            currency (PaymentRequestCurrency): [optional]  # noqa: E501\n            card_information (CardInformation): [optional]  # noqa: E501\n            card_verification_results (CardVerificationResults): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_properties = channel_properties\n        if channel_code is not None:\n            self.channel_code = channel_code\n        if currency is not None:\n            self.currency = currency\n        if card_information is not None:\n            self.card_information = card_information\n        if card_verification_results is not None:\n            self.card_verification_results = card_verification_results\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      77,
      78,
      92,
      93,
      103,
      164,
      165,
      166,
      167,
      168,
      170,
      172,
      173,
      174,
      175,
      176,
      177,
      179,
      188,
      189,
      190,
      191,
      192,
      193,
      195,
      196,
      197,
      202,
      203,
      204,
      267,
      268,
      269,
      270,
      271,
      273,
      274,
      275,
      276,
      277,
      278,
      280,
      289,
      290,
      291,
      292,
      293,
      294,
      296,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      305,
      306,
      311,
      312,
      313,
      314
    ]
  },
  {
    "file_path": "xendit/payment_request/model/card_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CardChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BAY_CARD_INSTALLMENT': \"BAY_CARD_INSTALLMENT\",\n            'BBL_CARD_INSTALLMENT': \"BBL_CARD_INSTALLMENT\",\n            'GPN': \"GPN\",\n            'KBANK_CARD_INSTALLMENT': \"KBANK_CARD_INSTALLMENT\",\n            'KTB_CARD_INSTALLMENT': \"KTB_CARD_INSTALLMENT\",\n            'SCB_CARD_INSTALLMENT': \"SCB_CARD_INSTALLMENT\",\n            'TTB_CARD_INSTALLMENT': \"TTB_CARD_INSTALLMENT\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"CardChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Card Channel Code., must be one of [\"BAY_CARD_INSTALLMENT\", \"BBL_CARD_INSTALLMENT\", \"GPN\", \"KBANK_CARD_INSTALLMENT\", \"KTB_CARD_INSTALLMENT\", \"SCB_CARD_INSTALLMENT\", \"TTB_CARD_INSTALLMENT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Card Channel Code., must be one of [\"BAY_CARD_INSTALLMENT\", \"BBL_CARD_INSTALLMENT\", \"GPN\", \"KBANK_CARD_INSTALLMENT\", \"KTB_CARD_INSTALLMENT\", \"SCB_CARD_INSTALLMENT\", \"TTB_CARD_INSTALLMENT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"CardChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Card Channel Code., must be one of [\"BAY_CARD_INSTALLMENT\", \"BBL_CARD_INSTALLMENT\", \"GPN\", \"KBANK_CARD_INSTALLMENT\", \"KTB_CARD_INSTALLMENT\", \"SCB_CARD_INSTALLMENT\", \"TTB_CARD_INSTALLMENT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Card Channel Code., must be one of [\"BAY_CARD_INSTALLMENT\", \"BBL_CARD_INSTALLMENT\", \"GPN\", \"KBANK_CARD_INSTALLMENT\", \"KTB_CARD_INSTALLMENT\", \"SCB_CARD_INSTALLMENT\", \"TTB_CARD_INSTALLMENT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      81,
      87,
      148,
      150,
      151,
      152,
      153,
      154,
      156,
      162,
      163,
      164,
      165,
      167,
      168,
      169,
      170,
      171,
      172,
      174,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      244,
      246,
      248,
      249,
      250,
      251,
      252,
      254,
      260,
      261,
      262,
      263,
      265,
      266,
      267,
      268,
      269,
      270,
      272,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      301
    ]
  },
  {
    "file_path": "xendit/payment_request/model/card_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.card_installment_configuration import CardInstallmentConfiguration\nglobals()['CardInstallmentConfiguration'] = CardInstallmentConfiguration\n\ndef lazy_import():\n    pass\n\nclass CardChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('success_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('failure_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'skip_three_d_secure': (bool, none_type, none_type),  # noqa: E501\n            'success_return_url': (str, none_type, none_type),  # noqa: E501\n            'failure_return_url': (str, none_type, none_type),  # noqa: E501\n            'cardonfile_type': (str, none_type, none_type),  # noqa: E501\n            'merchant_id_tag': (str, none_type),  # noqa: E501\n            'expires_at': (datetime, none_type),  # noqa: E501\n            'installment_configuration': (CardInstallmentConfiguration, none_type),  # noqa: E501\n            'skip_authorization': (bool, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'skip_three_d_secure': 'skip_three_d_secure',  # noqa: E501\n        'success_return_url': 'success_return_url',  # noqa: E501\n        'failure_return_url': 'failure_return_url',  # noqa: E501\n        'cardonfile_type': 'cardonfile_type',  # noqa: E501\n        'merchant_id_tag': 'merchant_id_tag',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n        'installment_configuration': 'installment_configuration',  # noqa: E501\n        'skip_authorization': 'skip_authorization',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CardChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            skip_three_d_secure (bool, none_type): To indicate whether to perform 3DS during the linking phase. [optional]  # noqa: E501\n            success_return_url (str, none_type): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str, none_type): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            cardonfile_type (str, none_type): Type of credential-on-file / card-on-file payment being made. Indicate that this payment uses a previously linked Payment Method for charging.. [optional]  # noqa: E501\n            merchant_id_tag (str): Tag for a Merchant ID that you want to associate this payment with. For merchants using their own MIDs to specify which MID they want to use. [optional]  # noqa: E501\n            expires_at (datetime): [optional]  # noqa: E501\n            installment_configuration (CardInstallmentConfiguration): [optional]  # noqa: E501\n            skip_authorization (bool): To indicate whether to skip the authorization phase. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        skip_three_d_secure: bool | None = None,\n        success_return_url: str | None = None,\n        failure_return_url: str | None = None,\n        cardonfile_type: str | None = None,\n        merchant_id_tag: str | None = None,\n        expires_at: datetime | None = None,\n        installment_configuration: CardInstallmentConfiguration | None = None,\n        skip_authorization: bool | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardChannelProperties - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            skip_three_d_secure (bool, none_type): To indicate whether to perform 3DS during the linking phase. [optional]  # noqa: E501\n            success_return_url (str, none_type): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str, none_type): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            cardonfile_type (str, none_type): Type of credential-on-file / card-on-file payment being made. Indicate that this payment uses a previously linked Payment Method for charging.. [optional]  # noqa: E501\n            merchant_id_tag (str): Tag for a Merchant ID that you want to associate this payment with. For merchants using their own MIDs to specify which MID they want to use. [optional]  # noqa: E501\n            expires_at (datetime): [optional]  # noqa: E501\n            installment_configuration (CardInstallmentConfiguration): [optional]  # noqa: E501\n            skip_authorization (bool): To indicate whether to skip the authorization phase. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if skip_three_d_secure is not None:\n            self.skip_three_d_secure = skip_three_d_secure\n        if success_return_url is not None:\n            self.success_return_url = success_return_url\n        if failure_return_url is not None:\n            self.failure_return_url = failure_return_url\n        if cardonfile_type is not None:\n            self.cardonfile_type = cardonfile_type\n        if merchant_id_tag is not None:\n            self.merchant_id_tag = merchant_id_tag\n        if expires_at is not None:\n            self.expires_at = expires_at\n        if installment_configuration is not None:\n            self.installment_configuration = installment_configuration\n        if skip_authorization is not None:\n            self.skip_authorization = skip_authorization\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      79,
      80,
      94,
      95,
      108,
      173,
      174,
      175,
      176,
      177,
      179,
      181,
      182,
      183,
      184,
      185,
      186,
      188,
      197,
      198,
      199,
      200,
      201,
      202,
      204,
      205,
      210,
      211,
      212,
      279,
      280,
      281,
      282,
      283,
      285,
      286,
      287,
      288,
      289,
      290,
      292,
      301,
      302,
      303,
      304,
      305,
      306,
      308,
      309,
      310,
      311,
      312,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      322,
      323,
      324,
      325,
      330,
      331,
      332,
      333
    ]
  },
  {
    "file_path": "xendit/payment_request/model/card_information.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CardInformation(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('network',): {\n            'VISA': \"VISA\",\n            'MASTERCARD': \"MASTERCARD\",\n            'JCB': \"JCB\",\n            'AMEX': \"AMEX\",\n            'DISCOVER': \"DISCOVER\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'token_id': (str, none_type),  # noqa: E501\n            'masked_card_number': (str, none_type),  # noqa: E501\n            'expiry_month': (str, none_type),  # noqa: E501\n            'expiry_year': (str, none_type),  # noqa: E501\n            'cardholder_name': (str, none_type, none_type),  # noqa: E501\n            'fingerprint': (str, none_type),  # noqa: E501\n            'type': (str, none_type),  # noqa: E501\n            'network': (str, none_type),  # noqa: E501\n            'country': (str, none_type),  # noqa: E501\n            'issuer': (str, none_type),  # noqa: E501\n            'card_number': (str, none_type),  # noqa: E501\n            'one_time_token': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'token_id': 'token_id',  # noqa: E501\n        'masked_card_number': 'masked_card_number',  # noqa: E501\n        'expiry_month': 'expiry_month',  # noqa: E501\n        'expiry_year': 'expiry_year',  # noqa: E501\n        'cardholder_name': 'cardholder_name',  # noqa: E501\n        'fingerprint': 'fingerprint',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'network': 'network',  # noqa: E501\n        'country': 'country',  # noqa: E501\n        'issuer': 'issuer',  # noqa: E501\n        'card_number': 'card_number',  # noqa: E501\n        'one_time_token': 'one_time_token',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CardInformation - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            token_id (str): [optional]  # noqa: E501\n            masked_card_number (str): 1st 6 and last 4 digits of the card. [optional]  # noqa: E501\n            expiry_month (str): Card expiry month in MM format. [optional]  # noqa: E501\n            expiry_year (str): Card expiry month in YY format. [optional]  # noqa: E501\n            cardholder_name (str, none_type): Cardholder name. [optional]  # noqa: E501\n            fingerprint (str): [optional]  # noqa: E501\n            type (str): [optional]  # noqa: E501\n            network (str): [optional]  # noqa: E501\n            country (str): [optional]  # noqa: E501\n            issuer (str): [optional]  # noqa: E501\n            card_number (str): [optional]  # noqa: E501\n            one_time_token (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        token_id: str | None = None,\n        masked_card_number: str | None = None,\n        expiry_month: str | None = None,\n        expiry_year: str | None = None,\n        cardholder_name: str | None = None,\n        fingerprint: str | None = None,\n        type: str | None = None,\n        network: str | None = None,\n        country: str | None = None,\n        issuer: str | None = None,\n        card_number: str | None = None,\n        one_time_token: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardInformation - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            token_id (str): [optional]  # noqa: E501\n            masked_card_number (str): 1st 6 and last 4 digits of the card. [optional]  # noqa: E501\n            expiry_month (str): Card expiry month in MM format. [optional]  # noqa: E501\n            expiry_year (str): Card expiry month in YY format. [optional]  # noqa: E501\n            cardholder_name (str, none_type): Cardholder name. [optional]  # noqa: E501\n            fingerprint (str): [optional]  # noqa: E501\n            type (str): [optional]  # noqa: E501\n            network (str): [optional]  # noqa: E501\n            country (str): [optional]  # noqa: E501\n            issuer (str): [optional]  # noqa: E501\n            card_number (str): [optional]  # noqa: E501\n            one_time_token (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if token_id is not None:\n            self.token_id = token_id\n        if masked_card_number is not None:\n            self.masked_card_number = masked_card_number\n        if expiry_month is not None:\n            self.expiry_month = expiry_month\n        if expiry_year is not None:\n            self.expiry_year = expiry_year\n        if cardholder_name is not None:\n            self.cardholder_name = cardholder_name\n        if fingerprint is not None:\n            self.fingerprint = fingerprint\n        if type is not None:\n            self.type = type\n        if network is not None:\n            self.network = network\n        if country is not None:\n            self.country = country\n        if issuer is not None:\n            self.issuer = issuer\n        if card_number is not None:\n            self.card_number = card_number\n        if one_time_token is not None:\n            self.one_time_token = one_time_token\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      74,
      88,
      105,
      178,
      179,
      180,
      181,
      182,
      184,
      186,
      187,
      188,
      189,
      190,
      191,
      193,
      202,
      203,
      204,
      205,
      206,
      207,
      209,
      210,
      215,
      216,
      217,
      292,
      293,
      294,
      295,
      296,
      298,
      299,
      300,
      301,
      302,
      303,
      305,
      314,
      315,
      316,
      317,
      318,
      319,
      321,
      322,
      323,
      324,
      325,
      326,
      327,
      328,
      329,
      330,
      331,
      332,
      333,
      334,
      335,
      336,
      337,
      338,
      339,
      340,
      341,
      342,
      343,
      344,
      345,
      346,
      351,
      352,
      353,
      354
    ]
  },
  {
    "file_path": "xendit/payment_request/model/card_installment_configuration.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CardInstallmentConfiguration(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'terms': (int, none_type),  # noqa: E501\n            'interval': (str, none_type),  # noqa: E501\n            'code': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'terms': 'terms',  # noqa: E501\n        'interval': 'interval',  # noqa: E501\n        'code': 'code',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CardInstallmentConfiguration - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            terms (int): [optional]  # noqa: E501\n            interval (str): [optional]  # noqa: E501\n            code (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        terms: int | None = None,\n        interval: str | None = None,\n        code: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardInstallmentConfiguration - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            terms (int): [optional]  # noqa: E501\n            interval (str): [optional]  # noqa: E501\n            code (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if terms is not None:\n            self.terms = terms\n        if interval is not None:\n            self.interval = interval\n        if code is not None:\n            self.code = code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      181,
      182,
      183,
      240,
      241,
      242,
      243,
      244,
      246,
      247,
      248,
      249,
      250,
      251,
      253,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      275,
      276,
      281,
      282,
      283,
      284
    ]
  },
  {
    "file_path": "xendit/payment_request/model/card_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.card_channel_properties import CardChannelProperties\nfrom xendit.payment_request.model.card_information import CardInformation\nglobals()['CardChannelProperties'] = CardChannelProperties\nglobals()['CardInformation'] = CardInformation\n\ndef lazy_import():\n    pass\n\nclass CardParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_properties': (CardChannelProperties,),  # noqa: E501\n            'card_information': (CardInformation, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'card_information': 'card_information',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, channel_properties, *args, **kwargs):  # noqa: E501\n        \"\"\"CardParameters - a model defined in OpenAPI\n\n        Args:\n            channel_properties (CardChannelProperties):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            card_information (CardInformation): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_properties: CardChannelProperties,\n        card_information: CardInformation | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardParameters - a model defined in OpenAPI\n\n        Args:\n            channel_properties (CardChannelProperties):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            card_information (CardInformation): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_properties = channel_properties\n        if card_information is not None:\n            self.card_information = card_information\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      86,
      87,
      94,
      149,
      150,
      151,
      152,
      153,
      155,
      157,
      158,
      159,
      160,
      161,
      162,
      164,
      173,
      174,
      175,
      176,
      177,
      178,
      180,
      181,
      182,
      187,
      188,
      189,
      246,
      247,
      248,
      249,
      250,
      252,
      253,
      254,
      255,
      256,
      257,
      259,
      268,
      269,
      270,
      271,
      272,
      273,
      275,
      276,
      277,
      278,
      279,
      284,
      285,
      286,
      287
    ]
  },
  {
    "file_path": "xendit/payment_request/model/card_verification_results.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.card_verification_results_three_d_secure import CardVerificationResultsThreeDSecure\nglobals()['CardVerificationResultsThreeDSecure'] = CardVerificationResultsThreeDSecure\n\ndef lazy_import():\n    pass\n\nclass CardVerificationResults(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'three_d_secure': (CardVerificationResultsThreeDSecure, none_type),  # noqa: E501\n            'cvv_result': (str, none_type, none_type),  # noqa: E501\n            'address_verification_result': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'three_d_secure': 'three_d_secure',  # noqa: E501\n        'cvv_result': 'cvv_result',  # noqa: E501\n        'address_verification_result': 'address_verification_result',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CardVerificationResults - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            three_d_secure (CardVerificationResultsThreeDSecure): [optional]  # noqa: E501\n            cvv_result (str, none_type): [optional]  # noqa: E501\n            address_verification_result (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        three_d_secure: CardVerificationResultsThreeDSecure | None = None,\n        cvv_result: str | None = None,\n        address_verification_result: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardVerificationResults - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            three_d_secure (CardVerificationResultsThreeDSecure): [optional]  # noqa: E501\n            cvv_result (str, none_type): [optional]  # noqa: E501\n            address_verification_result (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if three_d_secure is not None:\n            self.three_d_secure = three_d_secure\n        if cvv_result is not None:\n            self.cvv_result = cvv_result\n        if address_verification_result is not None:\n            self.address_verification_result = address_verification_result\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      93,
      148,
      149,
      150,
      151,
      152,
      154,
      156,
      157,
      158,
      159,
      160,
      161,
      163,
      172,
      173,
      174,
      175,
      176,
      177,
      179,
      180,
      185,
      186,
      187,
      244,
      245,
      246,
      247,
      248,
      250,
      251,
      252,
      253,
      254,
      255,
      257,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      285,
      286,
      287,
      288
    ]
  },
  {
    "file_path": "xendit/payment_request/model/card_verification_results_three_d_secure.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CardVerificationResultsThreeDSecure(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('three_d_secure_flow',): {\n            'None': None,\n            'CHALLENGE': \"CHALLENGE\",\n            'FRICTIONLESS': \"FRICTIONLESS\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'three_d_secure_flow': (str, none_type, none_type),  # noqa: E501\n            'eci_code': (str, none_type, none_type),  # noqa: E501\n            'three_d_secure_result': (str, none_type, none_type),  # noqa: E501\n            'three_d_secure_result_reason': (str, none_type, none_type),  # noqa: E501\n            'three_d_secure_version': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'three_d_secure_flow': 'three_d_secure_flow',  # noqa: E501\n        'eci_code': 'eci_code',  # noqa: E501\n        'three_d_secure_result': 'three_d_secure_result',  # noqa: E501\n        'three_d_secure_result_reason': 'three_d_secure_result_reason',  # noqa: E501\n        'three_d_secure_version': 'three_d_secure_version',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CardVerificationResultsThreeDSecure - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            three_d_secure_flow (str, none_type): [optional]  # noqa: E501\n            eci_code (str, none_type): [optional]  # noqa: E501\n            three_d_secure_result (str, none_type): [optional]  # noqa: E501\n            three_d_secure_result_reason (str, none_type): [optional]  # noqa: E501\n            three_d_secure_version (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        three_d_secure_flow: str | None = None,\n        eci_code: str | None = None,\n        three_d_secure_result: str | None = None,\n        three_d_secure_result_reason: str | None = None,\n        three_d_secure_version: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CardVerificationResultsThreeDSecure - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            three_d_secure_flow (str, none_type): [optional]  # noqa: E501\n            eci_code (str, none_type): [optional]  # noqa: E501\n            three_d_secure_result (str, none_type): [optional]  # noqa: E501\n            three_d_secure_result_reason (str, none_type): [optional]  # noqa: E501\n            three_d_secure_version (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if three_d_secure_flow is not None:\n            self.three_d_secure_flow = three_d_secure_flow\n        if eci_code is not None:\n            self.eci_code = eci_code\n        if three_d_secure_result is not None:\n            self.three_d_secure_result = three_d_secure_result\n        if three_d_secure_result_reason is not None:\n            self.three_d_secure_result_reason = three_d_secure_result_reason\n        if three_d_secure_version is not None:\n            self.three_d_secure_version = three_d_secure_version\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      72,
      86,
      96,
      155,
      156,
      157,
      158,
      159,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      186,
      187,
      192,
      193,
      194,
      255,
      256,
      257,
      258,
      259,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      277,
      278,
      279,
      280,
      281,
      282,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      294,
      295,
      300,
      301,
      302,
      303
    ]
  },
  {
    "file_path": "xendit/payment_request/model/direct_debit.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.direct_debit_all_of import DirectDebitAllOf\nfrom xendit.payment_request.model.direct_debit_bank_account import DirectDebitBankAccount\nfrom xendit.payment_request.model.direct_debit_channel_code import DirectDebitChannelCode\nfrom xendit.payment_request.model.direct_debit_channel_properties import DirectDebitChannelProperties\nfrom xendit.payment_request.model.direct_debit_debit_card import DirectDebitDebitCard\nfrom xendit.payment_request.model.direct_debit_parameters import DirectDebitParameters\nfrom xendit.payment_request.model.direct_debit_type import DirectDebitType\nglobals()['DirectDebitAllOf'] = DirectDebitAllOf\nglobals()['DirectDebitBankAccount'] = DirectDebitBankAccount\nglobals()['DirectDebitChannelCode'] = DirectDebitChannelCode\nglobals()['DirectDebitChannelProperties'] = DirectDebitChannelProperties\nglobals()['DirectDebitDebitCard'] = DirectDebitDebitCard\nglobals()['DirectDebitParameters'] = DirectDebitParameters\nglobals()['DirectDebitType'] = DirectDebitType\n\ndef lazy_import():\n    pass\n\nclass DirectDebit(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (DirectDebitChannelCode,),  # noqa: E501\n            'channel_properties': (DirectDebitChannelProperties,),  # noqa: E501\n            'type': (DirectDebitType,),  # noqa: E501\n            'bank_account': (DirectDebitBankAccount, none_type),  # noqa: E501\n            'debit_card': (DirectDebitDebitCard, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'bank_account': 'bank_account',  # noqa: E501\n        'debit_card': 'debit_card',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebit - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (DirectDebitChannelCode):\n            channel_properties (DirectDebitChannelProperties):\n            type (DirectDebitType):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            bank_account (DirectDebitBankAccount): [optional]  # noqa: E501\n            debit_card (DirectDebitDebitCard): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebit - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (DirectDebitChannelCode):\n            channel_properties (DirectDebitChannelProperties):\n            type (DirectDebitType):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            bank_account (DirectDebitBankAccount): [optional]  # noqa: E501\n            debit_card (DirectDebitDebitCard): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              DirectDebitAllOf,\n              DirectDebitParameters,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      81,
      82,
      96,
      97,
      107,
      164,
      165,
      166,
      167,
      168,
      170,
      172,
      173,
      174,
      175,
      176,
      177,
      179,
      188,
      189,
      190,
      191,
      192,
      193,
      195,
      202,
      204,
      205,
      206,
      207,
      209,
      210,
      215,
      216,
      218,
      274,
      275,
      276,
      277,
      278,
      280,
      281,
      282,
      283,
      284,
      285,
      287,
      296,
      297,
      298,
      299,
      300,
      301,
      303,
      310,
      312,
      313,
      314,
      315,
      317,
      318,
      323,
      324,
      325,
      326,
      338,
      339
    ]
  },
  {
    "file_path": "xendit/payment_request/model/direct_debit_all_of.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.direct_debit_bank_account import DirectDebitBankAccount\nfrom xendit.payment_request.model.direct_debit_debit_card import DirectDebitDebitCard\nfrom xendit.payment_request.model.direct_debit_type import DirectDebitType\nglobals()['DirectDebitBankAccount'] = DirectDebitBankAccount\nglobals()['DirectDebitDebitCard'] = DirectDebitDebitCard\nglobals()['DirectDebitType'] = DirectDebitType\n\ndef lazy_import():\n    pass\n\nclass DirectDebitAllOf(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'type': (DirectDebitType,),  # noqa: E501\n            'bank_account': (DirectDebitBankAccount, none_type),  # noqa: E501\n            'debit_card': (DirectDebitDebitCard, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'type': 'type',  # noqa: E501\n        'bank_account': 'bank_account',  # noqa: E501\n        'debit_card': 'debit_card',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, type, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitAllOf - a model defined in OpenAPI\n\n        Args:\n            type (DirectDebitType):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            bank_account (DirectDebitBankAccount): [optional]  # noqa: E501\n            debit_card (DirectDebitDebitCard): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        type: DirectDebitType,\n        bank_account: DirectDebitBankAccount | None = None,\n        debit_card: DirectDebitDebitCard | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitAllOf - a model defined in OpenAPI\n\n        Args:\n            type (DirectDebitType):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            bank_account (DirectDebitBankAccount): [optional]  # noqa: E501\n            debit_card (DirectDebitDebitCard): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        if bank_account is not None:\n            self.bank_account = bank_account\n        if debit_card is not None:\n            self.debit_card = debit_card\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      73,
      74,
      88,
      89,
      97,
      154,
      155,
      156,
      157,
      158,
      160,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      178,
      179,
      180,
      181,
      182,
      183,
      185,
      186,
      187,
      192,
      193,
      194,
      253,
      254,
      255,
      256,
      257,
      259,
      260,
      261,
      262,
      263,
      264,
      266,
      275,
      276,
      277,
      278,
      279,
      280,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      293,
      294,
      295,
      296
    ]
  },
  {
    "file_path": "xendit/payment_request/model/direct_debit_bank_account.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitBankAccount(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'masked_bank_account_number': (str, none_type, none_type),  # noqa: E501\n            'bank_account_hash': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'masked_bank_account_number': 'masked_bank_account_number',  # noqa: E501\n        'bank_account_hash': 'bank_account_hash',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitBankAccount - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            masked_bank_account_number (str, none_type): [optional]  # noqa: E501\n            bank_account_hash (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        masked_bank_account_number: str | None = None,\n        bank_account_hash: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitBankAccount - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            masked_bank_account_number (str, none_type): [optional]  # noqa: E501\n            bank_account_hash (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if masked_bank_account_number is not None:\n            self.masked_bank_account_number = masked_bank_account_number\n        if bank_account_hash is not None:\n            self.bank_account_hash = bank_account_hash\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/payment_request/model/direct_debit_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BCA_KLIKPAY': \"BCA_KLIKPAY\",\n            'BCA_ONEKLIK': \"BCA_ONEKLIK\",\n            'BRI': \"BRI\",\n            'BNI_AUTOPAY': \"BNI_AUTOPAY\",\n            'MANDIRI': \"MANDIRI\",\n            'BPI': \"BPI\",\n            'BPI_RECURRING': \"BPI_RECURRING\",\n            'BDO': \"BDO\",\n            'CIMBNIAGA': \"CIMBNIAGA\",\n            'MTB': \"MTB\",\n            'RCBC': \"RCBC\",\n            'UBP': \"UBP\",\n            'UBP_EADA': \"UBP_EADA\",\n            'UBP_DEBIT_PULL': \"UBP_DEBIT_PULL\",\n            'CHINABANK': \"CHINABANK\",\n            'BAY': \"BAY\",\n            'KTB': \"KTB\",\n            'BBL': \"BBL\",\n            'SCB': \"SCB\",\n            'KBANK_MB': \"KBANK_MB\",\n            'BAY_MB': \"BAY_MB\",\n            'KTB_MB': \"KTB_MB\",\n            'BBL_MB': \"BBL_MB\",\n            'SCB_MB': \"SCB_MB\",\n            'BDO_EPAY': \"BDO_EPAY\",\n            'AFFIN_FPX': \"AFFIN_FPX\",\n            'AGRO_FPX': \"AGRO_FPX\",\n            'ALLIANCE_FPX': \"ALLIANCE_FPX\",\n            'AMBANK_FPX': \"AMBANK_FPX\",\n            'ISLAM_FPX': \"ISLAM_FPX\",\n            'MUAMALAT_FPX': \"MUAMALAT_FPX\",\n            'BOC_FPX': \"BOC_FPX\",\n            'RAKYAT_FPX': \"RAKYAT_FPX\",\n            'BSN_FPX': \"BSN_FPX\",\n            'CIMB_FPX': \"CIMB_FPX\",\n            'HLB_FPX': \"HLB_FPX\",\n            'HSBC_FPX': \"HSBC_FPX\",\n            'KFH_FPX': \"KFH_FPX\",\n            'MAYB2E_FPX': \"MAYB2E_FPX\",\n            'MAYB2U_FPX': \"MAYB2U_FPX\",\n            'OCBC_FPX': \"OCBC_FPX\",\n            'PUBLIC_FPX': \"PUBLIC_FPX\",\n            'RHB_FPX': \"RHB_FPX\",\n            'SCH_FPX': \"SCH_FPX\",\n            'UOB_FPX': \"UOB_FPX\",\n            'AFFIN_FPX_BUSINESS': \"AFFIN_FPX_BUSINESS\",\n            'AGRO_FPX_BUSINESS': \"AGRO_FPX_BUSINESS\",\n            'ALLIANCE_FPX_BUSINESS': \"ALLIANCE_FPX_BUSINESS\",\n            'AMBANK_FPX_BUSINESS': \"AMBANK_FPX_BUSINESS\",\n            'ISLAM_FPX_BUSINESS': \"ISLAM_FPX_BUSINESS\",\n            'MUAMALAT_FPX_BUSINESS': \"MUAMALAT_FPX_BUSINESS\",\n            'BNP_FPX_BUSINESS': \"BNP_FPX_BUSINESS\",\n            'CIMB_FPX_BUSINESS': \"CIMB_FPX_BUSINESS\",\n            'CITIBANK_FPX_BUSINESS': \"CITIBANK_FPX_BUSINESS\",\n            'DEUTSCHE_FPX_BUSINESS': \"DEUTSCHE_FPX_BUSINESS\",\n            'HLB_FPX_BUSINESS': \"HLB_FPX_BUSINESS\",\n            'HSBC_FPX_BUSINESS': \"HSBC_FPX_BUSINESS\",\n            'RAKYAT_FPX_BUSINESS': \"RAKYAT_FPX_BUSINESS\",\n            'KFH_FPX_BUSINESS': \"KFH_FPX_BUSINESS\",\n            'MAYB2E_FPX_BUSINESS': \"MAYB2E_FPX_BUSINESS\",\n            'OCBC_FPX_BUSINESS': \"OCBC_FPX_BUSINESS\",\n            'PUBLIC_FPX_BUSINESS': \"PUBLIC_FPX_BUSINESS\",\n            'RHB_FPX_BUSINESS': \"RHB_FPX_BUSINESS\",\n            'SCH_FPX_BUSINESS': \"SCH_FPX_BUSINESS\",\n            'UOB_FPX_BUSINESS': \"UOB_FPX_BUSINESS\",\n            'BDO_ONLINE_BANKING': \"BDO_ONLINE_BANKING\",\n            'BPI_ONLINE_BANKING': \"BPI_ONLINE_BANKING\",\n            'UNIONBANK_ONLINE_BANKING': \"UNIONBANK_ONLINE_BANKING\",\n            'BOC_ONLINE_BANKING': \"BOC_ONLINE_BANKING\",\n            'CHINABANK_ONLINE_BANKING': \"CHINABANK_ONLINE_BANKING\",\n            'INSTAPAY_ONLINE_BANKING': \"INSTAPAY_ONLINE_BANKING\",\n            'LANDBANK_ONLINE_BANKING': \"LANDBANK_ONLINE_BANKING\",\n            'MAYBANK_ONLINE_BANKING': \"MAYBANK_ONLINE_BANKING\",\n            'METROBANK_ONLINE_BANKING': \"METROBANK_ONLINE_BANKING\",\n            'PNB_ONLINE_BANKING': \"PNB_ONLINE_BANKING\",\n            'PSBANK_ONLINE_BANKING': \"PSBANK_ONLINE_BANKING\",\n            'PESONET_ONLINE_BANKING': \"PESONET_ONLINE_BANKING\",\n            'RCBC_ONLINE_BANKING': \"RCBC_ONLINE_BANKING\",\n            'ROBINSONS_BANK_ONLINE_BANKING': \"ROBINSONS_BANK_ONLINE_BANKING\",\n            'SECURITY_BANK_ONLINE_BANKING': \"SECURITY_BANK_ONLINE_BANKING\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"DirectDebitChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Direct Debit Channel Code., must be one of [\"BCA_KLIKPAY\", \"BCA_ONEKLIK\", \"BRI\", \"BNI_AUTOPAY\", \"MANDIRI\", \"BPI\", \"BPI_RECURRING\", \"BDO\", \"CIMBNIAGA\", \"MTB\", \"RCBC\", \"UBP\", \"UBP_EADA\", \"UBP_DEBIT_PULL\", \"CHINABANK\", \"BAY\", \"KTB\", \"BBL\", \"SCB\", \"KBANK_MB\", \"BAY_MB\", \"KTB_MB\", \"BBL_MB\", \"SCB_MB\", \"BDO_EPAY\", \"AFFIN_FPX\", \"AGRO_FPX\", \"ALLIANCE_FPX\", \"AMBANK_FPX\", \"ISLAM_FPX\", \"MUAMALAT_FPX\", \"BOC_FPX\", \"RAKYAT_FPX\", \"BSN_FPX\", \"CIMB_FPX\", \"HLB_FPX\", \"HSBC_FPX\", \"KFH_FPX\", \"MAYB2E_FPX\", \"MAYB2U_FPX\", \"OCBC_FPX\", \"PUBLIC_FPX\", \"RHB_FPX\", \"SCH_FPX\", \"UOB_FPX\", \"AFFIN_FPX_BUSINESS\", \"AGRO_FPX_BUSINESS\", \"ALLIANCE_FPX_BUSINESS\", \"AMBANK_FPX_BUSINESS\", \"ISLAM_FPX_BUSINESS\", \"MUAMALAT_FPX_BUSINESS\", \"BNP_FPX_BUSINESS\", \"CIMB_FPX_BUSINESS\", \"CITIBANK_FPX_BUSINESS\", \"DEUTSCHE_FPX_BUSINESS\", \"HLB_FPX_BUSINESS\", \"HSBC_FPX_BUSINESS\", \"RAKYAT_FPX_BUSINESS\", \"KFH_FPX_BUSINESS\", \"MAYB2E_FPX_BUSINESS\", \"OCBC_FPX_BUSINESS\", \"PUBLIC_FPX_BUSINESS\", \"RHB_FPX_BUSINESS\", \"SCH_FPX_BUSINESS\", \"UOB_FPX_BUSINESS\", \"BDO_ONLINE_BANKING\", \"BPI_ONLINE_BANKING\", \"UNIONBANK_ONLINE_BANKING\", \"BOC_ONLINE_BANKING\", \"CHINABANK_ONLINE_BANKING\", \"INSTAPAY_ONLINE_BANKING\", \"LANDBANK_ONLINE_BANKING\", \"MAYBANK_ONLINE_BANKING\", \"METROBANK_ONLINE_BANKING\", \"PNB_ONLINE_BANKING\", \"PSBANK_ONLINE_BANKING\", \"PESONET_ONLINE_BANKING\", \"RCBC_ONLINE_BANKING\", \"ROBINSONS_BANK_ONLINE_BANKING\", \"SECURITY_BANK_ONLINE_BANKING\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Direct Debit Channel Code., must be one of [\"BCA_KLIKPAY\", \"BCA_ONEKLIK\", \"BRI\", \"BNI_AUTOPAY\", \"MANDIRI\", \"BPI\", \"BPI_RECURRING\", \"BDO\", \"CIMBNIAGA\", \"MTB\", \"RCBC\", \"UBP\", \"UBP_EADA\", \"UBP_DEBIT_PULL\", \"CHINABANK\", \"BAY\", \"KTB\", \"BBL\", \"SCB\", \"KBANK_MB\", \"BAY_MB\", \"KTB_MB\", \"BBL_MB\", \"SCB_MB\", \"BDO_EPAY\", \"AFFIN_FPX\", \"AGRO_FPX\", \"ALLIANCE_FPX\", \"AMBANK_FPX\", \"ISLAM_FPX\", \"MUAMALAT_FPX\", \"BOC_FPX\", \"RAKYAT_FPX\", \"BSN_FPX\", \"CIMB_FPX\", \"HLB_FPX\", \"HSBC_FPX\", \"KFH_FPX\", \"MAYB2E_FPX\", \"MAYB2U_FPX\", \"OCBC_FPX\", \"PUBLIC_FPX\", \"RHB_FPX\", \"SCH_FPX\", \"UOB_FPX\", \"AFFIN_FPX_BUSINESS\", \"AGRO_FPX_BUSINESS\", \"ALLIANCE_FPX_BUSINESS\", \"AMBANK_FPX_BUSINESS\", \"ISLAM_FPX_BUSINESS\", \"MUAMALAT_FPX_BUSINESS\", \"BNP_FPX_BUSINESS\", \"CIMB_FPX_BUSINESS\", \"CITIBANK_FPX_BUSINESS\", \"DEUTSCHE_FPX_BUSINESS\", \"HLB_FPX_BUSINESS\", \"HSBC_FPX_BUSINESS\", \"RAKYAT_FPX_BUSINESS\", \"KFH_FPX_BUSINESS\", \"MAYB2E_FPX_BUSINESS\", \"OCBC_FPX_BUSINESS\", \"PUBLIC_FPX_BUSINESS\", \"RHB_FPX_BUSINESS\", \"SCH_FPX_BUSINESS\", \"UOB_FPX_BUSINESS\", \"BDO_ONLINE_BANKING\", \"BPI_ONLINE_BANKING\", \"UNIONBANK_ONLINE_BANKING\", \"BOC_ONLINE_BANKING\", \"CHINABANK_ONLINE_BANKING\", \"INSTAPAY_ONLINE_BANKING\", \"LANDBANK_ONLINE_BANKING\", \"MAYBANK_ONLINE_BANKING\", \"METROBANK_ONLINE_BANKING\", \"PNB_ONLINE_BANKING\", \"PSBANK_ONLINE_BANKING\", \"PESONET_ONLINE_BANKING\", \"RCBC_ONLINE_BANKING\", \"ROBINSONS_BANK_ONLINE_BANKING\", \"SECURITY_BANK_ONLINE_BANKING\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"DirectDebitChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Direct Debit Channel Code., must be one of [\"BCA_KLIKPAY\", \"BCA_ONEKLIK\", \"BRI\", \"BNI_AUTOPAY\", \"MANDIRI\", \"BPI\", \"BPI_RECURRING\", \"BDO\", \"CIMBNIAGA\", \"MTB\", \"RCBC\", \"UBP\", \"UBP_EADA\", \"UBP_DEBIT_PULL\", \"CHINABANK\", \"BAY\", \"KTB\", \"BBL\", \"SCB\", \"KBANK_MB\", \"BAY_MB\", \"KTB_MB\", \"BBL_MB\", \"SCB_MB\", \"BDO_EPAY\", \"AFFIN_FPX\", \"AGRO_FPX\", \"ALLIANCE_FPX\", \"AMBANK_FPX\", \"ISLAM_FPX\", \"MUAMALAT_FPX\", \"BOC_FPX\", \"RAKYAT_FPX\", \"BSN_FPX\", \"CIMB_FPX\", \"HLB_FPX\", \"HSBC_FPX\", \"KFH_FPX\", \"MAYB2E_FPX\", \"MAYB2U_FPX\", \"OCBC_FPX\", \"PUBLIC_FPX\", \"RHB_FPX\", \"SCH_FPX\", \"UOB_FPX\", \"AFFIN_FPX_BUSINESS\", \"AGRO_FPX_BUSINESS\", \"ALLIANCE_FPX_BUSINESS\", \"AMBANK_FPX_BUSINESS\", \"ISLAM_FPX_BUSINESS\", \"MUAMALAT_FPX_BUSINESS\", \"BNP_FPX_BUSINESS\", \"CIMB_FPX_BUSINESS\", \"CITIBANK_FPX_BUSINESS\", \"DEUTSCHE_FPX_BUSINESS\", \"HLB_FPX_BUSINESS\", \"HSBC_FPX_BUSINESS\", \"RAKYAT_FPX_BUSINESS\", \"KFH_FPX_BUSINESS\", \"MAYB2E_FPX_BUSINESS\", \"OCBC_FPX_BUSINESS\", \"PUBLIC_FPX_BUSINESS\", \"RHB_FPX_BUSINESS\", \"SCH_FPX_BUSINESS\", \"UOB_FPX_BUSINESS\", \"BDO_ONLINE_BANKING\", \"BPI_ONLINE_BANKING\", \"UNIONBANK_ONLINE_BANKING\", \"BOC_ONLINE_BANKING\", \"CHINABANK_ONLINE_BANKING\", \"INSTAPAY_ONLINE_BANKING\", \"LANDBANK_ONLINE_BANKING\", \"MAYBANK_ONLINE_BANKING\", \"METROBANK_ONLINE_BANKING\", \"PNB_ONLINE_BANKING\", \"PSBANK_ONLINE_BANKING\", \"PESONET_ONLINE_BANKING\", \"RCBC_ONLINE_BANKING\", \"ROBINSONS_BANK_ONLINE_BANKING\", \"SECURITY_BANK_ONLINE_BANKING\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Direct Debit Channel Code., must be one of [\"BCA_KLIKPAY\", \"BCA_ONEKLIK\", \"BRI\", \"BNI_AUTOPAY\", \"MANDIRI\", \"BPI\", \"BPI_RECURRING\", \"BDO\", \"CIMBNIAGA\", \"MTB\", \"RCBC\", \"UBP\", \"UBP_EADA\", \"UBP_DEBIT_PULL\", \"CHINABANK\", \"BAY\", \"KTB\", \"BBL\", \"SCB\", \"KBANK_MB\", \"BAY_MB\", \"KTB_MB\", \"BBL_MB\", \"SCB_MB\", \"BDO_EPAY\", \"AFFIN_FPX\", \"AGRO_FPX\", \"ALLIANCE_FPX\", \"AMBANK_FPX\", \"ISLAM_FPX\", \"MUAMALAT_FPX\", \"BOC_FPX\", \"RAKYAT_FPX\", \"BSN_FPX\", \"CIMB_FPX\", \"HLB_FPX\", \"HSBC_FPX\", \"KFH_FPX\", \"MAYB2E_FPX\", \"MAYB2U_FPX\", \"OCBC_FPX\", \"PUBLIC_FPX\", \"RHB_FPX\", \"SCH_FPX\", \"UOB_FPX\", \"AFFIN_FPX_BUSINESS\", \"AGRO_FPX_BUSINESS\", \"ALLIANCE_FPX_BUSINESS\", \"AMBANK_FPX_BUSINESS\", \"ISLAM_FPX_BUSINESS\", \"MUAMALAT_FPX_BUSINESS\", \"BNP_FPX_BUSINESS\", \"CIMB_FPX_BUSINESS\", \"CITIBANK_FPX_BUSINESS\", \"DEUTSCHE_FPX_BUSINESS\", \"HLB_FPX_BUSINESS\", \"HSBC_FPX_BUSINESS\", \"RAKYAT_FPX_BUSINESS\", \"KFH_FPX_BUSINESS\", \"MAYB2E_FPX_BUSINESS\", \"OCBC_FPX_BUSINESS\", \"PUBLIC_FPX_BUSINESS\", \"RHB_FPX_BUSINESS\", \"SCH_FPX_BUSINESS\", \"UOB_FPX_BUSINESS\", \"BDO_ONLINE_BANKING\", \"BPI_ONLINE_BANKING\", \"UNIONBANK_ONLINE_BANKING\", \"BOC_ONLINE_BANKING\", \"CHINABANK_ONLINE_BANKING\", \"INSTAPAY_ONLINE_BANKING\", \"LANDBANK_ONLINE_BANKING\", \"MAYBANK_ONLINE_BANKING\", \"METROBANK_ONLINE_BANKING\", \"PNB_ONLINE_BANKING\", \"PSBANK_ONLINE_BANKING\", \"PESONET_ONLINE_BANKING\", \"RCBC_ONLINE_BANKING\", \"ROBINSONS_BANK_ONLINE_BANKING\", \"SECURITY_BANK_ONLINE_BANKING\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      154,
      160,
      221,
      223,
      224,
      225,
      226,
      227,
      229,
      235,
      236,
      237,
      238,
      240,
      241,
      242,
      243,
      244,
      245,
      247,
      256,
      257,
      258,
      259,
      260,
      261,
      262,
      263,
      264,
      317,
      319,
      321,
      322,
      323,
      324,
      325,
      327,
      333,
      334,
      335,
      336,
      338,
      339,
      340,
      341,
      342,
      343,
      345,
      354,
      355,
      356,
      357,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      374
    ]
  },
  {
    "file_path": "xendit/payment_request/model/direct_debit_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.direct_debit_channel_properties_bank_account import DirectDebitChannelPropertiesBankAccount\nfrom xendit.payment_request.model.direct_debit_channel_properties_bank_redirect import DirectDebitChannelPropertiesBankRedirect\nfrom xendit.payment_request.model.direct_debit_channel_properties_debit_card import DirectDebitChannelPropertiesDebitCard\nglobals()['DirectDebitChannelPropertiesBankAccount'] = DirectDebitChannelPropertiesBankAccount\nglobals()['DirectDebitChannelPropertiesBankRedirect'] = DirectDebitChannelPropertiesBankRedirect\nglobals()['DirectDebitChannelPropertiesDebitCard'] = DirectDebitChannelPropertiesDebitCard\n\ndef lazy_import():\n    pass\n\nclass DirectDebitChannelProperties(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'email': (str, none_type),  # noqa: E501\n            'mobile_number': (str, none_type),  # noqa: E501\n            'success_return_url': (str, none_type),  # noqa: E501\n            'failure_return_url': (str, none_type),  # noqa: E501\n            'identity_document_number': (str, none_type),  # noqa: E501\n            'account_number': (str, none_type),  # noqa: E501\n            'card_last_four': (str, none_type),  # noqa: E501\n            'card_expiry': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'email': 'email',  # noqa: E501\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'success_return_url': 'success_return_url',  # noqa: E501\n        'failure_return_url': 'failure_return_url',  # noqa: E501\n        'identity_document_number': 'identity_document_number',  # noqa: E501\n        'account_number': 'account_number',  # noqa: E501\n        'card_last_four': 'card_last_four',  # noqa: E501\n        'card_expiry': 'card_expiry',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            email (str): Email address of the customer that is registered to the partner channel. [optional]  # noqa: E501\n            mobile_number (str): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            success_return_url (str): [optional]  # noqa: E501\n            failure_return_url (str): [optional]  # noqa: E501\n            identity_document_number (str): [optional]  # noqa: E501\n            account_number (str): [optional]  # noqa: E501\n            card_last_four (str): Last four digits of the debit card. [optional]  # noqa: E501\n            card_expiry (str): Expiry month and year of the debit card (in MM/YY format). [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            email (str): Email address of the customer that is registered to the partner channel. [optional]  # noqa: E501\n            mobile_number (str): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            success_return_url (str): [optional]  # noqa: E501\n            failure_return_url (str): [optional]  # noqa: E501\n            identity_document_number (str): [optional]  # noqa: E501\n            account_number (str): [optional]  # noqa: E501\n            card_last_four (str): Last four digits of the debit card. [optional]  # noqa: E501\n            card_expiry (str): Expiry month and year of the debit card (in MM/YY format). [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n              DirectDebitChannelPropertiesBankAccount,\n              DirectDebitChannelPropertiesBankRedirect,\n              DirectDebitChannelPropertiesDebitCard,\n          ],\n          'allOf': [\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      73,
      74,
      88,
      89,
      102,
      165,
      166,
      167,
      168,
      169,
      171,
      173,
      174,
      175,
      176,
      177,
      178,
      180,
      189,
      190,
      191,
      192,
      193,
      194,
      196,
      203,
      205,
      206,
      207,
      208,
      210,
      211,
      216,
      217,
      219,
      278,
      279,
      280,
      281,
      282,
      284,
      285,
      286,
      287,
      288,
      289,
      291,
      300,
      301,
      302,
      303,
      304,
      305,
      307,
      314,
      316,
      317,
      318,
      319,
      321,
      322,
      327,
      328,
      329,
      330,
      342,
      343
    ]
  },
  {
    "file_path": "xendit/payment_request/model/direct_debit_channel_properties_bank_account.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitChannelPropertiesBankAccount(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'success_return_url': (str, none_type),  # noqa: E501\n            'failure_return_url': (str, none_type),  # noqa: E501\n            'mobile_number': (str, none_type),  # noqa: E501\n            'identity_document_number': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'success_return_url': 'success_return_url',  # noqa: E501\n        'failure_return_url': 'failure_return_url',  # noqa: E501\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'identity_document_number': 'identity_document_number',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitChannelPropertiesBankAccount - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): [optional]  # noqa: E501\n            failure_return_url (str): [optional]  # noqa: E501\n            mobile_number (str): [optional]  # noqa: E501\n            identity_document_number (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        success_return_url: str | None = None,\n        failure_return_url: str | None = None,\n        mobile_number: str | None = None,\n        identity_document_number: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitChannelPropertiesBankAccount - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): [optional]  # noqa: E501\n            failure_return_url (str): [optional]  # noqa: E501\n            mobile_number (str): [optional]  # noqa: E501\n            identity_document_number (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if success_return_url is not None:\n            self.success_return_url = success_return_url\n        if failure_return_url is not None:\n            self.failure_return_url = failure_return_url\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if identity_document_number is not None:\n            self.identity_document_number = identity_document_number\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      90,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      184,
      185,
      186,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      288,
      289,
      290,
      291
    ]
  },
  {
    "file_path": "xendit/payment_request/model/direct_debit_channel_properties_bank_redirect.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitChannelPropertiesBankRedirect(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'email': (str, none_type),  # noqa: E501\n            'mobile_number': (str, none_type),  # noqa: E501\n            'success_return_url': (str, none_type),  # noqa: E501\n            'failure_return_url': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'email': 'email',  # noqa: E501\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'success_return_url': 'success_return_url',  # noqa: E501\n        'failure_return_url': 'failure_return_url',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitChannelPropertiesBankRedirect - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            email (str): [optional]  # noqa: E501\n            mobile_number (str): Mobile number of the customer that is registered to channel. [optional]  # noqa: E501\n            success_return_url (str): [optional]  # noqa: E501\n            failure_return_url (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        email: str | None = None,\n        mobile_number: str | None = None,\n        success_return_url: str | None = None,\n        failure_return_url: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitChannelPropertiesBankRedirect - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            email (str): [optional]  # noqa: E501\n            mobile_number (str): Mobile number of the customer that is registered to channel. [optional]  # noqa: E501\n            success_return_url (str): [optional]  # noqa: E501\n            failure_return_url (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if email is not None:\n            self.email = email\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if success_return_url is not None:\n            self.success_return_url = success_return_url\n        if failure_return_url is not None:\n            self.failure_return_url = failure_return_url\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      90,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      184,
      185,
      186,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      288,
      289,
      290,
      291
    ]
  },
  {
    "file_path": "xendit/payment_request/model/direct_debit_channel_properties_debit_card.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitChannelPropertiesDebitCard(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'mobile_number': (str, none_type),  # noqa: E501\n            'account_number': (str, none_type),  # noqa: E501\n            'card_last_four': (str, none_type),  # noqa: E501\n            'card_expiry': (str, none_type),  # noqa: E501\n            'email': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'account_number': 'account_number',  # noqa: E501\n        'card_last_four': 'card_last_four',  # noqa: E501\n        'card_expiry': 'card_expiry',  # noqa: E501\n        'email': 'email',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitChannelPropertiesDebitCard - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            mobile_number (str): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            account_number (str): [optional]  # noqa: E501\n            card_last_four (str): Last four digits of the debit card. [optional]  # noqa: E501\n            card_expiry (str): Expiry month and year of the debit card (in MM/YY format). [optional]  # noqa: E501\n            email (str): Email address of the customer that is registered to the partner channel. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        mobile_number: str | None = None,\n        account_number: str | None = None,\n        card_last_four: str | None = None,\n        card_expiry: str | None = None,\n        email: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitChannelPropertiesDebitCard - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            mobile_number (str): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            account_number (str): [optional]  # noqa: E501\n            card_last_four (str): Last four digits of the debit card. [optional]  # noqa: E501\n            card_expiry (str): Expiry month and year of the debit card (in MM/YY format). [optional]  # noqa: E501\n            email (str): Email address of the customer that is registered to the partner channel. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if account_number is not None:\n            self.account_number = account_number\n        if card_last_four is not None:\n            self.card_last_four = card_last_four\n        if card_expiry is not None:\n            self.card_expiry = card_expiry\n        if email is not None:\n            self.email = email\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      91,
      150,
      151,
      152,
      153,
      154,
      156,
      158,
      159,
      160,
      161,
      162,
      163,
      165,
      174,
      175,
      176,
      177,
      178,
      179,
      181,
      182,
      187,
      188,
      189,
      250,
      251,
      252,
      253,
      254,
      256,
      257,
      258,
      259,
      260,
      261,
      263,
      272,
      273,
      274,
      275,
      276,
      277,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      295,
      296,
      297,
      298
    ]
  },
  {
    "file_path": "xendit/payment_request/model/direct_debit_debit_card.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitDebitCard(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'mobile_number': (str, none_type, none_type),  # noqa: E501\n            'account_number': (str, none_type),  # noqa: E501\n            'card_last_four': (str, none_type, none_type),  # noqa: E501\n            'card_expiry': (str, none_type, none_type),  # noqa: E501\n            'email': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'account_number': 'account_number',  # noqa: E501\n        'card_last_four': 'card_last_four',  # noqa: E501\n        'card_expiry': 'card_expiry',  # noqa: E501\n        'email': 'email',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitDebitCard - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            mobile_number (str, none_type): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            account_number (str): [optional]  # noqa: E501\n            card_last_four (str, none_type): Last four digits of the debit card. [optional]  # noqa: E501\n            card_expiry (str, none_type): Expiry month and year of the debit card (in MM/YY format). [optional]  # noqa: E501\n            email (str, none_type): Email address of the customer that is registered to the partner channel. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        mobile_number: str | None = None,\n        account_number: str | None = None,\n        card_last_four: str | None = None,\n        card_expiry: str | None = None,\n        email: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitDebitCard - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            mobile_number (str, none_type): Mobile number of the customer registered to the partner channel. [optional]  # noqa: E501\n            account_number (str): [optional]  # noqa: E501\n            card_last_four (str, none_type): Last four digits of the debit card. [optional]  # noqa: E501\n            card_expiry (str, none_type): Expiry month and year of the debit card (in MM/YY format). [optional]  # noqa: E501\n            email (str, none_type): Email address of the customer that is registered to the partner channel. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if account_number is not None:\n            self.account_number = account_number\n        if card_last_four is not None:\n            self.card_last_four = card_last_four\n        if card_expiry is not None:\n            self.card_expiry = card_expiry\n        if email is not None:\n            self.email = email\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      91,
      150,
      151,
      152,
      153,
      154,
      156,
      158,
      159,
      160,
      161,
      162,
      163,
      165,
      174,
      175,
      176,
      177,
      178,
      179,
      181,
      182,
      187,
      188,
      189,
      250,
      251,
      252,
      253,
      254,
      256,
      257,
      258,
      259,
      260,
      261,
      263,
      272,
      273,
      274,
      275,
      276,
      277,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      295,
      296,
      297,
      298
    ]
  },
  {
    "file_path": "xendit/payment_request/model/direct_debit_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.direct_debit_channel_code import DirectDebitChannelCode\nfrom xendit.payment_request.model.direct_debit_channel_properties import DirectDebitChannelProperties\nfrom xendit.payment_request.model.direct_debit_type import DirectDebitType\nglobals()['DirectDebitChannelCode'] = DirectDebitChannelCode\nglobals()['DirectDebitChannelProperties'] = DirectDebitChannelProperties\nglobals()['DirectDebitType'] = DirectDebitType\n\ndef lazy_import():\n    pass\n\nclass DirectDebitParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (DirectDebitChannelCode,),  # noqa: E501\n            'channel_properties': (DirectDebitChannelProperties,),  # noqa: E501\n            'type': (DirectDebitType, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'type': 'type',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, channel_code, channel_properties, *args, **kwargs):  # noqa: E501\n        \"\"\"DirectDebitParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (DirectDebitChannelCode):\n            channel_properties (DirectDebitChannelProperties):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            type (DirectDebitType): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_code: DirectDebitChannelCode,\n        channel_properties: DirectDebitChannelProperties | None,\n        type: DirectDebitType | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DirectDebitParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (DirectDebitChannelCode):\n            channel_properties (DirectDebitChannelProperties):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            type (DirectDebitType): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        if type is not None:\n            self.type = type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      73,
      74,
      88,
      89,
      97,
      154,
      155,
      156,
      157,
      158,
      160,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      178,
      179,
      180,
      181,
      182,
      183,
      185,
      186,
      187,
      188,
      193,
      194,
      195,
      254,
      255,
      256,
      257,
      258,
      260,
      261,
      262,
      263,
      264,
      265,
      267,
      276,
      277,
      278,
      279,
      280,
      281,
      283,
      284,
      285,
      286,
      287,
      288,
      293,
      294,
      295,
      296
    ]
  },
  {
    "file_path": "xendit/payment_request/model/direct_debit_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass DirectDebitType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'DEBIT_CARD': \"DEBIT_CARD\",\n            'BANK_ACCOUNT': \"BANK_ACCOUNT\",\n            'BANK_REDIRECT': \"BANK_REDIRECT\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"DirectDebitType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"DEBIT_CARD\", \"BANK_ACCOUNT\", \"BANK_REDIRECT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"DEBIT_CARD\", \"BANK_ACCOUNT\", \"BANK_REDIRECT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"DirectDebitType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"DEBIT_CARD\", \"BANK_ACCOUNT\", \"BANK_REDIRECT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"DEBIT_CARD\", \"BANK_ACCOUNT\", \"BANK_REDIRECT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      77,
      83,
      144,
      146,
      147,
      148,
      149,
      150,
      152,
      158,
      159,
      160,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      240,
      242,
      244,
      245,
      246,
      247,
      248,
      250,
      256,
      257,
      258,
      259,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      297
    ]
  },
  {
    "file_path": "xendit/payment_request/model/e_wallet.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.e_wallet_account import EWalletAccount\nfrom xendit.payment_request.model.e_wallet_all_of import EWalletAllOf\nfrom xendit.payment_request.model.e_wallet_channel_code import EWalletChannelCode\nfrom xendit.payment_request.model.e_wallet_channel_properties import EWalletChannelProperties\nfrom xendit.payment_request.model.e_wallet_parameters import EWalletParameters\nglobals()['EWalletAccount'] = EWalletAccount\nglobals()['EWalletAllOf'] = EWalletAllOf\nglobals()['EWalletChannelCode'] = EWalletChannelCode\nglobals()['EWalletChannelProperties'] = EWalletChannelProperties\nglobals()['EWalletParameters'] = EWalletParameters\n\ndef lazy_import():\n    pass\n\nclass EWallet(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (EWalletChannelCode, none_type),  # noqa: E501\n            'channel_properties': (EWalletChannelProperties, none_type),  # noqa: E501\n            'account': (EWalletAccount, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'account': 'account',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"EWallet - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (EWalletChannelCode): [optional]  # noqa: E501\n            channel_properties (EWalletChannelProperties): [optional]  # noqa: E501\n            account (EWalletAccount): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"EWallet - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (EWalletChannelCode): [optional]  # noqa: E501\n            channel_properties (EWalletChannelProperties): [optional]  # noqa: E501\n            account (EWalletAccount): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              EWalletAllOf,\n              EWalletParameters,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      77,
      78,
      92,
      93,
      101,
      154,
      155,
      156,
      157,
      158,
      160,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      178,
      179,
      180,
      181,
      182,
      183,
      185,
      192,
      194,
      195,
      196,
      197,
      199,
      200,
      205,
      206,
      208,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      275,
      284,
      285,
      286,
      287,
      288,
      289,
      291,
      298,
      300,
      301,
      302,
      303,
      305,
      306,
      311,
      312,
      313,
      314,
      326,
      327
    ]
  },
  {
    "file_path": "xendit/payment_request/model/e_wallet_account.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass EWalletAccount(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'name': (str, none_type, none_type),  # noqa: E501\n            'account_details': (str, none_type, none_type),  # noqa: E501\n            'balance': (float, none_type, none_type),  # noqa: E501\n            'point_balance': (float, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'name': 'name',  # noqa: E501\n        'account_details': 'account_details',  # noqa: E501\n        'balance': 'balance',  # noqa: E501\n        'point_balance': 'point_balance',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"EWalletAccount - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            name (str, none_type): Name of the eWallet account holder. The value is null if unavailableName of the eWallet account holder. The value is null if unavailable. [optional]  # noqa: E501\n            account_details (str, none_type): Identifier from eWallet provider e.g. phone number. The value is null if unavailable. [optional]  # noqa: E501\n            balance (float, none_type): The main balance amount on eWallet account provided from eWallet provider. The value is null if unavailable. [optional]  # noqa: E501\n            point_balance (float, none_type): The point balance amount on eWallet account. Applicable only on some eWallet provider that has point system. The value is null if unavailabl. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        name: str | None = None,\n        account_details: str | None = None,\n        balance: float | None = None,\n        point_balance: float | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"EWalletAccount - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            name (str, none_type): Name of the eWallet account holder. The value is null if unavailableName of the eWallet account holder. The value is null if unavailable. [optional]  # noqa: E501\n            account_details (str, none_type): Identifier from eWallet provider e.g. phone number. The value is null if unavailable. [optional]  # noqa: E501\n            balance (float, none_type): The main balance amount on eWallet account provided from eWallet provider. The value is null if unavailable. [optional]  # noqa: E501\n            point_balance (float, none_type): The point balance amount on eWallet account. Applicable only on some eWallet provider that has point system. The value is null if unavailabl. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if name is not None:\n            self.name = name\n        if account_details is not None:\n            self.account_details = account_details\n        if balance is not None:\n            self.balance = balance\n        if point_balance is not None:\n            self.point_balance = point_balance\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      90,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      184,
      185,
      186,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      288,
      289,
      290,
      291
    ]
  },
  {
    "file_path": "xendit/payment_request/model/e_wallet_all_of.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.e_wallet_account import EWalletAccount\nglobals()['EWalletAccount'] = EWalletAccount\n\ndef lazy_import():\n    pass\n\nclass EWalletAllOf(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'account': (EWalletAccount, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'account': 'account',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"EWalletAllOf - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account (EWalletAccount): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        account: EWalletAccount | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"EWalletAllOf - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account (EWalletAccount): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if account is not None:\n            self.account = account\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      91,
      142,
      143,
      144,
      145,
      146,
      148,
      150,
      151,
      152,
      153,
      154,
      155,
      157,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      174,
      179,
      180,
      181,
      234,
      235,
      236,
      237,
      238,
      240,
      241,
      242,
      243,
      244,
      245,
      247,
      256,
      257,
      258,
      259,
      260,
      261,
      263,
      264,
      265,
      266,
      271,
      272,
      273,
      274
    ]
  },
  {
    "file_path": "xendit/payment_request/model/e_wallet_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass EWalletChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'GCASH': \"GCASH\",\n            'GRABPAY': \"GRABPAY\",\n            'PAYMAYA': \"PAYMAYA\",\n            'DANA': \"DANA\",\n            'OVO': \"OVO\",\n            'LINKAJA': \"LINKAJA\",\n            'SHOPEEPAY': \"SHOPEEPAY\",\n            'NEXCASH': \"NEXCASH\",\n            'ASTRAPAY': \"ASTRAPAY\",\n            'JENIUSPAY': \"JENIUSPAY\",\n            'APPOTA': \"APPOTA\",\n            'MOMO': \"MOMO\",\n            'VNPTWALLET': \"VNPTWALLET\",\n            'VIETTELPAY': \"VIETTELPAY\",\n            'ZALOPAY': \"ZALOPAY\",\n            'WECHATPAY': \"WECHATPAY\",\n            'LINEPAY': \"LINEPAY\",\n            'TRUEMONEY': \"TRUEMONEY\",\n            'ALIPAY': \"ALIPAY\",\n            'TOUCHNGO': \"TOUCHNGO\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"EWalletChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Ewallet Channel Code., must be one of [\"GCASH\", \"GRABPAY\", \"PAYMAYA\", \"DANA\", \"OVO\", \"LINKAJA\", \"SHOPEEPAY\", \"NEXCASH\", \"ASTRAPAY\", \"JENIUSPAY\", \"APPOTA\", \"MOMO\", \"VNPTWALLET\", \"VIETTELPAY\", \"ZALOPAY\", \"WECHATPAY\", \"LINEPAY\", \"TRUEMONEY\", \"ALIPAY\", \"TOUCHNGO\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Ewallet Channel Code., must be one of [\"GCASH\", \"GRABPAY\", \"PAYMAYA\", \"DANA\", \"OVO\", \"LINKAJA\", \"SHOPEEPAY\", \"NEXCASH\", \"ASTRAPAY\", \"JENIUSPAY\", \"APPOTA\", \"MOMO\", \"VNPTWALLET\", \"VIETTELPAY\", \"ZALOPAY\", \"WECHATPAY\", \"LINEPAY\", \"TRUEMONEY\", \"ALIPAY\", \"TOUCHNGO\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"EWalletChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Ewallet Channel Code., must be one of [\"GCASH\", \"GRABPAY\", \"PAYMAYA\", \"DANA\", \"OVO\", \"LINKAJA\", \"SHOPEEPAY\", \"NEXCASH\", \"ASTRAPAY\", \"JENIUSPAY\", \"APPOTA\", \"MOMO\", \"VNPTWALLET\", \"VIETTELPAY\", \"ZALOPAY\", \"WECHATPAY\", \"LINEPAY\", \"TRUEMONEY\", \"ALIPAY\", \"TOUCHNGO\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Ewallet Channel Code., must be one of [\"GCASH\", \"GRABPAY\", \"PAYMAYA\", \"DANA\", \"OVO\", \"LINKAJA\", \"SHOPEEPAY\", \"NEXCASH\", \"ASTRAPAY\", \"JENIUSPAY\", \"APPOTA\", \"MOMO\", \"VNPTWALLET\", \"VIETTELPAY\", \"ZALOPAY\", \"WECHATPAY\", \"LINEPAY\", \"TRUEMONEY\", \"ALIPAY\", \"TOUCHNGO\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      94,
      100,
      161,
      163,
      164,
      165,
      166,
      167,
      169,
      175,
      176,
      177,
      178,
      180,
      181,
      182,
      183,
      184,
      185,
      187,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      257,
      259,
      261,
      262,
      263,
      264,
      265,
      267,
      273,
      274,
      275,
      276,
      278,
      279,
      280,
      281,
      282,
      283,
      285,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      305,
      314
    ]
  },
  {
    "file_path": "xendit/payment_request/model/e_wallet_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass EWalletChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('success_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('pending_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('failure_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('cancel_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'success_return_url': (str, none_type),  # noqa: E501\n            'pending_return_url': (str, none_type),  # noqa: E501\n            'failure_return_url': (str, none_type),  # noqa: E501\n            'cancel_return_url': (str, none_type),  # noqa: E501\n            'redeem_points': (str, none_type),  # noqa: E501\n            'mobile_number': (str, none_type),  # noqa: E501\n            'cashtag': (str, none_type),  # noqa: E501\n            'promotion_label': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'success_return_url': 'success_return_url',  # noqa: E501\n        'pending_return_url': 'pending_return_url',  # noqa: E501\n        'failure_return_url': 'failure_return_url',  # noqa: E501\n        'cancel_return_url': 'cancel_return_url',  # noqa: E501\n        'redeem_points': 'redeem_points',  # noqa: E501\n        'mobile_number': 'mobile_number',  # noqa: E501\n        'cashtag': 'cashtag',  # noqa: E501\n        'promotion_label': 'promotion_label',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"EWalletChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            pending_return_url (str): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            cancel_return_url (str): URL where the end-customer is redirected if the authorization cancelled. [optional]  # noqa: E501\n            redeem_points (str): REDEEM_NONE will not use any point, REDEEM_ALL will use all available points before cash balance is used. For OVO and ShopeePay tokenized payment use only.. [optional]  # noqa: E501\n            mobile_number (str): [optional]  # noqa: E501\n            cashtag (str): [optional]  # noqa: E501\n            promotion_label (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        success_return_url: str | None = None,\n        pending_return_url: str | None = None,\n        failure_return_url: str | None = None,\n        cancel_return_url: str | None = None,\n        redeem_points: str | None = None,\n        mobile_number: str | None = None,\n        cashtag: str | None = None,\n        promotion_label: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"EWalletChannelProperties - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            pending_return_url (str): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            cancel_return_url (str): URL where the end-customer is redirected if the authorization cancelled. [optional]  # noqa: E501\n            redeem_points (str): REDEEM_NONE will not use any point, REDEEM_ALL will use all available points before cash balance is used. For OVO and ShopeePay tokenized payment use only.. [optional]  # noqa: E501\n            mobile_number (str): [optional]  # noqa: E501\n            cashtag (str): [optional]  # noqa: E501\n            promotion_label (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if success_return_url is not None:\n            self.success_return_url = success_return_url\n        if pending_return_url is not None:\n            self.pending_return_url = pending_return_url\n        if failure_return_url is not None:\n            self.failure_return_url = failure_return_url\n        if cancel_return_url is not None:\n            self.cancel_return_url = cancel_return_url\n        if redeem_points is not None:\n            self.redeem_points = redeem_points\n        if mobile_number is not None:\n            self.mobile_number = mobile_number\n        if cashtag is not None:\n            self.cashtag = cashtag\n        if promotion_label is not None:\n            self.promotion_label = promotion_label\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      87,
      101,
      114,
      179,
      180,
      181,
      182,
      183,
      185,
      187,
      188,
      189,
      190,
      191,
      192,
      194,
      203,
      204,
      205,
      206,
      207,
      208,
      210,
      211,
      216,
      217,
      218,
      285,
      286,
      287,
      288,
      289,
      291,
      292,
      293,
      294,
      295,
      296,
      298,
      307,
      308,
      309,
      310,
      311,
      312,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      322,
      323,
      324,
      325,
      326,
      327,
      328,
      329,
      330,
      331,
      336,
      337,
      338,
      339
    ]
  },
  {
    "file_path": "xendit/payment_request/model/e_wallet_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.e_wallet_channel_code import EWalletChannelCode\nfrom xendit.payment_request.model.e_wallet_channel_properties import EWalletChannelProperties\nglobals()['EWalletChannelCode'] = EWalletChannelCode\nglobals()['EWalletChannelProperties'] = EWalletChannelProperties\n\ndef lazy_import():\n    pass\n\nclass EWalletParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (EWalletChannelCode, none_type),  # noqa: E501\n            'channel_properties': (EWalletChannelProperties, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"EWalletParameters - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (EWalletChannelCode): [optional]  # noqa: E501\n            channel_properties (EWalletChannelProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_code: EWalletChannelCode | None = None,\n        channel_properties: EWalletChannelProperties | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"EWalletParameters - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (EWalletChannelCode): [optional]  # noqa: E501\n            channel_properties (EWalletChannelProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if channel_code is not None:\n            self.channel_code = channel_code\n        if channel_properties is not None:\n            self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      86,
      87,
      94,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      184,
      185,
      186,
      241,
      242,
      243,
      244,
      245,
      247,
      248,
      249,
      250,
      251,
      252,
      254,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      271,
      272,
      273,
      274,
      275,
      280,
      281,
      282,
      283
    ]
  },
  {
    "file_path": "xendit/payment_request/model/error.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass Error(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'None': None,\n            'ACCOUNT_ACCESS_BLOCKED': \"ACCOUNT_ACCESS_BLOCKED\",\n            'ADDRESS_VALIDATION_FAILED': \"ADDRESS_VALIDATION_FAILED\",\n            'AMOUNT_MISMATCHED': \"AMOUNT_MISMATCHED\",\n            'API_VALIDATION_ERROR': \"API_VALIDATION_ERROR\",\n            'AUTHENTICATION_FAILED': \"AUTHENTICATION_FAILED\",\n            'AUTHENTICATION_REQUIRED': \"AUTHENTICATION_REQUIRED\",\n            'CARD_DECLINED': \"CARD_DECLINED\",\n            'CHANNEL_CODE_NOT_SUPPORTED_ERROR': \"CHANNEL_CODE_NOT_SUPPORTED_ERROR\",\n            'CHANNEL_NOT_ACTIVATED': \"CHANNEL_NOT_ACTIVATED\",\n            'CHANNEL_UNAVAILABLE': \"CHANNEL_UNAVAILABLE\",\n            'COF_COMBINATION_NOT_ALLOWED_ERROR': \"COF_COMBINATION_NOT_ALLOWED_ERROR\",\n            'CURRENCY_MISMATCHED': \"CURRENCY_MISMATCHED\",\n            'CUSTOMER_NOT_FOUND_ERROR': \"CUSTOMER_NOT_FOUND_ERROR\",\n            'CUSTOMER_PAYMENT_METHOD_MISMATCHED': \"CUSTOMER_PAYMENT_METHOD_MISMATCHED\",\n            'DATA_NOT_FOUND': \"DATA_NOT_FOUND\",\n            'DATA_NOT_FOUND_ERROR': \"DATA_NOT_FOUND_ERROR\",\n            'DECLINED_BY_ISSUER': \"DECLINED_BY_ISSUER\",\n            'DECLINED_BY_PROCESSOR': \"DECLINED_BY_PROCESSOR\",\n            'DENIED_PERSON_LIST_MATCHED': \"DENIED_PERSON_LIST_MATCHED\",\n            'DUPLICATE_ERROR': \"DUPLICATE_ERROR\",\n            'DUPLICATE_REFERENCE': \"DUPLICATE_REFERENCE\",\n            'EXCEEDS_CAPTURABLE_AMOUNT': \"EXCEEDS_CAPTURABLE_AMOUNT\",\n            'EXPIRED_CARD': \"EXPIRED_CARD\",\n            'EXPIRED_OTP_ERROR': \"EXPIRED_OTP_ERROR\",\n            'FEATURE_NOT_ACTIVATED': \"FEATURE_NOT_ACTIVATED\",\n            'IDEMPOTENCY_ERROR': \"IDEMPOTENCY_ERROR\",\n            'INACTIVE_OR_UNAUTHORIZED_CARD': \"INACTIVE_OR_UNAUTHORIZED_CARD\",\n            'INSUFFICIENT_BALANCE': \"INSUFFICIENT_BALANCE\",\n            'INVALID_ACCOUNT_DETAILS': \"INVALID_ACCOUNT_DETAILS\",\n            'INVALID_CVV': \"INVALID_CVV\",\n            'INVALID_OTP_ERROR': \"INVALID_OTP_ERROR\",\n            'INVALID_PAYMENT_METHOD': \"INVALID_PAYMENT_METHOD\",\n            'ISSUER_UNAVAILABLE': \"ISSUER_UNAVAILABLE\",\n            'MANUAL_CAPTURE_NOT_SUPPORTED': \"MANUAL_CAPTURE_NOT_SUPPORTED\",\n            'MAX_ACCOUNT_LINKING': \"MAX_ACCOUNT_LINKING\",\n            'MAX_AMOUNT_LIMIT_ERROR': \"MAX_AMOUNT_LIMIT_ERROR\",\n            'MAX_OTP_ATTEMPTS_ERROR': \"MAX_OTP_ATTEMPTS_ERROR\",\n            'OPERATION_NOT_ALLOWED': \"OPERATION_NOT_ALLOWED\",\n            'OTP_DELIVERY_ERROR': \"OTP_DELIVERY_ERROR\",\n            'PAYMENT_METHOD_NOT_FOUND_ERROR': \"PAYMENT_METHOD_NOT_FOUND_ERROR\",\n            'PAYMENT_REQUEST_ALREADY_COMPLETED': \"PAYMENT_REQUEST_ALREADY_COMPLETED\",\n            'PAYMENT_REQUEST_ALREADY_FAILED': \"PAYMENT_REQUEST_ALREADY_FAILED\",\n            'PAYMENT_REQUEST_ALREADY_FULLY_CAPTURED': \"PAYMENT_REQUEST_ALREADY_FULLY_CAPTURED\",\n            'PAYMENT_STATUS_FAILED': \"PAYMENT_STATUS_FAILED\",\n            'PROCESSOR_CONFIGURATION_ERROR': \"PROCESSOR_CONFIGURATION_ERROR\",\n            'PROCESSOR_ERROR': \"PROCESSOR_ERROR\",\n            'PROCESSOR_TEMPORARILY_UNAVAILABLE': \"PROCESSOR_TEMPORARILY_UNAVAILABLE\",\n            'PROCESSOR_TIMEOUT': \"PROCESSOR_TIMEOUT\",\n            'REJECTED_BY_ACQUIRER': \"REJECTED_BY_ACQUIRER\",\n            'SERVER_ERROR': \"SERVER_ERROR\",\n            'STOLEN_CARD': \"STOLEN_CARD\",\n            'STRONG_CUSTOMER_AUTHENTICATION_REQUIRED': \"STRONG_CUSTOMER_AUTHENTICATION_REQUIRED\",\n            'SUSPECTED_FRAUDULENT': \"SUSPECTED_FRAUDULENT\",\n            'UNAUTHORIZED': \"UNAUTHORIZED\",\n            'DUPLICATED_FIXED_PAYMENT_INSTRUMENT': \"DUPLICATED_FIXED_PAYMENT_INSTRUMENT\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type, none_type),  # noqa: E501\n            'message': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"Error - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str, none_type): [optional]  # noqa: E501\n            message (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Error - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str, none_type): [optional]  # noqa: E501\n            message (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      125,
      139,
      146,
      199,
      200,
      201,
      202,
      203,
      205,
      207,
      208,
      209,
      210,
      211,
      212,
      214,
      223,
      224,
      225,
      226,
      227,
      228,
      230,
      231,
      236,
      237,
      238,
      293,
      294,
      295,
      296,
      297,
      299,
      300,
      301,
      302,
      303,
      304,
      306,
      315,
      316,
      317,
      318,
      319,
      320,
      322,
      323,
      324,
      325,
      326,
      327,
      332,
      333,
      334,
      335
    ]
  },
  {
    "file_path": "xendit/payment_request/model/invoice_partner_metadata.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass InvoicePartnerMetadata(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'notes': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'notes': 'notes',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"InvoicePartnerMetadata - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            notes (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        notes: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"InvoicePartnerMetadata - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            notes (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if notes is not None:\n            self.notes = notes\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      87,
      138,
      139,
      140,
      141,
      142,
      144,
      146,
      147,
      148,
      149,
      150,
      151,
      153,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      170,
      175,
      176,
      177,
      230,
      231,
      232,
      233,
      234,
      236,
      237,
      238,
      239,
      240,
      241,
      243,
      252,
      253,
      254,
      255,
      256,
      257,
      259,
      260,
      261,
      262,
      267,
      268,
      269,
      270
    ]
  },
  {
    "file_path": "xendit/payment_request/model/over_the_counter.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.over_the_counter_channel_code import OverTheCounterChannelCode\nfrom xendit.payment_request.model.over_the_counter_channel_properties import OverTheCounterChannelProperties\nfrom xendit.payment_request.model.over_the_counter_parameters import OverTheCounterParameters\nfrom xendit.payment_request.model.payment_request_currency import PaymentRequestCurrency\nglobals()['OverTheCounterChannelCode'] = OverTheCounterChannelCode\nglobals()['OverTheCounterChannelProperties'] = OverTheCounterChannelProperties\nglobals()['OverTheCounterParameters'] = OverTheCounterParameters\nglobals()['PaymentRequestCurrency'] = PaymentRequestCurrency\n\ndef lazy_import():\n    pass\n\nclass OverTheCounter(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (OverTheCounterChannelCode,),  # noqa: E501\n            'channel_properties': (OverTheCounterChannelProperties,),  # noqa: E501\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'currency': (PaymentRequestCurrency, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"OverTheCounter - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (OverTheCounterChannelCode):\n            channel_properties (OverTheCounterChannelProperties):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (PaymentRequestCurrency): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"OverTheCounter - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (OverTheCounterChannelCode):\n            channel_properties (OverTheCounterChannelProperties):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (PaymentRequestCurrency): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              OverTheCounterParameters,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      75,
      76,
      90,
      91,
      100,
      155,
      156,
      157,
      158,
      159,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      186,
      193,
      195,
      196,
      197,
      198,
      200,
      201,
      206,
      207,
      209,
      264,
      265,
      266,
      267,
      268,
      270,
      271,
      272,
      273,
      274,
      275,
      277,
      286,
      287,
      288,
      289,
      290,
      291,
      293,
      300,
      302,
      303,
      304,
      305,
      307,
      308,
      313,
      314,
      315,
      316,
      328,
      329
    ]
  },
  {
    "file_path": "xendit/payment_request/model/over_the_counter_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass OverTheCounterChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            '7ELEVEN': \"7ELEVEN\",\n            '7ELEVEN_CLIQQ': \"7ELEVEN_CLIQQ\",\n            'CEBUANA': \"CEBUANA\",\n            'ECPAY': \"ECPAY\",\n            'PALAWAN': \"PALAWAN\",\n            'MLHUILLIER': \"MLHUILLIER\",\n            'ECPAY_DRAGONLOAN': \"ECPAY_DRAGONLOAN\",\n            'LBC': \"LBC\",\n            'ECPAY_SCHOOL': \"ECPAY_SCHOOL\",\n            'RD_PAWNSHOP': \"RD_PAWNSHOP\",\n            'CVM': \"CVM\",\n            'USSC': \"USSC\",\n            'SM_BILLS': \"SM_BILLS\",\n            'ROBINSONS_BILLS': \"ROBINSONS_BILLS\",\n            'ALFAMART': \"ALFAMART\",\n            'INDOMARET': \"INDOMARET\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"OverTheCounterChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Over The Counter Channel Code., must be one of [\"7ELEVEN\", \"7ELEVEN_CLIQQ\", \"CEBUANA\", \"ECPAY\", \"PALAWAN\", \"MLHUILLIER\", \"ECPAY_DRAGONLOAN\", \"LBC\", \"ECPAY_SCHOOL\", \"RD_PAWNSHOP\", \"CVM\", \"USSC\", \"SM_BILLS\", \"ROBINSONS_BILLS\", \"ALFAMART\", \"INDOMARET\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Over The Counter Channel Code., must be one of [\"7ELEVEN\", \"7ELEVEN_CLIQQ\", \"CEBUANA\", \"ECPAY\", \"PALAWAN\", \"MLHUILLIER\", \"ECPAY_DRAGONLOAN\", \"LBC\", \"ECPAY_SCHOOL\", \"RD_PAWNSHOP\", \"CVM\", \"USSC\", \"SM_BILLS\", \"ROBINSONS_BILLS\", \"ALFAMART\", \"INDOMARET\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"OverTheCounterChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Over The Counter Channel Code., must be one of [\"7ELEVEN\", \"7ELEVEN_CLIQQ\", \"CEBUANA\", \"ECPAY\", \"PALAWAN\", \"MLHUILLIER\", \"ECPAY_DRAGONLOAN\", \"LBC\", \"ECPAY_SCHOOL\", \"RD_PAWNSHOP\", \"CVM\", \"USSC\", \"SM_BILLS\", \"ROBINSONS_BILLS\", \"ALFAMART\", \"INDOMARET\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Over The Counter Channel Code., must be one of [\"7ELEVEN\", \"7ELEVEN_CLIQQ\", \"CEBUANA\", \"ECPAY\", \"PALAWAN\", \"MLHUILLIER\", \"ECPAY_DRAGONLOAN\", \"LBC\", \"ECPAY_SCHOOL\", \"RD_PAWNSHOP\", \"CVM\", \"USSC\", \"SM_BILLS\", \"ROBINSONS_BILLS\", \"ALFAMART\", \"INDOMARET\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      157,
      159,
      160,
      161,
      162,
      163,
      165,
      171,
      172,
      173,
      174,
      176,
      177,
      178,
      179,
      180,
      181,
      183,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      258,
      263,
      275,
      276,
      277,
      278,
      279,
      281,
      298,
      299,
      301
    ]
  },
  {
    "file_path": "xendit/payment_request/model/over_the_counter_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass OverTheCounterChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'customer_name': (str,),  # noqa: E501\n            'payment_code': (str, none_type),  # noqa: E501\n            'expires_at': (datetime, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'customer_name': 'customer_name',  # noqa: E501\n        'payment_code': 'payment_code',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, customer_name, *args, **kwargs):  # noqa: E501\n        \"\"\"OverTheCounterChannelProperties - a model defined in OpenAPI\n\n        Args:\n            customer_name (str): Name of customer.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_code (str): The payment code that you want to assign, e.g 12345. If you do not send one, one will be picked at random.. [optional]  # noqa: E501\n            expires_at (datetime): The time when the payment code will be expired. The minimum is 2 hours and the maximum is 9 days for 7ELEVEN. Default expired date will be 2 days from payment code generated.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.customer_name = customer_name\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        customer_name: str,\n        payment_code: str | None = None,\n        expires_at: datetime | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"OverTheCounterChannelProperties - a model defined in OpenAPI\n\n        Args:\n            customer_name (str): Name of customer.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_code (str): The payment code that you want to assign, e.g 12345. If you do not send one, one will be picked at random.. [optional]  # noqa: E501\n            expires_at (datetime): The time when the payment code will be expired. The minimum is 2 hours and the maximum is 9 days for 7ELEVEN. Default expired date will be 2 days from payment code generated.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.customer_name = customer_name\n        if payment_code is not None:\n            self.payment_code = payment_code\n        if expires_at is not None:\n            self.expires_at = expires_at\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      155,
      156,
      157,
      158,
      159,
      161,
      179,
      184,
      185,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      285,
      286,
      287,
      288
    ]
  },
  {
    "file_path": "xendit/payment_request/model/over_the_counter_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.over_the_counter_channel_code import OverTheCounterChannelCode\nfrom xendit.payment_request.model.over_the_counter_channel_properties import OverTheCounterChannelProperties\nfrom xendit.payment_request.model.payment_request_currency import PaymentRequestCurrency\nglobals()['OverTheCounterChannelCode'] = OverTheCounterChannelCode\nglobals()['OverTheCounterChannelProperties'] = OverTheCounterChannelProperties\nglobals()['PaymentRequestCurrency'] = PaymentRequestCurrency\n\ndef lazy_import():\n    pass\n\nclass OverTheCounterParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (OverTheCounterChannelCode,),  # noqa: E501\n            'channel_properties': (OverTheCounterChannelProperties,),  # noqa: E501\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'currency': (PaymentRequestCurrency, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, channel_code, channel_properties, *args, **kwargs):  # noqa: E501\n        \"\"\"OverTheCounterParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (OverTheCounterChannelCode):\n            channel_properties (OverTheCounterChannelProperties):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (PaymentRequestCurrency): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_code: OverTheCounterChannelCode,\n        channel_properties: OverTheCounterChannelProperties,\n        amount: float | None = None,\n        currency: PaymentRequestCurrency | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"OverTheCounterParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (OverTheCounterChannelCode):\n            channel_properties (OverTheCounterChannelProperties):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (PaymentRequestCurrency): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        if amount is not None:\n            self.amount = amount\n        if currency is not None:\n            self.currency = currency\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      73,
      74,
      166,
      167,
      168,
      169,
      170,
      172,
      191,
      196,
      197,
      259,
      260,
      261,
      262,
      263,
      265,
      266,
      267,
      268,
      269,
      270,
      272,
      281,
      282,
      283,
      284,
      285,
      286,
      288,
      289,
      290,
      291,
      292,
      293,
      294,
      295,
      300,
      301,
      302,
      303
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_callback.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.payment_callback_data import PaymentCallbackData\nglobals()['PaymentCallbackData'] = PaymentCallbackData\n\ndef lazy_import():\n    pass\n\nclass PaymentCallback(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'event': (str,),  # noqa: E501\n            'business_id': (str,),  # noqa: E501\n            'created': (str,),  # noqa: E501\n            'data': (PaymentCallbackData, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'event': 'event',  # noqa: E501\n        'business_id': 'business_id',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'data': 'data',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, event, business_id, created, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentCallback - a model defined in OpenAPI\n\n        Args:\n            event (str): Identifies the event that triggered a notification to the merchant\n            business_id (str): business_id\n            created (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            data (PaymentCallbackData): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.event = event\n        self.business_id = business_id\n        self.created = created\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        event: str,\n        business_id: str,\n        created: str,\n        data: PaymentCallbackData | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentCallback - a model defined in OpenAPI\n\n        Args:\n            event (str): Identifies the event that triggered a notification to the merchant\n            business_id (str): business_id\n            created (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            data (PaymentCallbackData): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.event = event\n        self.business_id = business_id\n        self.created = created\n        if data is not None:\n            self.data = data\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      94,
      153,
      154,
      155,
      156,
      157,
      159,
      161,
      162,
      163,
      164,
      165,
      166,
      168,
      177,
      178,
      179,
      180,
      181,
      182,
      184,
      185,
      186,
      187,
      188,
      193,
      194,
      195,
      256,
      257,
      258,
      259,
      260,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      278,
      279,
      280,
      281,
      282,
      283,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      296,
      297,
      298,
      299
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_callback_data.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.payment_method import PaymentMethod\nfrom xendit.payment_request.model.payment_request_channel_properties import PaymentRequestChannelProperties\nglobals()['PaymentMethod'] = PaymentMethod\nglobals()['PaymentRequestChannelProperties'] = PaymentRequestChannelProperties\n\ndef lazy_import():\n    pass\n\nclass PaymentCallbackData(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'id': (str,),  # noqa: E501\n            'reference_id': (str,),  # noqa: E501\n            'currency': (str,),  # noqa: E501\n            'amount': (float,),  # noqa: E501\n            'country': (str,),  # noqa: E501\n            'status': (str,),  # noqa: E501\n            'payment_method': (PaymentMethod,),  # noqa: E501\n            'created': (str,),  # noqa: E501\n            'updated': (str,),  # noqa: E501\n            'payment_request_id': (str, none_type, none_type),  # noqa: E501\n            'customer_id': (str, none_type, none_type),  # noqa: E501\n            'channel_properties': (PaymentRequestChannelProperties, none_type),  # noqa: E501\n            'payment_detail': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n            'failure_code': (str, none_type, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'id': 'id',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'country': 'country',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'payment_method': 'payment_method',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'payment_request_id': 'payment_request_id',  # noqa: E501\n        'customer_id': 'customer_id',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'payment_detail': 'payment_detail',  # noqa: E501\n        'failure_code': 'failure_code',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, id, reference_id, currency, amount, country, status, payment_method, created, updated, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentCallbackData - a model defined in OpenAPI\n\n        Args:\n            id (str):\n            reference_id (str):\n            currency (str):\n            amount (float):\n            country (str):\n            status (str):\n            payment_method (PaymentMethod):\n            created (str):\n            updated (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_request_id (str, none_type): [optional]  # noqa: E501\n            customer_id (str, none_type): [optional]  # noqa: E501\n            channel_properties (PaymentRequestChannelProperties): [optional]  # noqa: E501\n            payment_detail ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            failure_code (str, none_type): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.reference_id = reference_id\n        self.currency = currency\n        self.amount = amount\n        self.country = country\n        self.status = status\n        self.payment_method = payment_method\n        self.created = created\n        self.updated = updated\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        id: str,\n        reference_id: str,\n        currency: str,\n        amount: float,\n        country: str,\n        status: str,\n        payment_method: PaymentMethod,\n        created: str,\n        updated: str,\n        payment_request_id: str | None = None,\n        customer_id: str | None = None,\n        channel_properties: PaymentRequestChannelProperties | None = None,\n        payment_detail: dict | None = None,\n        failure_code: str | None = None,\n        metadata: dict | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentCallbackData - a model defined in OpenAPI\n\n        Args:\n            id (str):\n            reference_id (str):\n            currency (str):\n            amount (float):\n            country (str):\n            status (str):\n            payment_method (PaymentMethod):\n            created (str):\n            updated (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_request_id (str, none_type): [optional]  # noqa: E501\n            customer_id (str, none_type): [optional]  # noqa: E501\n            channel_properties (PaymentRequestChannelProperties): [optional]  # noqa: E501\n            payment_detail ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            failure_code (str, none_type): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.reference_id = reference_id\n        self.currency = currency\n        self.amount = amount\n        self.country = country\n        self.status = status\n        self.payment_method = payment_method\n        self.created = created\n        self.updated = updated\n        if payment_request_id is not None:\n            self.payment_request_id = payment_request_id\n        if customer_id is not None:\n            self.customer_id = customer_id\n        if channel_properties is not None:\n            self.channel_properties = channel_properties\n        if payment_detail is not None:\n            self.payment_detail = payment_detail\n        if failure_code is not None:\n            self.failure_code = failure_code\n        if metadata is not None:\n            self.metadata = metadata\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      86,
      87,
      107,
      188,
      189,
      190,
      191,
      192,
      194,
      196,
      197,
      198,
      199,
      200,
      201,
      203,
      212,
      213,
      214,
      215,
      216,
      217,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      234,
      235,
      236,
      319,
      320,
      321,
      322,
      323,
      325,
      326,
      327,
      328,
      329,
      330,
      332,
      341,
      342,
      343,
      344,
      345,
      346,
      348,
      349,
      350,
      351,
      352,
      353,
      354,
      355,
      356,
      357,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      368,
      369,
      370,
      375,
      376,
      377,
      378
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_method.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.card import Card\nfrom xendit.payment_request.model.direct_debit import DirectDebit\nfrom xendit.payment_request.model.e_wallet import EWallet\nfrom xendit.payment_request.model.over_the_counter import OverTheCounter\nfrom xendit.payment_request.model.payment_method_reusability import PaymentMethodReusability\nfrom xendit.payment_request.model.payment_method_status import PaymentMethodStatus\nfrom xendit.payment_request.model.payment_method_type import PaymentMethodType\nfrom xendit.payment_request.model.qr_code import QRCode\nfrom xendit.payment_request.model.virtual_account import VirtualAccount\nglobals()['Card'] = Card\nglobals()['DirectDebit'] = DirectDebit\nglobals()['EWallet'] = EWallet\nglobals()['OverTheCounter'] = OverTheCounter\nglobals()['PaymentMethodReusability'] = PaymentMethodReusability\nglobals()['PaymentMethodStatus'] = PaymentMethodStatus\nglobals()['PaymentMethodType'] = PaymentMethodType\nglobals()['QRCode'] = QRCode\nglobals()['VirtualAccount'] = VirtualAccount\n\ndef lazy_import():\n    pass\n\nclass PaymentMethod(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'id': (str,),  # noqa: E501\n            'type': (PaymentMethodType,),  # noqa: E501\n            'reusability': (PaymentMethodReusability,),  # noqa: E501\n            'status': (PaymentMethodStatus,),  # noqa: E501\n            'created': (str, none_type),  # noqa: E501\n            'updated': (str, none_type),  # noqa: E501\n            'description': (str, none_type, none_type),  # noqa: E501\n            'reference_id': (str, none_type),  # noqa: E501\n            'card': (Card, none_type),  # noqa: E501\n            'direct_debit': (DirectDebit, none_type),  # noqa: E501\n            'ewallet': (EWallet, none_type),  # noqa: E501\n            'over_the_counter': (OverTheCounter, none_type),  # noqa: E501\n            'virtual_account': (VirtualAccount, none_type),  # noqa: E501\n            'qr_code': (QRCode, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'id': 'id',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'reusability': 'reusability',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'card': 'card',  # noqa: E501\n        'direct_debit': 'direct_debit',  # noqa: E501\n        'ewallet': 'ewallet',  # noqa: E501\n        'over_the_counter': 'over_the_counter',  # noqa: E501\n        'virtual_account': 'virtual_account',  # noqa: E501\n        'qr_code': 'qr_code',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, id, type, reusability, status, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentMethod - a model defined in OpenAPI\n\n        Args:\n            id (str):\n            type (PaymentMethodType):\n            reusability (PaymentMethodReusability):\n            status (PaymentMethodStatus):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            created (str): [optional]  # noqa: E501\n            updated (str): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            card (Card): [optional]  # noqa: E501\n            direct_debit (DirectDebit): [optional]  # noqa: E501\n            ewallet (EWallet): [optional]  # noqa: E501\n            over_the_counter (OverTheCounter): [optional]  # noqa: E501\n            virtual_account (VirtualAccount): [optional]  # noqa: E501\n            qr_code (QRCode): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.type = type\n        self.reusability = reusability\n        self.status = status\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        id: str,\n        type: PaymentMethodType,\n        reusability: PaymentMethodReusability,\n        status: PaymentMethodStatus,\n        created: str | None = None,\n        updated: str | None = None,\n        description: str | None = None,\n        reference_id: str | None = None,\n        card: Card | None = None,\n        direct_debit: DirectDebit | None = None,\n        ewallet: EWallet | None = None,\n        over_the_counter: OverTheCounter | None = None,\n        virtual_account: VirtualAccount | None = None,\n        qr_code: QRCode | None = None,\n        metadata: dict | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentMethod - a model defined in OpenAPI\n\n        Args:\n            id (str):\n            type (PaymentMethodType):\n            reusability (PaymentMethodReusability):\n            status (PaymentMethodStatus):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            created (str): [optional]  # noqa: E501\n            updated (str): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            card (Card): [optional]  # noqa: E501\n            direct_debit (DirectDebit): [optional]  # noqa: E501\n            ewallet (EWallet): [optional]  # noqa: E501\n            over_the_counter (OverTheCounter): [optional]  # noqa: E501\n            virtual_account (VirtualAccount): [optional]  # noqa: E501\n            qr_code (QRCode): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.type = type\n        self.reusability = reusability\n        self.status = status\n        if created is not None:\n            self.created = created\n        if updated is not None:\n            self.updated = updated\n        if description is not None:\n            self.description = description\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if card is not None:\n            self.card = card\n        if direct_debit is not None:\n            self.direct_debit = direct_debit\n        if ewallet is not None:\n            self.ewallet = ewallet\n        if over_the_counter is not None:\n            self.over_the_counter = over_the_counter\n        if virtual_account is not None:\n            self.virtual_account = virtual_account\n        if qr_code is not None:\n            self.qr_code = qr_code\n        if metadata is not None:\n            self.metadata = metadata\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      85,
      86,
      100,
      101,
      121,
      202,
      203,
      204,
      205,
      206,
      208,
      210,
      211,
      212,
      213,
      214,
      215,
      217,
      226,
      227,
      228,
      229,
      230,
      231,
      233,
      234,
      235,
      236,
      237,
      238,
      243,
      244,
      245,
      328,
      329,
      330,
      331,
      332,
      334,
      335,
      336,
      337,
      338,
      339,
      341,
      350,
      351,
      352,
      353,
      354,
      355,
      357,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      368,
      369,
      370,
      371,
      372,
      373,
      374,
      375,
      376,
      377,
      378,
      379,
      380,
      381,
      382,
      383,
      384,
      389,
      390,
      391,
      392
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_method_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.card_parameters import CardParameters\nfrom xendit.payment_request.model.direct_debit_parameters import DirectDebitParameters\nfrom xendit.payment_request.model.e_wallet_parameters import EWalletParameters\nfrom xendit.payment_request.model.over_the_counter_parameters import OverTheCounterParameters\nfrom xendit.payment_request.model.payment_method_reusability import PaymentMethodReusability\nfrom xendit.payment_request.model.payment_method_type import PaymentMethodType\nfrom xendit.payment_request.model.qr_code_parameters import QRCodeParameters\nfrom xendit.payment_request.model.virtual_account_parameters import VirtualAccountParameters\nglobals()['CardParameters'] = CardParameters\nglobals()['DirectDebitParameters'] = DirectDebitParameters\nglobals()['EWalletParameters'] = EWalletParameters\nglobals()['OverTheCounterParameters'] = OverTheCounterParameters\nglobals()['PaymentMethodReusability'] = PaymentMethodReusability\nglobals()['PaymentMethodType'] = PaymentMethodType\nglobals()['QRCodeParameters'] = QRCodeParameters\nglobals()['VirtualAccountParameters'] = VirtualAccountParameters\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'type': (PaymentMethodType,),  # noqa: E501\n            'reusability': (PaymentMethodReusability,),  # noqa: E501\n            'description': (str, none_type, none_type),  # noqa: E501\n            'reference_id': (str, none_type),  # noqa: E501\n            'card': (CardParameters, none_type),  # noqa: E501\n            'direct_debit': (DirectDebitParameters, none_type),  # noqa: E501\n            'ewallet': (EWalletParameters, none_type),  # noqa: E501\n            'over_the_counter': (OverTheCounterParameters, none_type),  # noqa: E501\n            'virtual_account': (VirtualAccountParameters, none_type),  # noqa: E501\n            'qr_code': (QRCodeParameters, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'type': 'type',  # noqa: E501\n        'reusability': 'reusability',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'card': 'card',  # noqa: E501\n        'direct_debit': 'direct_debit',  # noqa: E501\n        'ewallet': 'ewallet',  # noqa: E501\n        'over_the_counter': 'over_the_counter',  # noqa: E501\n        'virtual_account': 'virtual_account',  # noqa: E501\n        'qr_code': 'qr_code',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, type, reusability, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentMethodParameters - a model defined in OpenAPI\n\n        Args:\n            type (PaymentMethodType):\n            reusability (PaymentMethodReusability):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            description (str, none_type): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            card (CardParameters): [optional]  # noqa: E501\n            direct_debit (DirectDebitParameters): [optional]  # noqa: E501\n            ewallet (EWalletParameters): [optional]  # noqa: E501\n            over_the_counter (OverTheCounterParameters): [optional]  # noqa: E501\n            virtual_account (VirtualAccountParameters): [optional]  # noqa: E501\n            qr_code (QRCodeParameters): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        self.reusability = reusability\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        type: PaymentMethodType,\n        reusability: PaymentMethodReusability,\n        description: str | None = None,\n        reference_id: str | None = None,\n        card: CardParameters | None = None,\n        direct_debit: DirectDebitParameters | None = None,\n        ewallet: EWalletParameters | None = None,\n        over_the_counter: OverTheCounterParameters | None = None,\n        virtual_account: VirtualAccountParameters | None = None,\n        qr_code: QRCodeParameters | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentMethodParameters - a model defined in OpenAPI\n\n        Args:\n            type (PaymentMethodType):\n            reusability (PaymentMethodReusability):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            description (str, none_type): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            card (CardParameters): [optional]  # noqa: E501\n            direct_debit (DirectDebitParameters): [optional]  # noqa: E501\n            ewallet (EWalletParameters): [optional]  # noqa: E501\n            over_the_counter (OverTheCounterParameters): [optional]  # noqa: E501\n            virtual_account (VirtualAccountParameters): [optional]  # noqa: E501\n            qr_code (QRCodeParameters): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.type = type\n        self.reusability = reusability\n        if description is not None:\n            self.description = description\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if card is not None:\n            self.card = card\n        if direct_debit is not None:\n            self.direct_debit = direct_debit\n        if ewallet is not None:\n            self.ewallet = ewallet\n        if over_the_counter is not None:\n            self.over_the_counter = over_the_counter\n        if virtual_account is not None:\n            self.virtual_account = virtual_account\n        if qr_code is not None:\n            self.qr_code = qr_code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      83,
      84,
      194,
      195,
      196,
      197,
      198,
      200,
      224,
      299,
      300,
      301,
      302,
      303,
      305,
      306,
      307,
      308,
      309,
      310,
      312,
      321,
      322,
      323,
      324,
      325,
      326,
      328,
      329,
      330,
      331,
      332,
      333,
      334,
      335,
      336,
      337,
      338,
      339,
      340,
      341,
      342,
      343,
      344,
      345,
      346,
      347,
      352,
      353,
      354,
      355
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_method_reusability.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodReusability(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'MULTIPLE_USE': \"MULTIPLE_USE\",\n            'ONE_TIME_USE': \"ONE_TIME_USE\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentMethodReusability - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"MULTIPLE_USE\", \"ONE_TIME_USE\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"MULTIPLE_USE\", \"ONE_TIME_USE\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentMethodReusability - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"MULTIPLE_USE\", \"ONE_TIME_USE\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"MULTIPLE_USE\", \"ONE_TIME_USE\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      143,
      145,
      146,
      147,
      148,
      149,
      151,
      157,
      158,
      159,
      160,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      244,
      249,
      261,
      262,
      263,
      264,
      265,
      267,
      284,
      285,
      287
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_method_status.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodStatus(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'ACTIVE': \"ACTIVE\",\n            'INACTIVE': \"INACTIVE\",\n            'PENDING': \"PENDING\",\n            'EXPIRED': \"EXPIRED\",\n            'FAILED': \"FAILED\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentMethodStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"ACTIVE\", \"INACTIVE\", \"PENDING\", \"EXPIRED\", \"FAILED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"ACTIVE\", \"INACTIVE\", \"PENDING\", \"EXPIRED\", \"FAILED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentMethodStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"ACTIVE\", \"INACTIVE\", \"PENDING\", \"EXPIRED\", \"FAILED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"ACTIVE\", \"INACTIVE\", \"PENDING\", \"EXPIRED\", \"FAILED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      79,
      85,
      146,
      148,
      149,
      150,
      151,
      152,
      154,
      160,
      161,
      162,
      163,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      242,
      244,
      246,
      247,
      248,
      249,
      250,
      252,
      258,
      259,
      260,
      261,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      299
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_method_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentMethodType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'CARD': \"CARD\",\n            'DIRECT_DEBIT': \"DIRECT_DEBIT\",\n            'EWALLET': \"EWALLET\",\n            'OVER_THE_COUNTER': \"OVER_THE_COUNTER\",\n            'QR_CODE': \"QR_CODE\",\n            'VIRTUAL_ACCOUNT': \"VIRTUAL_ACCOUNT\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentMethodType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"CARD\", \"DIRECT_DEBIT\", \"EWALLET\", \"OVER_THE_COUNTER\", \"QR_CODE\", \"VIRTUAL_ACCOUNT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"CARD\", \"DIRECT_DEBIT\", \"EWALLET\", \"OVER_THE_COUNTER\", \"QR_CODE\", \"VIRTUAL_ACCOUNT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentMethodType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"CARD\", \"DIRECT_DEBIT\", \"EWALLET\", \"OVER_THE_COUNTER\", \"QR_CODE\", \"VIRTUAL_ACCOUNT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"CARD\", \"DIRECT_DEBIT\", \"EWALLET\", \"OVER_THE_COUNTER\", \"QR_CODE\", \"VIRTUAL_ACCOUNT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      147,
      149,
      150,
      151,
      152,
      153,
      155,
      161,
      162,
      163,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      248,
      253,
      265,
      266,
      267,
      268,
      269,
      271,
      288,
      289,
      291
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.payment_method import PaymentMethod\nfrom xendit.payment_request.model.payment_request_action import PaymentRequestAction\nfrom xendit.payment_request.model.payment_request_basket import PaymentRequestBasket\nfrom xendit.payment_request.model.payment_request_capture_method import PaymentRequestCaptureMethod\nfrom xendit.payment_request.model.payment_request_card_verification_results import PaymentRequestCardVerificationResults\nfrom xendit.payment_request.model.payment_request_country import PaymentRequestCountry\nfrom xendit.payment_request.model.payment_request_currency import PaymentRequestCurrency\nfrom xendit.payment_request.model.payment_request_initiator import PaymentRequestInitiator\nfrom xendit.payment_request.model.payment_request_shipping_information import PaymentRequestShippingInformation\nfrom xendit.payment_request.model.payment_request_status import PaymentRequestStatus\nglobals()['PaymentMethod'] = PaymentMethod\nglobals()['PaymentRequestAction'] = PaymentRequestAction\nglobals()['PaymentRequestBasket'] = PaymentRequestBasket\nglobals()['PaymentRequestCaptureMethod'] = PaymentRequestCaptureMethod\nglobals()['PaymentRequestCardVerificationResults'] = PaymentRequestCardVerificationResults\nglobals()['PaymentRequestCountry'] = PaymentRequestCountry\nglobals()['PaymentRequestCurrency'] = PaymentRequestCurrency\nglobals()['PaymentRequestInitiator'] = PaymentRequestInitiator\nglobals()['PaymentRequestShippingInformation'] = PaymentRequestShippingInformation\nglobals()['PaymentRequestStatus'] = PaymentRequestStatus\n\ndef lazy_import():\n    pass\n\nclass PaymentRequest(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'id': (str,),  # noqa: E501\n            'created': (str,),  # noqa: E501\n            'updated': (str,),  # noqa: E501\n            'reference_id': (str,),  # noqa: E501\n            'business_id': (str,),  # noqa: E501\n            'currency': (PaymentRequestCurrency,),  # noqa: E501\n            'payment_method': (PaymentMethod,),  # noqa: E501\n            'status': (PaymentRequestStatus,),  # noqa: E501\n            'customer_id': (str, none_type, none_type),  # noqa: E501\n            'customer': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n            'amount': (float, none_type),  # noqa: E501\n            'min_amount': (float, none_type, none_type),  # noqa: E501\n            'max_amount': (float, none_type, none_type),  # noqa: E501\n            'country': (PaymentRequestCountry, none_type),  # noqa: E501\n            'description': (str, none_type, none_type),  # noqa: E501\n            'failure_code': (str, none_type, none_type),  # noqa: E501\n            'capture_method': (PaymentRequestCaptureMethod, none_type),  # noqa: E501\n            'initiator': (PaymentRequestInitiator, none_type),  # noqa: E501\n            'card_verification_results': (PaymentRequestCardVerificationResults, none_type),  # noqa: E501\n            'actions': ([PaymentRequestAction], none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n            'shipping_information': (PaymentRequestShippingInformation, none_type),  # noqa: E501\n            'items': (PaymentRequestBasket, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'id': 'id',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'business_id': 'business_id',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'payment_method': 'payment_method',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'customer_id': 'customer_id',  # noqa: E501\n        'customer': 'customer',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'min_amount': 'min_amount',  # noqa: E501\n        'max_amount': 'max_amount',  # noqa: E501\n        'country': 'country',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'failure_code': 'failure_code',  # noqa: E501\n        'capture_method': 'capture_method',  # noqa: E501\n        'initiator': 'initiator',  # noqa: E501\n        'card_verification_results': 'card_verification_results',  # noqa: E501\n        'actions': 'actions',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n        'shipping_information': 'shipping_information',  # noqa: E501\n        'items': 'items',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, id, created, updated, reference_id, business_id, currency, payment_method, status, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequest - a model defined in OpenAPI\n\n        Args:\n            id (str):\n            created (str):\n            updated (str):\n            reference_id (str):\n            business_id (str):\n            currency (PaymentRequestCurrency):\n            payment_method (PaymentMethod):\n            status (PaymentRequestStatus):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            customer_id (str, none_type): [optional]  # noqa: E501\n            customer ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            amount (float): [optional]  # noqa: E501\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            country (PaymentRequestCountry): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            failure_code (str, none_type): [optional]  # noqa: E501\n            capture_method (PaymentRequestCaptureMethod): [optional]  # noqa: E501\n            initiator (PaymentRequestInitiator): [optional]  # noqa: E501\n            card_verification_results (PaymentRequestCardVerificationResults): [optional]  # noqa: E501\n            actions ([PaymentRequestAction]): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            shipping_information (PaymentRequestShippingInformation): [optional]  # noqa: E501\n            items (PaymentRequestBasket): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.created = created\n        self.updated = updated\n        self.reference_id = reference_id\n        self.business_id = business_id\n        self.currency = currency\n        self.payment_method = payment_method\n        self.status = status\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        id: str,\n        created: str,\n        updated: str,\n        reference_id: str,\n        business_id: str,\n        currency: PaymentRequestCurrency,\n        payment_method: PaymentMethod,\n        status: PaymentRequestStatus,\n        customer_id: str | None = None,\n        customer: dict | None = None,\n        amount: float | None = None,\n        min_amount: float | None = None,\n        max_amount: float | None = None,\n        country: PaymentRequestCountry | None = None,\n        description: str | None = None,\n        failure_code: str | None = None,\n        capture_method: PaymentRequestCaptureMethod | None = None,\n        initiator: PaymentRequestInitiator | None = None,\n        card_verification_results: PaymentRequestCardVerificationResults | None = None,\n        actions: list | None = None,\n        metadata: dict | None = None,\n        shipping_information: PaymentRequestShippingInformation | None = None,\n        items: PaymentRequestBasket | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentRequest - a model defined in OpenAPI\n\n        Args:\n            id (str):\n            created (str):\n            updated (str):\n            reference_id (str):\n            business_id (str):\n            currency (PaymentRequestCurrency):\n            payment_method (PaymentMethod):\n            status (PaymentRequestStatus):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            customer_id (str, none_type): [optional]  # noqa: E501\n            customer ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            amount (float): [optional]  # noqa: E501\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            country (PaymentRequestCountry): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            failure_code (str, none_type): [optional]  # noqa: E501\n            capture_method (PaymentRequestCaptureMethod): [optional]  # noqa: E501\n            initiator (PaymentRequestInitiator): [optional]  # noqa: E501\n            card_verification_results (PaymentRequestCardVerificationResults): [optional]  # noqa: E501\n            actions ([PaymentRequestAction]): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            shipping_information (PaymentRequestShippingInformation): [optional]  # noqa: E501\n            items (PaymentRequestBasket): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.created = created\n        self.updated = updated\n        self.reference_id = reference_id\n        self.business_id = business_id\n        self.currency = currency\n        self.payment_method = payment_method\n        self.status = status\n        if customer_id is not None:\n            self.customer_id = customer_id\n        if customer is not None:\n            self.customer = customer\n        if amount is not None:\n            self.amount = amount\n        if min_amount is not None:\n            self.min_amount = min_amount\n        if max_amount is not None:\n            self.max_amount = max_amount\n        if country is not None:\n            self.country = country\n        if description is not None:\n            self.description = description\n        if failure_code is not None:\n            self.failure_code = failure_code\n        if capture_method is not None:\n            self.capture_method = capture_method\n        if initiator is not None:\n            self.initiator = initiator\n        if card_verification_results is not None:\n            self.card_verification_results = card_verification_results\n        if actions is not None:\n            self.actions = actions\n        if metadata is not None:\n            self.metadata = metadata\n        if shipping_information is not None:\n            self.shipping_information = shipping_information\n        if items is not None:\n            self.items = items\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      87,
      88,
      102,
      103,
      131,
      228,
      229,
      230,
      231,
      232,
      234,
      236,
      237,
      238,
      239,
      240,
      241,
      243,
      252,
      253,
      254,
      255,
      256,
      257,
      259,
      260,
      261,
      262,
      263,
      264,
      265,
      266,
      267,
      268,
      273,
      274,
      275,
      374,
      375,
      376,
      377,
      378,
      380,
      381,
      382,
      383,
      384,
      385,
      387,
      396,
      397,
      398,
      399,
      400,
      401,
      403,
      404,
      405,
      406,
      407,
      408,
      409,
      410,
      411,
      412,
      413,
      414,
      415,
      416,
      417,
      418,
      419,
      420,
      421,
      422,
      423,
      424,
      425,
      426,
      427,
      428,
      429,
      430,
      431,
      432,
      433,
      434,
      435,
      436,
      437,
      438,
      439,
      440,
      441,
      442,
      447,
      448,
      449,
      450
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_action.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestAction(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('action',): {\n            'AUTH': \"AUTH\",\n            'RESEND_AUTH': \"RESEND_AUTH\",\n            'CAPTURE': \"CAPTURE\",\n            'CANCEL': \"CANCEL\",\n            'PRESENT_TO_CUSTOMER': \"PRESENT_TO_CUSTOMER\",\n        },\n        ('url_type',): {\n            'API': \"API\",\n            'WEB': \"WEB\",\n            'MOBILE': \"MOBILE\",\n            'DEEPLINK': \"DEEPLINK\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'action': (str,),  # noqa: E501\n            'url_type': (str,),  # noqa: E501\n            'method': (str, none_type,),  # noqa: E501\n            'url': (str, none_type,),  # noqa: E501\n            'qr_code': (str, none_type,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'action': 'action',  # noqa: E501\n        'url_type': 'url_type',  # noqa: E501\n        'method': 'method',  # noqa: E501\n        'url': 'url',  # noqa: E501\n        'qr_code': 'qr_code',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, action, url_type, method, url, qr_code, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestAction - a model defined in OpenAPI\n\n        Args:\n            action (str):\n            url_type (str):\n            method (str, none_type):\n            url (str, none_type):\n            qr_code (str, none_type):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.action = action\n        self.url_type = url_type\n        self.method = method\n        self.url = url\n        self.qr_code = qr_code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        action: str,\n        url_type: str,\n        method: str | None,\n        url: str | None,\n        qr_code: str | None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentRequestAction - a model defined in OpenAPI\n\n        Args:\n            action (str):\n            url_type (str):\n            method (str, none_type):\n            url (str, none_type):\n            qr_code (str, none_type):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.action = action\n        self.url_type = url_type\n        self.method = method\n        self.url = url\n        self.qr_code = qr_code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      80,
      94,
      104,
      165,
      166,
      167,
      168,
      169,
      171,
      173,
      174,
      175,
      176,
      177,
      178,
      180,
      189,
      190,
      191,
      192,
      193,
      194,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      207,
      208,
      209,
      272,
      273,
      274,
      275,
      276,
      278,
      279,
      280,
      281,
      282,
      283,
      285,
      294,
      295,
      296,
      297,
      298,
      299,
      301,
      302,
      303,
      304,
      305,
      306,
      307,
      312,
      313,
      314,
      315
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_auth_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestAuthParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'auth_code': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'auth_code': 'auth_code',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, auth_code, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestAuthParameters - a model defined in OpenAPI\n\n        Args:\n            auth_code (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.auth_code = auth_code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        auth_code: str,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentRequestAuthParameters - a model defined in OpenAPI\n\n        Args:\n            auth_code (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.auth_code = auth_code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      87,
      140,
      141,
      142,
      143,
      144,
      146,
      148,
      149,
      150,
      151,
      152,
      153,
      155,
      164,
      165,
      166,
      167,
      168,
      169,
      171,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      271,
      272,
      273,
      274
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_basket.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.payment_request_basket_item import PaymentRequestBasketItem\nglobals()['PaymentRequestBasketItem'] = PaymentRequestBasketItem\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestBasket(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'value': ([PaymentRequestBasketItem], none_type,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentRequestBasket - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] ([PaymentRequestBasketItem], none_type):  # noqa: E501\n\n        Keyword Args:\n            value ([PaymentRequestBasketItem], none_type):  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentRequestBasket - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] ([PaymentRequestBasketItem], none_type):  # noqa: E501\n\n        Keyword Args:\n            value ([PaymentRequestBasketItem], none_type):  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      73,
      74,
      80,
      141,
      143,
      144,
      145,
      146,
      147,
      149,
      155,
      156,
      157,
      158,
      160,
      161,
      162,
      163,
      164,
      165,
      167,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      237,
      239,
      241,
      242,
      243,
      244,
      245,
      247,
      253,
      254,
      255,
      256,
      258,
      259,
      260,
      261,
      262,
      263,
      265,
      274,
      275,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      291
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_basket_item.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestBasketItem(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'name': (str,),  # noqa: E501\n            'category': (str,),  # noqa: E501\n            'currency': (str,),  # noqa: E501\n            'quantity': (float,),  # noqa: E501\n            'price': (float,),  # noqa: E501\n            'reference_id': (str, none_type),  # noqa: E501\n            'description': (str, none_type),  # noqa: E501\n            'type': (str, none_type),  # noqa: E501\n            'sub_category': (str, none_type),  # noqa: E501\n            'payer_charged_currency': (str, none_type),  # noqa: E501\n            'payer_charged_price': (float, none_type),  # noqa: E501\n            'url': (str, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'name': 'name',  # noqa: E501\n        'category': 'category',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'quantity': 'quantity',  # noqa: E501\n        'price': 'price',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'type': 'type',  # noqa: E501\n        'sub_category': 'sub_category',  # noqa: E501\n        'payer_charged_currency': 'payer_charged_currency',  # noqa: E501\n        'payer_charged_price': 'payer_charged_price',  # noqa: E501\n        'url': 'url',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, name, category, currency, quantity, price, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestBasketItem - a model defined in OpenAPI\n\n        Args:\n            name (str):\n            category (str):\n            currency (str):\n            quantity (float):\n            price (float):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            reference_id (str): [optional]  # noqa: E501\n            description (str): [optional]  # noqa: E501\n            type (str): [optional]  # noqa: E501\n            sub_category (str): [optional]  # noqa: E501\n            payer_charged_currency (str): [optional]  # noqa: E501\n            payer_charged_price (float): [optional]  # noqa: E501\n            url (str): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.name = name\n        self.category = category\n        self.currency = currency\n        self.quantity = quantity\n        self.price = price\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        name: str,\n        category: str,\n        currency: str,\n        quantity: float,\n        price: float,\n        reference_id: str | None = None,\n        description: str | None = None,\n        type: str | None = None,\n        sub_category: str | None = None,\n        payer_charged_currency: str | None = None,\n        payer_charged_price: float | None = None,\n        url: str | None = None,\n        metadata: dict | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentRequestBasketItem - a model defined in OpenAPI\n\n        Args:\n            name (str):\n            category (str):\n            currency (str):\n            quantity (float):\n            price (float):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            reference_id (str): [optional]  # noqa: E501\n            description (str): [optional]  # noqa: E501\n            type (str): [optional]  # noqa: E501\n            sub_category (str): [optional]  # noqa: E501\n            payer_charged_currency (str): [optional]  # noqa: E501\n            payer_charged_price (float): [optional]  # noqa: E501\n            url (str): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.name = name\n        self.category = category\n        self.currency = currency\n        self.quantity = quantity\n        self.price = price\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if description is not None:\n            self.description = description\n        if type is not None:\n            self.type = type\n        if sub_category is not None:\n            self.sub_category = sub_category\n        if payer_charged_currency is not None:\n            self.payer_charged_currency = payer_charged_currency\n        if payer_charged_price is not None:\n            self.payer_charged_price = payer_charged_price\n        if url is not None:\n            self.url = url\n        if metadata is not None:\n            self.metadata = metadata\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      99,
      176,
      177,
      178,
      179,
      180,
      182,
      184,
      185,
      186,
      187,
      188,
      189,
      191,
      200,
      201,
      202,
      203,
      204,
      205,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      218,
      219,
      220,
      299,
      300,
      301,
      302,
      303,
      305,
      306,
      307,
      308,
      309,
      310,
      312,
      321,
      322,
      323,
      324,
      325,
      326,
      328,
      329,
      330,
      331,
      332,
      333,
      334,
      335,
      336,
      337,
      338,
      339,
      340,
      341,
      342,
      343,
      344,
      345,
      346,
      347,
      348,
      349,
      350,
      355,
      356,
      357,
      358
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_capture_method.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestCaptureMethod(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'None': None,\n            'AUTOMATIC': \"AUTOMATIC\",\n            'MANUAL': \"MANUAL\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentRequestCaptureMethod - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"AUTOMATIC\", \"MANUAL\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"AUTOMATIC\", \"MANUAL\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentRequestCaptureMethod - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"AUTOMATIC\", \"MANUAL\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"AUTOMATIC\", \"MANUAL\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      77,
      83,
      144,
      146,
      147,
      148,
      149,
      150,
      152,
      158,
      159,
      160,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      240,
      242,
      244,
      245,
      246,
      247,
      248,
      250,
      256,
      257,
      258,
      259,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      297
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_card_verification_results.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.payment_request_card_verification_results_three_dee_secure import PaymentRequestCardVerificationResultsThreeDeeSecure\nglobals()['PaymentRequestCardVerificationResultsThreeDeeSecure'] = PaymentRequestCardVerificationResultsThreeDeeSecure\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestCardVerificationResults(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'three_d_secure': (PaymentRequestCardVerificationResultsThreeDeeSecure,),  # noqa: E501\n            'cvv_result': (str, none_type, none_type),  # noqa: E501\n            'address_verification_result': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'three_d_secure': 'three_d_secure',  # noqa: E501\n        'cvv_result': 'cvv_result',  # noqa: E501\n        'address_verification_result': 'address_verification_result',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, three_d_secure, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestCardVerificationResults - a model defined in OpenAPI\n\n        Args:\n            three_d_secure (PaymentRequestCardVerificationResultsThreeDeeSecure):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            cvv_result (str, none_type): [optional]  # noqa: E501\n            address_verification_result (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.three_d_secure = three_d_secure\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        three_d_secure: PaymentRequestCardVerificationResultsThreeDeeSecure | None,\n        cvv_result: str | None = None,\n        address_verification_result: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentRequestCardVerificationResults - a model defined in OpenAPI\n\n        Args:\n            three_d_secure (PaymentRequestCardVerificationResultsThreeDeeSecure):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            cvv_result (str, none_type): [optional]  # noqa: E501\n            address_verification_result (str, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.three_d_secure = three_d_secure\n        if cvv_result is not None:\n            self.cvv_result = cvv_result\n        if address_verification_result is not None:\n            self.address_verification_result = address_verification_result\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      93,
      150,
      151,
      152,
      153,
      154,
      156,
      158,
      159,
      160,
      161,
      162,
      163,
      165,
      174,
      175,
      176,
      177,
      178,
      179,
      181,
      182,
      183,
      188,
      189,
      190,
      249,
      250,
      251,
      252,
      253,
      255,
      256,
      257,
      258,
      259,
      260,
      262,
      271,
      272,
      273,
      274,
      275,
      276,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      289,
      290,
      291,
      292
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_card_verification_results_three_dee_secure.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestCardVerificationResultsThreeDeeSecure(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'three_d_secure_flow': (str, none_type),  # noqa: E501\n            'eci_code': (str, none_type),  # noqa: E501\n            'three_d_secure_result': (str, none_type),  # noqa: E501\n            'three_d_secure_result_reason': (str, none_type, none_type),  # noqa: E501\n            'three_d_secure_version': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'three_d_secure_flow': 'three_d_secure_flow',  # noqa: E501\n        'eci_code': 'eci_code',  # noqa: E501\n        'three_d_secure_result': 'three_d_secure_result',  # noqa: E501\n        'three_d_secure_result_reason': 'three_d_secure_result_reason',  # noqa: E501\n        'three_d_secure_version': 'three_d_secure_version',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestCardVerificationResultsThreeDeeSecure - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            three_d_secure_flow (str): [optional]  # noqa: E501\n            eci_code (str): [optional]  # noqa: E501\n            three_d_secure_result (str): [optional]  # noqa: E501\n            three_d_secure_result_reason (str, none_type): [optional]  # noqa: E501\n            three_d_secure_version (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        three_d_secure_flow: str | None = None,\n        eci_code: str | None = None,\n        three_d_secure_result: str | None = None,\n        three_d_secure_result_reason: str | None = None,\n        three_d_secure_version: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentRequestCardVerificationResultsThreeDeeSecure - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            three_d_secure_flow (str): [optional]  # noqa: E501\n            eci_code (str): [optional]  # noqa: E501\n            three_d_secure_result (str): [optional]  # noqa: E501\n            three_d_secure_result_reason (str, none_type): [optional]  # noqa: E501\n            three_d_secure_version (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if three_d_secure_flow is not None:\n            self.three_d_secure_flow = three_d_secure_flow\n        if eci_code is not None:\n            self.eci_code = eci_code\n        if three_d_secure_result is not None:\n            self.three_d_secure_result = three_d_secure_result\n        if three_d_secure_result_reason is not None:\n            self.three_d_secure_result_reason = three_d_secure_result_reason\n        if three_d_secure_version is not None:\n            self.three_d_secure_version = three_d_secure_version\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      91,
      150,
      151,
      152,
      153,
      154,
      156,
      158,
      159,
      160,
      161,
      162,
      163,
      165,
      174,
      175,
      176,
      177,
      178,
      179,
      181,
      182,
      187,
      188,
      189,
      250,
      251,
      252,
      253,
      254,
      256,
      257,
      258,
      259,
      260,
      261,
      263,
      272,
      273,
      274,
      275,
      276,
      277,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      295,
      296,
      297,
      298
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('success_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('failure_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('cancel_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('pending_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'success_return_url': (str, none_type),  # noqa: E501\n            'failure_return_url': (str, none_type),  # noqa: E501\n            'cancel_return_url': (str, none_type),  # noqa: E501\n            'pending_return_url': (str, none_type),  # noqa: E501\n            'redeem_points': (str, none_type),  # noqa: E501\n            'require_auth': (bool, none_type),  # noqa: E501\n            'merchant_id_tag': (str, none_type),  # noqa: E501\n            'cardonfile_type': (str, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'success_return_url': 'success_return_url',  # noqa: E501\n        'failure_return_url': 'failure_return_url',  # noqa: E501\n        'cancel_return_url': 'cancel_return_url',  # noqa: E501\n        'pending_return_url': 'pending_return_url',  # noqa: E501\n        'redeem_points': 'redeem_points',  # noqa: E501\n        'require_auth': 'require_auth',  # noqa: E501\n        'merchant_id_tag': 'merchant_id_tag',  # noqa: E501\n        'cardonfile_type': 'cardonfile_type',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            cancel_return_url (str): URL where the end-customer is redirected if the authorization cancelled. [optional]  # noqa: E501\n            pending_return_url (str): URL where the end-customer is redirected if the authorization is pending. [optional]  # noqa: E501\n            redeem_points (str): REDEEM_NONE will not use any point, REDEEM_ALL will use all available points before cash balance is used. For OVO and ShopeePay tokenized payment use only.. [optional]  # noqa: E501\n            require_auth (bool): Toggle used to require end-customer to input undergo OTP validation before completing a payment. OTP will always be required for transactions greater than 1,000,000 IDR. For BRI tokenized payment use only.. [optional]  # noqa: E501\n            merchant_id_tag (str): Tag for a Merchant ID that you want to associate this payment with. For merchants using their own MIDs to specify which MID they want to use . [optional]  # noqa: E501\n            cardonfile_type (str, none_type): Type of credential-on-file / card-on-file payment being made. Indicate that this payment uses a previously linked Payment Method for charging.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        success_return_url: str | None = None,\n        failure_return_url: str | None = None,\n        cancel_return_url: str | None = None,\n        pending_return_url: str | None = None,\n        redeem_points: str | None = None,\n        require_auth: bool | None = None,\n        merchant_id_tag: str | None = None,\n        cardonfile_type: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentRequestChannelProperties - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            cancel_return_url (str): URL where the end-customer is redirected if the authorization cancelled. [optional]  # noqa: E501\n            pending_return_url (str): URL where the end-customer is redirected if the authorization is pending. [optional]  # noqa: E501\n            redeem_points (str): REDEEM_NONE will not use any point, REDEEM_ALL will use all available points before cash balance is used. For OVO and ShopeePay tokenized payment use only.. [optional]  # noqa: E501\n            require_auth (bool): Toggle used to require end-customer to input undergo OTP validation before completing a payment. OTP will always be required for transactions greater than 1,000,000 IDR. For BRI tokenized payment use only.. [optional]  # noqa: E501\n            merchant_id_tag (str): Tag for a Merchant ID that you want to associate this payment with. For merchants using their own MIDs to specify which MID they want to use . [optional]  # noqa: E501\n            cardonfile_type (str, none_type): Type of credential-on-file / card-on-file payment being made. Indicate that this payment uses a previously linked Payment Method for charging.. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if success_return_url is not None:\n            self.success_return_url = success_return_url\n        if failure_return_url is not None:\n            self.failure_return_url = failure_return_url\n        if cancel_return_url is not None:\n            self.cancel_return_url = cancel_return_url\n        if pending_return_url is not None:\n            self.pending_return_url = pending_return_url\n        if redeem_points is not None:\n            self.redeem_points = redeem_points\n        if require_auth is not None:\n            self.require_auth = require_auth\n        if merchant_id_tag is not None:\n            self.merchant_id_tag = merchant_id_tag\n        if cardonfile_type is not None:\n            self.cardonfile_type = cardonfile_type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      87,
      101,
      114,
      179,
      180,
      181,
      182,
      183,
      185,
      187,
      188,
      189,
      190,
      191,
      192,
      194,
      203,
      204,
      205,
      206,
      207,
      208,
      210,
      211,
      216,
      217,
      218,
      285,
      286,
      287,
      288,
      289,
      291,
      292,
      293,
      294,
      295,
      296,
      298,
      307,
      308,
      309,
      310,
      311,
      312,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      322,
      323,
      324,
      325,
      326,
      327,
      328,
      329,
      330,
      331,
      336,
      337,
      338,
      339
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_country.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestCountry(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'ID': \"ID\",\n            'PH': \"PH\",\n            'VN': \"VN\",\n            'TH': \"TH\",\n            'MY': \"MY\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentRequestCountry - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"ID\", \"PH\", \"VN\", \"TH\", \"MY\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"ID\", \"PH\", \"VN\", \"TH\", \"MY\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentRequestCountry - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"ID\", \"PH\", \"VN\", \"TH\", \"MY\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"ID\", \"PH\", \"VN\", \"TH\", \"MY\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      79,
      85,
      146,
      148,
      149,
      150,
      151,
      152,
      154,
      160,
      161,
      162,
      163,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      242,
      244,
      246,
      247,
      248,
      249,
      250,
      252,
      258,
      259,
      260,
      261,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      299
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_currency.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestCurrency(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'IDR': \"IDR\",\n            'PHP': \"PHP\",\n            'VND': \"VND\",\n            'THB': \"THB\",\n            'MYR': \"MYR\",\n            'USD': \"USD\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentRequestCurrency - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"IDR\", \"PHP\", \"VND\", \"THB\", \"MYR\", \"USD\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"IDR\", \"PHP\", \"VND\", \"THB\", \"MYR\", \"USD\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentRequestCurrency - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"IDR\", \"PHP\", \"VND\", \"THB\", \"MYR\", \"USD\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"IDR\", \"PHP\", \"VND\", \"THB\", \"MYR\", \"USD\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      147,
      149,
      150,
      151,
      152,
      153,
      155,
      161,
      162,
      163,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      248,
      253,
      265,
      266,
      267,
      268,
      269,
      271,
      288,
      289,
      291
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_initiator.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestInitiator(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'None': None,\n            'CUSTOMER': \"CUSTOMER\",\n            'MERCHANT': \"MERCHANT\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentRequestInitiator - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"CUSTOMER\", \"MERCHANT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"CUSTOMER\", \"MERCHANT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentRequestInitiator - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"CUSTOMER\", \"MERCHANT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"CUSTOMER\", \"MERCHANT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      77,
      83,
      144,
      146,
      147,
      148,
      149,
      150,
      152,
      158,
      159,
      160,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      240,
      242,
      244,
      245,
      246,
      247,
      248,
      250,
      256,
      257,
      258,
      259,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      297
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_list_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.payment_request import PaymentRequest\nglobals()['PaymentRequest'] = PaymentRequest\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestListResponse(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'data': ([PaymentRequest],),  # noqa: E501\n            'has_more': (bool,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'data': 'data',  # noqa: E501\n        'has_more': 'has_more',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, data, has_more, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestListResponse - a model defined in OpenAPI\n\n        Args:\n            data ([PaymentRequest]):\n            has_more (bool):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.data = data\n        self.has_more = has_more\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        data: list,\n        has_more: bool,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentRequestListResponse - a model defined in OpenAPI\n\n        Args:\n            data ([PaymentRequest]):\n            has_more (bool):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.data = data\n        self.has_more = has_more\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      92,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      180,
      181,
      186,
      187,
      188,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      282,
      283,
      284,
      285
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.payment_method_parameters import PaymentMethodParameters\nfrom xendit.payment_request.model.payment_request_basket import PaymentRequestBasket\nfrom xendit.payment_request.model.payment_request_capture_method import PaymentRequestCaptureMethod\nfrom xendit.payment_request.model.payment_request_currency import PaymentRequestCurrency\nfrom xendit.payment_request.model.payment_request_initiator import PaymentRequestInitiator\nfrom xendit.payment_request.model.payment_request_parameters_channel_properties import PaymentRequestParametersChannelProperties\nfrom xendit.payment_request.model.payment_request_shipping_information import PaymentRequestShippingInformation\nglobals()['PaymentMethodParameters'] = PaymentMethodParameters\nglobals()['PaymentRequestBasket'] = PaymentRequestBasket\nglobals()['PaymentRequestCaptureMethod'] = PaymentRequestCaptureMethod\nglobals()['PaymentRequestCurrency'] = PaymentRequestCurrency\nglobals()['PaymentRequestInitiator'] = PaymentRequestInitiator\nglobals()['PaymentRequestParametersChannelProperties'] = PaymentRequestParametersChannelProperties\nglobals()['PaymentRequestShippingInformation'] = PaymentRequestShippingInformation\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'currency': (PaymentRequestCurrency,),  # noqa: E501\n            'reference_id': (str, none_type),  # noqa: E501\n            'amount': (float, none_type),  # noqa: E501\n            'payment_method': (PaymentMethodParameters, none_type),  # noqa: E501\n            'description': (str, none_type, none_type),  # noqa: E501\n            'capture_method': (PaymentRequestCaptureMethod, none_type),  # noqa: E501\n            'initiator': (PaymentRequestInitiator, none_type),  # noqa: E501\n            'payment_method_id': (str, none_type),  # noqa: E501\n            'channel_properties': (PaymentRequestParametersChannelProperties, none_type),  # noqa: E501\n            'shipping_information': (PaymentRequestShippingInformation, none_type),  # noqa: E501\n            'items': (PaymentRequestBasket, none_type),  # noqa: E501\n            'customer_id': (str, none_type, none_type),  # noqa: E501\n            'customer': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'currency': 'currency',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'payment_method': 'payment_method',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'capture_method': 'capture_method',  # noqa: E501\n        'initiator': 'initiator',  # noqa: E501\n        'payment_method_id': 'payment_method_id',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'shipping_information': 'shipping_information',  # noqa: E501\n        'items': 'items',  # noqa: E501\n        'customer_id': 'customer_id',  # noqa: E501\n        'customer': 'customer',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, currency, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestParameters - a model defined in OpenAPI\n\n        Args:\n            currency (PaymentRequestCurrency):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            reference_id (str): [optional]  # noqa: E501\n            amount (float): [optional]  # noqa: E501\n            payment_method (PaymentMethodParameters): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            capture_method (PaymentRequestCaptureMethod): [optional]  # noqa: E501\n            initiator (PaymentRequestInitiator): [optional]  # noqa: E501\n            payment_method_id (str): [optional]  # noqa: E501\n            channel_properties (PaymentRequestParametersChannelProperties): [optional]  # noqa: E501\n            shipping_information (PaymentRequestShippingInformation): [optional]  # noqa: E501\n            items (PaymentRequestBasket): [optional]  # noqa: E501\n            customer_id (str, none_type): [optional]  # noqa: E501\n            customer ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.currency = currency\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        currency: PaymentRequestCurrency,\n        reference_id: str | None = None,\n        amount: float | None = None,\n        payment_method: PaymentMethodParameters | None = None,\n        description: str | None = None,\n        capture_method: PaymentRequestCaptureMethod | None = None,\n        initiator: PaymentRequestInitiator | None = None,\n        payment_method_id: str | None = None,\n        channel_properties: PaymentRequestParametersChannelProperties | None = None,\n        shipping_information: PaymentRequestShippingInformation | None = None,\n        items: PaymentRequestBasket | None = None,\n        customer_id: str | None = None,\n        customer: dict | None = None,\n        metadata: dict | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentRequestParameters - a model defined in OpenAPI\n\n        Args:\n            currency (PaymentRequestCurrency):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            reference_id (str): [optional]  # noqa: E501\n            amount (float): [optional]  # noqa: E501\n            payment_method (PaymentMethodParameters): [optional]  # noqa: E501\n            description (str, none_type): [optional]  # noqa: E501\n            capture_method (PaymentRequestCaptureMethod): [optional]  # noqa: E501\n            initiator (PaymentRequestInitiator): [optional]  # noqa: E501\n            payment_method_id (str): [optional]  # noqa: E501\n            channel_properties (PaymentRequestParametersChannelProperties): [optional]  # noqa: E501\n            shipping_information (PaymentRequestShippingInformation): [optional]  # noqa: E501\n            items (PaymentRequestBasket): [optional]  # noqa: E501\n            customer_id (str, none_type): [optional]  # noqa: E501\n            customer ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.currency = currency\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if amount is not None:\n            self.amount = amount\n        if payment_method is not None:\n            self.payment_method = payment_method\n        if description is not None:\n            self.description = description\n        if capture_method is not None:\n            self.capture_method = capture_method\n        if initiator is not None:\n            self.initiator = initiator\n        if payment_method_id is not None:\n            self.payment_method_id = payment_method_id\n        if channel_properties is not None:\n            self.channel_properties = channel_properties\n        if shipping_information is not None:\n            self.shipping_information = shipping_information\n        if items is not None:\n            self.items = items\n        if customer_id is not None:\n            self.customer_id = customer_id\n        if customer is not None:\n            self.customer = customer\n        if metadata is not None:\n            self.metadata = metadata\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      204,
      205,
      206,
      207,
      208,
      210,
      233,
      316,
      317,
      318,
      319,
      320,
      322,
      323,
      324,
      325,
      326,
      327,
      329,
      338,
      339,
      340,
      341,
      342,
      343,
      345,
      346,
      347,
      348,
      349,
      350,
      351,
      352,
      353,
      354,
      355,
      356,
      357,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      368,
      369,
      370,
      371,
      372,
      373,
      378,
      379,
      380,
      381
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_parameters_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.payment_request_channel_properties import PaymentRequestChannelProperties\nfrom xendit.payment_request.model.payment_request_parameters_channel_properties_all_of import PaymentRequestParametersChannelPropertiesAllOf\nglobals()['PaymentRequestChannelProperties'] = PaymentRequestChannelProperties\nglobals()['PaymentRequestParametersChannelPropertiesAllOf'] = PaymentRequestParametersChannelPropertiesAllOf\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestParametersChannelProperties(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('success_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('failure_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('cancel_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n        ('pending_return_url',): {\n            'regex': {\n                'pattern': r'^\\S{1,255}:\\/\\/\\S{0,1000}$',  # noqa: E501\n            },\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'success_return_url': (str, none_type),  # noqa: E501\n            'failure_return_url': (str, none_type),  # noqa: E501\n            'cancel_return_url': (str, none_type),  # noqa: E501\n            'pending_return_url': (str, none_type),  # noqa: E501\n            'redeem_points': (str, none_type),  # noqa: E501\n            'require_auth': (bool, none_type),  # noqa: E501\n            'merchant_id_tag': (str, none_type),  # noqa: E501\n            'cardonfile_type': (str, none_type, none_type),  # noqa: E501\n            'cvv': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'success_return_url': 'success_return_url',  # noqa: E501\n        'failure_return_url': 'failure_return_url',  # noqa: E501\n        'cancel_return_url': 'cancel_return_url',  # noqa: E501\n        'pending_return_url': 'pending_return_url',  # noqa: E501\n        'redeem_points': 'redeem_points',  # noqa: E501\n        'require_auth': 'require_auth',  # noqa: E501\n        'merchant_id_tag': 'merchant_id_tag',  # noqa: E501\n        'cardonfile_type': 'cardonfile_type',  # noqa: E501\n        'cvv': 'cvv',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestParametersChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            cancel_return_url (str): URL where the end-customer is redirected if the authorization cancelled. [optional]  # noqa: E501\n            pending_return_url (str): URL where the end-customer is redirected if the authorization is pending. [optional]  # noqa: E501\n            redeem_points (str): REDEEM_NONE will not use any point, REDEEM_ALL will use all available points before cash balance is used. For OVO and ShopeePay tokenized payment use only.. [optional]  # noqa: E501\n            require_auth (bool): Toggle used to require end-customer to input undergo OTP validation before completing a payment. OTP will always be required for transactions greater than 1,000,000 IDR. For BRI tokenized payment use only.. [optional]  # noqa: E501\n            merchant_id_tag (str): Tag for a Merchant ID that you want to associate this payment with. For merchants using their own MIDs to specify which MID they want to use . [optional]  # noqa: E501\n            cardonfile_type (str, none_type): Type of credential-on-file / card-on-file payment being made. Indicate that this payment uses a previously linked Payment Method for charging.. [optional]  # noqa: E501\n            cvv (str): Three digit code written on the back of the card (usually called CVV/CVN).. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestParametersChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            success_return_url (str): URL where the end-customer is redirected if the authorization is successful. [optional]  # noqa: E501\n            failure_return_url (str): URL where the end-customer is redirected if the authorization failed. [optional]  # noqa: E501\n            cancel_return_url (str): URL where the end-customer is redirected if the authorization cancelled. [optional]  # noqa: E501\n            pending_return_url (str): URL where the end-customer is redirected if the authorization is pending. [optional]  # noqa: E501\n            redeem_points (str): REDEEM_NONE will not use any point, REDEEM_ALL will use all available points before cash balance is used. For OVO and ShopeePay tokenized payment use only.. [optional]  # noqa: E501\n            require_auth (bool): Toggle used to require end-customer to input undergo OTP validation before completing a payment. OTP will always be required for transactions greater than 1,000,000 IDR. For BRI tokenized payment use only.. [optional]  # noqa: E501\n            merchant_id_tag (str): Tag for a Merchant ID that you want to associate this payment with. For merchants using their own MIDs to specify which MID they want to use . [optional]  # noqa: E501\n            cardonfile_type (str, none_type): Type of credential-on-file / card-on-file payment being made. Indicate that this payment uses a previously linked Payment Method for charging.. [optional]  # noqa: E501\n            cvv (str): Three digit code written on the back of the card (usually called CVV/CVN).. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              PaymentRequestChannelProperties,\n              PaymentRequestParametersChannelPropertiesAllOf,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      91,
      92,
      106,
      107,
      121,
      186,
      187,
      188,
      189,
      190,
      192,
      194,
      195,
      196,
      197,
      198,
      199,
      201,
      210,
      211,
      212,
      213,
      214,
      215,
      217,
      224,
      226,
      227,
      228,
      229,
      231,
      232,
      237,
      238,
      240,
      300,
      301,
      302,
      303,
      304,
      306,
      307,
      308,
      309,
      310,
      311,
      313,
      322,
      323,
      324,
      325,
      326,
      327,
      329,
      336,
      338,
      339,
      340,
      341,
      343,
      344,
      349,
      350,
      351,
      352,
      364,
      365
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_parameters_channel_properties_all_of.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestParametersChannelPropertiesAllOf(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'cvv': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'cvv': 'cvv',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestParametersChannelPropertiesAllOf - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            cvv (str): Three digit code written on the back of the card (usually called CVV/CVN).. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        cvv: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentRequestParametersChannelPropertiesAllOf - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            cvv (str): Three digit code written on the back of the card (usually called CVV/CVN).. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if cvv is not None:\n            self.cvv = cvv\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      87,
      138,
      139,
      140,
      141,
      142,
      144,
      146,
      147,
      148,
      149,
      150,
      151,
      153,
      162,
      163,
      164,
      165,
      166,
      167,
      169,
      170,
      175,
      176,
      177,
      230,
      231,
      232,
      233,
      234,
      236,
      237,
      238,
      239,
      240,
      241,
      243,
      252,
      253,
      254,
      255,
      256,
      257,
      259,
      260,
      261,
      262,
      267,
      268,
      269,
      270
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_shipping_information.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestShippingInformation(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'country': (str,),  # noqa: E501\n            'street_line1': (str, none_type),  # noqa: E501\n            'street_line2': (str, none_type),  # noqa: E501\n            'city': (str, none_type),  # noqa: E501\n            'province_state': (str, none_type),  # noqa: E501\n            'postal_code': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'country': 'country',  # noqa: E501\n        'street_line1': 'street_line1',  # noqa: E501\n        'street_line2': 'street_line2',  # noqa: E501\n        'city': 'city',  # noqa: E501\n        'province_state': 'province_state',  # noqa: E501\n        'postal_code': 'postal_code',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, country, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentRequestShippingInformation - a model defined in OpenAPI\n\n        Args:\n            country (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            street_line1 (str): [optional]  # noqa: E501\n            street_line2 (str): [optional]  # noqa: E501\n            city (str): [optional]  # noqa: E501\n            province_state (str): [optional]  # noqa: E501\n            postal_code (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.country = country\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        country: str,\n        street_line1: str | None = None,\n        street_line2: str | None = None,\n        city: str | None = None,\n        province_state: str | None = None,\n        postal_code: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentRequestShippingInformation - a model defined in OpenAPI\n\n        Args:\n            country (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            street_line1 (str): [optional]  # noqa: E501\n            street_line2 (str): [optional]  # noqa: E501\n            city (str): [optional]  # noqa: E501\n            province_state (str): [optional]  # noqa: E501\n            postal_code (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.country = country\n        if street_line1 is not None:\n            self.street_line1 = street_line1\n        if street_line2 is not None:\n            self.street_line2 = street_line2\n        if city is not None:\n            self.city = city\n        if province_state is not None:\n            self.province_state = province_state\n        if postal_code is not None:\n            self.postal_code = postal_code\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      92,
      155,
      156,
      157,
      158,
      159,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      186,
      187,
      188,
      193,
      194,
      195,
      260,
      261,
      262,
      263,
      264,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      282,
      283,
      284,
      285,
      286,
      287,
      289,
      290,
      291,
      292,
      293,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      301,
      306,
      307,
      308,
      309
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_request_status.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentRequestStatus(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'PENDING': \"PENDING\",\n            'REQUIRES_ACTION': \"REQUIRES_ACTION\",\n            'CANCELED': \"CANCELED\",\n            'SUCCEEDED': \"SUCCEEDED\",\n            'FAILED': \"FAILED\",\n            'VOIDED': \"VOIDED\",\n            'UNKNOWN': \"UNKNOWN\",\n            'AWAITING_CAPTURE': \"AWAITING_CAPTURE\",\n            'EXPIRED': \"EXPIRED\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"PaymentRequestStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"PENDING\", \"REQUIRES_ACTION\", \"CANCELED\", \"SUCCEEDED\", \"FAILED\", \"VOIDED\", \"UNKNOWN\", \"AWAITING_CAPTURE\", \"EXPIRED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"PENDING\", \"REQUIRES_ACTION\", \"CANCELED\", \"SUCCEEDED\", \"FAILED\", \"VOIDED\", \"UNKNOWN\", \"AWAITING_CAPTURE\", \"EXPIRED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"PaymentRequestStatus - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str):, must be one of [\"PENDING\", \"REQUIRES_ACTION\", \"CANCELED\", \"SUCCEEDED\", \"FAILED\", \"VOIDED\", \"UNKNOWN\", \"AWAITING_CAPTURE\", \"EXPIRED\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str):, must be one of [\"PENDING\", \"REQUIRES_ACTION\", \"CANCELED\", \"SUCCEEDED\", \"FAILED\", \"VOIDED\", \"UNKNOWN\", \"AWAITING_CAPTURE\", \"EXPIRED\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      83,
      89,
      150,
      152,
      153,
      154,
      155,
      156,
      158,
      164,
      165,
      166,
      167,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      246,
      248,
      250,
      251,
      252,
      253,
      254,
      256,
      262,
      263,
      264,
      265,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      292,
      293,
      294,
      303
    ]
  },
  {
    "file_path": "xendit/payment_request/model/payment_simulation.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PaymentSimulation(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'status': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'status': 'status',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"PaymentSimulation - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            status (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        status: str | None = None,\n        message: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PaymentSimulation - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            status (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if status is not None:\n            self.status = status\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/payment_request/model/qr_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.qr_code_channel_code import QRCodeChannelCode\nfrom xendit.payment_request.model.qr_code_channel_properties import QRCodeChannelProperties\nfrom xendit.payment_request.model.qr_code_parameters import QRCodeParameters\nglobals()['QRCodeChannelCode'] = QRCodeChannelCode\nglobals()['QRCodeChannelProperties'] = QRCodeChannelProperties\nglobals()['QRCodeParameters'] = QRCodeParameters\n\ndef lazy_import():\n    pass\n\nclass QRCode(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (QRCodeChannelCode, none_type),  # noqa: E501\n            'channel_properties': (QRCodeChannelProperties, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"QRCode - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (QRCodeChannelCode): [optional]  # noqa: E501\n            channel_properties (QRCodeChannelProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"QRCode - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (QRCodeChannelCode): [optional]  # noqa: E501\n            channel_properties (QRCodeChannelProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              QRCodeParameters,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      73,
      74,
      88,
      89,
      96,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      185,
      187,
      188,
      189,
      190,
      192,
      193,
      198,
      199,
      201,
      254,
      255,
      256,
      257,
      258,
      260,
      261,
      262,
      263,
      264,
      265,
      267,
      276,
      277,
      278,
      279,
      280,
      281,
      283,
      290,
      292,
      293,
      294,
      295,
      297,
      298,
      303,
      304,
      305,
      306,
      318,
      319
    ]
  },
  {
    "file_path": "xendit/payment_request/model/qr_code_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass QRCodeChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'None': None,\n            'QRIS': \"QRIS\",\n            'DANA': \"DANA\",\n            'RCBC': \"RCBC\",\n            'LINKAJA': \"LINKAJA\",\n            'PROMPTPAY': \"PROMPTPAY\",\n            'XENDIT': \"XENDIT\",\n            'QRPH': \"QRPH\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"QRCodeChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): QR Code Channel Code., must be one of [\"QRIS\", \"DANA\", \"RCBC\", \"LINKAJA\", \"PROMPTPAY\", \"XENDIT\", \"QRPH\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): QR Code Channel Code., must be one of [\"QRIS\", \"DANA\", \"RCBC\", \"LINKAJA\", \"PROMPTPAY\", \"XENDIT\", \"QRPH\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"QRCodeChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): QR Code Channel Code., must be one of [\"QRIS\", \"DANA\", \"RCBC\", \"LINKAJA\", \"PROMPTPAY\", \"XENDIT\", \"QRPH\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): QR Code Channel Code., must be one of [\"QRIS\", \"DANA\", \"RCBC\", \"LINKAJA\", \"PROMPTPAY\", \"XENDIT\", \"QRPH\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      149,
      151,
      152,
      153,
      154,
      155,
      157,
      163,
      164,
      165,
      166,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      250,
      255,
      267,
      268,
      269,
      270,
      271,
      273,
      290,
      291,
      293
    ]
  },
  {
    "file_path": "xendit/payment_request/model/qr_code_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass QRCodeChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'qr_string': (str, none_type),  # noqa: E501\n            'expires_at': (datetime, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'qr_string': 'qr_string',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"QRCodeChannelProperties - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            qr_string (str): [optional]  # noqa: E501\n            expires_at (datetime): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        qr_string: str | None = None,\n        expires_at: datetime | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"QRCodeChannelProperties - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            qr_string (str): [optional]  # noqa: E501\n            expires_at (datetime): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if qr_string is not None:\n            self.qr_string = qr_string\n        if expires_at is not None:\n            self.expires_at = expires_at\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/payment_request/model/qr_code_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.qr_code_channel_code import QRCodeChannelCode\nfrom xendit.payment_request.model.qr_code_channel_properties import QRCodeChannelProperties\nglobals()['QRCodeChannelCode'] = QRCodeChannelCode\nglobals()['QRCodeChannelProperties'] = QRCodeChannelProperties\n\ndef lazy_import():\n    pass\n\nclass QRCodeParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (QRCodeChannelCode, none_type),  # noqa: E501\n            'channel_properties': (QRCodeChannelProperties, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"QRCodeParameters - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (QRCodeChannelCode): [optional]  # noqa: E501\n            channel_properties (QRCodeChannelProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_code: QRCodeChannelCode | None = None,\n        channel_properties: QRCodeChannelProperties | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"QRCodeParameters - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            channel_code (QRCodeChannelCode): [optional]  # noqa: E501\n            channel_properties (QRCodeChannelProperties): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if channel_code is not None:\n            self.channel_code = channel_code\n        if channel_properties is not None:\n            self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      156,
      157,
      158,
      159,
      160,
      162,
      184,
      241,
      242,
      243,
      244,
      245,
      247,
      248,
      249,
      250,
      251,
      252,
      254,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      271,
      272,
      273,
      274,
      275,
      280,
      281,
      282,
      283
    ]
  },
  {
    "file_path": "xendit/payment_request/model/virtual_account.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.payment_request_currency import PaymentRequestCurrency\nfrom xendit.payment_request.model.virtual_account_all_of import VirtualAccountAllOf\nfrom xendit.payment_request.model.virtual_account_alternative_display import VirtualAccountAlternativeDisplay\nfrom xendit.payment_request.model.virtual_account_channel_code import VirtualAccountChannelCode\nfrom xendit.payment_request.model.virtual_account_channel_properties import VirtualAccountChannelProperties\nfrom xendit.payment_request.model.virtual_account_parameters import VirtualAccountParameters\nglobals()['PaymentRequestCurrency'] = PaymentRequestCurrency\nglobals()['VirtualAccountAllOf'] = VirtualAccountAllOf\nglobals()['VirtualAccountAlternativeDisplay'] = VirtualAccountAlternativeDisplay\nglobals()['VirtualAccountChannelCode'] = VirtualAccountChannelCode\nglobals()['VirtualAccountChannelProperties'] = VirtualAccountChannelProperties\nglobals()['VirtualAccountParameters'] = VirtualAccountParameters\n\ndef lazy_import():\n    pass\n\nclass VirtualAccount(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('alternative_display_types',): {\n            'QR_STRING': \"QR_STRING\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (VirtualAccountChannelCode,),  # noqa: E501\n            'channel_properties': (VirtualAccountChannelProperties,),  # noqa: E501\n            'min_amount': (float, none_type, none_type),  # noqa: E501\n            'max_amount': (float, none_type, none_type),  # noqa: E501\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'currency': (PaymentRequestCurrency, none_type),  # noqa: E501\n            'alternative_display_types': ([str], none_type),  # noqa: E501\n            'alternative_displays': ([VirtualAccountAlternativeDisplay], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'min_amount': 'min_amount',  # noqa: E501\n        'max_amount': 'max_amount',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'alternative_display_types': 'alternative_display_types',  # noqa: E501\n        'alternative_displays': 'alternative_displays',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccount - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (VirtualAccountChannelCode):\n            channel_properties (VirtualAccountChannelProperties):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (PaymentRequestCurrency): [optional]  # noqa: E501\n            alternative_display_types ([str]): Alternative display requested for the virtual account. [optional]  # noqa: E501\n            alternative_displays ([VirtualAccountAlternativeDisplay]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccount - a model defined in OpenAPI\n\n        Keyword Args:\n            channel_code (VirtualAccountChannelCode):\n            channel_properties (VirtualAccountChannelProperties):\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (PaymentRequestCurrency): [optional]  # noqa: E501\n            alternative_display_types ([str]): Alternative display requested for the virtual account. [optional]  # noqa: E501\n            alternative_displays ([VirtualAccountAlternativeDisplay]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              VirtualAccountAllOf,\n              VirtualAccountParameters,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      82,
      83,
      97,
      98,
      111,
      174,
      175,
      176,
      177,
      178,
      180,
      182,
      183,
      184,
      185,
      186,
      187,
      189,
      198,
      199,
      200,
      201,
      202,
      203,
      205,
      212,
      214,
      215,
      216,
      217,
      219,
      220,
      225,
      226,
      228,
      287,
      288,
      289,
      290,
      291,
      293,
      294,
      295,
      296,
      297,
      298,
      300,
      309,
      310,
      311,
      312,
      313,
      314,
      316,
      323,
      325,
      326,
      327,
      328,
      330,
      331,
      336,
      337,
      338,
      339,
      351,
      352
    ]
  },
  {
    "file_path": "xendit/payment_request/model/virtual_account_all_of.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.virtual_account_alternative_display import VirtualAccountAlternativeDisplay\nglobals()['VirtualAccountAlternativeDisplay'] = VirtualAccountAlternativeDisplay\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountAllOf(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'alternative_displays': ([VirtualAccountAlternativeDisplay], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'alternative_displays': 'alternative_displays',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccountAllOf - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            alternative_displays ([VirtualAccountAlternativeDisplay]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        alternative_displays: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"VirtualAccountAllOf - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            alternative_displays ([VirtualAccountAlternativeDisplay]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if alternative_displays is not None:\n            self.alternative_displays = alternative_displays\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      91,
      142,
      143,
      144,
      145,
      146,
      148,
      150,
      151,
      152,
      153,
      154,
      155,
      157,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      174,
      179,
      180,
      181,
      234,
      235,
      236,
      237,
      238,
      240,
      241,
      242,
      243,
      244,
      245,
      247,
      256,
      257,
      258,
      259,
      260,
      261,
      263,
      264,
      265,
      266,
      271,
      272,
      273,
      274
    ]
  },
  {
    "file_path": "xendit/payment_request/model/virtual_account_alternative_display.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountAlternativeDisplay(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('type',): {\n            'QR_STRING': \"QR_STRING\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'type': (str, none_type),  # noqa: E501\n            'data': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'type': 'type',  # noqa: E501\n        'data': 'data',  # noqa: E501\n    }\n\n    read_only_vars = {\n        'type',  # noqa: E501\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccountAlternativeDisplay - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            type (str): Type of the alternative display. [optional] if omitted the server will use the default value of \"QR_STRING\"  # noqa: E501\n            data (str): Data payload of the given alternative display. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        data: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"VirtualAccountAlternativeDisplay - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            type (str): Type of the alternative display. [optional] if omitted the server will use the default value of \"QR_STRING\"  # noqa: E501\n            data (str): Data payload of the given alternative display. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if data is not None:\n            self.data = data\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      91,
      145,
      146,
      147,
      148,
      149,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      160,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      177,
      182,
      183,
      184,
      238,
      239,
      240,
      241,
      242,
      244,
      245,
      246,
      247,
      248,
      249,
      251,
      260,
      261,
      262,
      263,
      264,
      265,
      267,
      268,
      269,
      270,
      275,
      276,
      277,
      278
    ]
  },
  {
    "file_path": "xendit/payment_request/model/virtual_account_channel_code.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountChannelCode(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BCA': \"BCA\",\n            'BJB': \"BJB\",\n            'BNI': \"BNI\",\n            'BRI': \"BRI\",\n            'MANDIRI': \"MANDIRI\",\n            'PERMATA': \"PERMATA\",\n            'BSI': \"BSI\",\n            'CIMB': \"CIMB\",\n            'SAHABAT_SAMPOERNA': \"SAHABAT_SAMPOERNA\",\n            'ARTAJASA': \"ARTAJASA\",\n            'PV': \"PV\",\n            'VIETCAPITAL': \"VIETCAPITAL\",\n            'WOORI': \"WOORI\",\n            'MSB': \"MSB\",\n            'VPB': \"VPB\",\n            'BIDV': \"BIDV\",\n            'STANDARD_CHARTERED': \"STANDARD_CHARTERED\",\n            'AMBANK': \"AMBANK\",\n            'UOB': \"UOB\",\n            'BNC': \"BNC\",\n            'HANA': \"HANA\",\n            'MUAMALAT': \"MUAMALAT\",\n            'BANK_TRANSFER': \"BANK_TRANSFER\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"VirtualAccountChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Virtual Account Channel Code., must be one of [\"BCA\", \"BJB\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"CIMB\", \"SAHABAT_SAMPOERNA\", \"ARTAJASA\", \"PV\", \"VIETCAPITAL\", \"WOORI\", \"MSB\", \"VPB\", \"BIDV\", \"STANDARD_CHARTERED\", \"AMBANK\", \"UOB\", \"BNC\", \"HANA\", \"MUAMALAT\", \"BANK_TRANSFER\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Virtual Account Channel Code., must be one of [\"BCA\", \"BJB\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"CIMB\", \"SAHABAT_SAMPOERNA\", \"ARTAJASA\", \"PV\", \"VIETCAPITAL\", \"WOORI\", \"MSB\", \"VPB\", \"BIDV\", \"STANDARD_CHARTERED\", \"AMBANK\", \"UOB\", \"BNC\", \"HANA\", \"MUAMALAT\", \"BANK_TRANSFER\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"VirtualAccountChannelCode - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Virtual Account Channel Code., must be one of [\"BCA\", \"BJB\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"CIMB\", \"SAHABAT_SAMPOERNA\", \"ARTAJASA\", \"PV\", \"VIETCAPITAL\", \"WOORI\", \"MSB\", \"VPB\", \"BIDV\", \"STANDARD_CHARTERED\", \"AMBANK\", \"UOB\", \"BNC\", \"HANA\", \"MUAMALAT\", \"BANK_TRANSFER\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Virtual Account Channel Code., must be one of [\"BCA\", \"BJB\", \"BNI\", \"BRI\", \"MANDIRI\", \"PERMATA\", \"BSI\", \"CIMB\", \"SAHABAT_SAMPOERNA\", \"ARTAJASA\", \"PV\", \"VIETCAPITAL\", \"WOORI\", \"MSB\", \"VPB\", \"BIDV\", \"STANDARD_CHARTERED\", \"AMBANK\", \"UOB\", \"BNC\", \"HANA\", \"MUAMALAT\", \"BANK_TRANSFER\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      164,
      166,
      167,
      168,
      169,
      170,
      172,
      178,
      179,
      180,
      181,
      183,
      184,
      185,
      186,
      187,
      188,
      190,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      265,
      270,
      282,
      283,
      284,
      285,
      286,
      288,
      305,
      306,
      308
    ]
  },
  {
    "file_path": "xendit/payment_request/model/virtual_account_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'customer_name': (str,),  # noqa: E501\n            'virtual_account_number': (str, none_type),  # noqa: E501\n            'expires_at': (datetime, none_type),  # noqa: E501\n            'suggested_amount': (float, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'customer_name': 'customer_name',  # noqa: E501\n        'virtual_account_number': 'virtual_account_number',  # noqa: E501\n        'expires_at': 'expires_at',  # noqa: E501\n        'suggested_amount': 'suggested_amount',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, customer_name, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccountChannelProperties - a model defined in OpenAPI\n\n        Args:\n            customer_name (str): Name of customer.\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            virtual_account_number (str): You can assign specific Virtual Account number using this parameter. If you do not send one, one will be picked at random. Make sure the number you specify is within your Virtual Account range.. [optional]  # noqa: E501\n            expires_at (datetime): The date and time in ISO 8601 UTC+0 when the virtual account number will be expired. Default: The default expiration date will be 31 years from creation date.. [optional]  # noqa: E501\n            suggested_amount (float): The suggested amount you want to assign. Note: Suggested amounts is the amounts that can see as a suggestion, but user can still put any numbers (only supported for Mandiri and BRI). [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.customer_name = customer_name\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        customer_name: str,\n        virtual_account_number: str | None = None,\n        expires_at: datetime | None = None,\n        suggested_amount: float | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"VirtualAccountChannelProperties - a model defined in OpenAPI\n\n        Args:\n            customer_name (str): Name of customer.\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            virtual_account_number (str): You can assign specific Virtual Account number using this parameter. If you do not send one, one will be picked at random. Make sure the number you specify is within your Virtual Account range.. [optional]  # noqa: E501\n            expires_at (datetime): The date and time in ISO 8601 UTC+0 when the virtual account number will be expired. Default: The default expiration date will be 31 years from creation date.. [optional]  # noqa: E501\n            suggested_amount (float): The suggested amount you want to assign. Note: Suggested amounts is the amounts that can see as a suggestion, but user can still put any numbers (only supported for Mandiri and BRI). [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.customer_name = customer_name\n        if virtual_account_number is not None:\n            self.virtual_account_number = virtual_account_number\n        if expires_at is not None:\n            self.expires_at = expires_at\n        if suggested_amount is not None:\n            self.suggested_amount = suggested_amount\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      158,
      159,
      160,
      161,
      162,
      164,
      182,
      187,
      188,
      250,
      251,
      252,
      253,
      254,
      256,
      257,
      258,
      259,
      260,
      261,
      263,
      272,
      273,
      274,
      275,
      276,
      277,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      292,
      293,
      294,
      295
    ]
  },
  {
    "file_path": "xendit/payment_request/model/virtual_account_parameters.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.70.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payment_request.model.payment_request_currency import PaymentRequestCurrency\nfrom xendit.payment_request.model.virtual_account_channel_code import VirtualAccountChannelCode\nfrom xendit.payment_request.model.virtual_account_channel_properties import VirtualAccountChannelProperties\nglobals()['PaymentRequestCurrency'] = PaymentRequestCurrency\nglobals()['VirtualAccountChannelCode'] = VirtualAccountChannelCode\nglobals()['VirtualAccountChannelProperties'] = VirtualAccountChannelProperties\n\ndef lazy_import():\n    pass\n\nclass VirtualAccountParameters(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('alternative_display_types',): {\n            'QR_STRING': \"QR_STRING\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = True\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (VirtualAccountChannelCode,),  # noqa: E501\n            'channel_properties': (VirtualAccountChannelProperties,),  # noqa: E501\n            'min_amount': (float, none_type, none_type),  # noqa: E501\n            'max_amount': (float, none_type, none_type),  # noqa: E501\n            'amount': (float, none_type, none_type),  # noqa: E501\n            'currency': (PaymentRequestCurrency, none_type),  # noqa: E501\n            'alternative_display_types': ([str], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'min_amount': 'min_amount',  # noqa: E501\n        'max_amount': 'max_amount',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'alternative_display_types': 'alternative_display_types',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, channel_code, channel_properties, *args, **kwargs):  # noqa: E501\n        \"\"\"VirtualAccountParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (VirtualAccountChannelCode):\n            channel_properties (VirtualAccountChannelProperties):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (PaymentRequestCurrency): [optional]  # noqa: E501\n            alternative_display_types ([str]): Alternative display requested for the virtual account. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_code: VirtualAccountChannelCode,\n        channel_properties: VirtualAccountChannelProperties,\n        min_amount: float | None = None,\n        max_amount: float | None = None,\n        amount: float | None = None,\n        currency: PaymentRequestCurrency | None = None,\n        alternative_display_types: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"VirtualAccountParameters - a model defined in OpenAPI\n\n        Args:\n            channel_code (VirtualAccountChannelCode):\n            channel_properties (VirtualAccountChannelProperties):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            min_amount (float, none_type): [optional]  # noqa: E501\n            max_amount (float, none_type): [optional]  # noqa: E501\n            amount (float, none_type): [optional]  # noqa: E501\n            currency (PaymentRequestCurrency): [optional]  # noqa: E501\n            alternative_display_types ([str]): Alternative display requested for the virtual account. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        if min_amount is not None:\n            self.min_amount = min_amount\n        if max_amount is not None:\n            self.max_amount = max_amount\n        if amount is not None:\n            self.amount = amount\n        if currency is not None:\n            self.currency = currency\n        if alternative_display_types is not None:\n            self.alternative_display_types = alternative_display_types\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      76,
      77,
      178,
      179,
      180,
      181,
      182,
      184,
      203,
      208,
      209,
      277,
      278,
      279,
      280,
      281,
      283,
      284,
      285,
      286,
      287,
      288,
      290,
      299,
      300,
      301,
      302,
      303,
      304,
      306,
      307,
      308,
      309,
      310,
      311,
      312,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      324,
      325,
      326,
      327
    ]
  },
  {
    "file_path": "xendit/payout/payout_api.py",
    "code": "\"\"\"\n    Payout Service\n\n    This API allows Xendit to send money from an account to a channel (banks, eWallets, retail outlets) from across regions  # noqa: E501\n\n    The version of the OpenAPI document: 1.0.0\n\"\"\"\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\n\nfrom xendit.api_client import ApiClient, Endpoint as _Endpoint\nfrom xendit.model_utils import (  # noqa: F401\n    check_allowed_values,\n    check_validations,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_and_convert_types\n)\nfrom typing import Optional, List # noqa: F401\n\nfrom xendit.payout.model import *  # noqa: F401,E501\n\nclass PayoutApi(object):\n    \"\"\"NOTE: This class is auto generated by the OpenAPI Generator.\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None):\n        if api_client is None:\n            api_client = ApiClient()\n        self.api_client = api_client\n        self.create_payout_endpoint = _Endpoint(\n            settings={\n                'response_type': (GetPayouts200ResponseDataInner,),\n                'auth': [],\n                'endpoint_path': '/v2/payouts',\n                'operation_id': 'create_payout',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'idempotency_key',\n                    'for_user_id',\n                    'create_payout_request',\n                ],\n                'required': [\n                    'idempotency_key',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'idempotency_key':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'create_payout_request':\n                        (CreatePayoutRequest,),\n                },\n                'attribute_map': {\n                    'idempotency_key': 'idempotency-key',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'idempotency_key': 'header',\n                    'for_user_id': 'header',\n                    'create_payout_request': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n        self.get_payout_by_id_endpoint = _Endpoint(\n            settings={\n                'response_type': (GetPayouts200ResponseDataInner,),\n                'auth': [],\n                'endpoint_path': '/v2/payouts/{id}',\n                'operation_id': 'get_payout_by_id',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'id',\n                    'for_user_id',\n                ],\n                'required': [\n                    'id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'id': 'id',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'id': 'path',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.get_payout_channels_endpoint = _Endpoint(\n            settings={\n                'response_type': ([Channel],),\n                'auth': [],\n                'endpoint_path': '/payouts_channels',\n                'operation_id': 'get_payout_channels',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'currency',\n                    'channel_category',\n                    'channel_code',\n                    'for_user_id',\n                ],\n                'required': [],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'currency':\n                        (str,),\n                    'channel_category':\n                        ([ChannelCategory],),\n                    'channel_code':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'currency': 'currency',\n                    'channel_category': 'channel_category',\n                    'channel_code': 'channel_code',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'currency': 'query',\n                    'channel_category': 'query',\n                    'channel_code': 'query',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                    'channel_category': 'csv',\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.get_payouts_endpoint = _Endpoint(\n            settings={\n                'response_type': (GetPayouts200Response,),\n                'auth': [],\n                'endpoint_path': '/v2/payouts',\n                'operation_id': 'get_payouts',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'reference_id',\n                    'limit',\n                    'after_id',\n                    'before_id',\n                    'for_user_id',\n                ],\n                'required': [\n                    'reference_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'reference_id':\n                        (str,),\n                    'limit':\n                        (float,),\n                    'after_id':\n                        (str,),\n                    'before_id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'reference_id': 'reference_id',\n                    'limit': 'limit',\n                    'after_id': 'after_id',\n                    'before_id': 'before_id',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'reference_id': 'query',\n                    'limit': 'query',\n                    'after_id': 'query',\n                    'before_id': 'query',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.cancel_payout_endpoint = _Endpoint(\n            settings={\n                'response_type': (GetPayouts200ResponseDataInner,),\n                'auth': [],\n                'endpoint_path': '/v2/payouts/{id}/cancel',\n                'operation_id': 'cancel_payout',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'id',\n                    'for_user_id',\n                ],\n                'required': [\n                    'id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'id':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'id': 'id',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'id': 'path',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n\n    def create_payout(\n        self,\n        idempotency_key: str,\n        for_user_id: Optional[str] = None,\n        create_payout_request: Optional[CreatePayoutRequest] = None,\n        **kwargs\n    ) -> GetPayouts200ResponseDataInner:\n        \"\"\"API to send money at scale to bank accounts & eWallets  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.create_payout(idempotency_key, for_user_id, create_payout_request, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            idempotency_key (str): A unique key to prevent duplicate requests from pushing through our system. No expiration.\n\n        Keyword Args:\n            for_user_id (str): The sub-account user-id that you want to make this transaction for. This header is only used if you have access to xenPlatform. See xenPlatform for more information.. [optional]\n            create_payout_request (CreatePayoutRequest): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            GetPayouts200ResponseDataInner\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['idempotency_key'] = idempotency_key\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if create_payout_request is not None:\n            kwargs['create_payout_request'] = create_payout_request\n        return self.create_payout_endpoint.call_with_http_info(**kwargs)\n\n    def get_payout_by_id(\n        self,\n        id: str,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> GetPayouts200ResponseDataInner:\n        \"\"\"API to fetch the current status, or details of the payout  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_payout_by_id(id, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            id (str): Payout id returned from the response of /v2/payouts\n\n        Keyword Args:\n            for_user_id (str): The sub-account user-id that you want to make this transaction for. This header is only used if you have access to xenPlatform. See xenPlatform for more information.. [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            GetPayouts200ResponseDataInner\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['id'] = id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.get_payout_by_id_endpoint.call_with_http_info(**kwargs)\n\n    def get_payout_channels(\n        self,\n        currency: Optional[str] = None,\n        channel_category: Optional[List[ChannelCategory]] = None,\n        channel_code: Optional[str] = None,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> [Channel]:\n        \"\"\"API providing the current list of banks and e-wallets we support for payouts for both regions  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_payout_channels(currency, channel_category, channel_code, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n\n        Keyword Args:\n            currency (str): Filter channels by currency from ISO-4217 values. [optional]\n            channel_category ([ChannelCategory]): Filter channels by category. [optional]\n            channel_code (str): Filter channels by channel code, prefixed by ISO-3166 country code. [optional]\n            for_user_id (str): The sub-account user-id that you want to make this transaction for. This header is only used if you have access to xenPlatform. See xenPlatform for more information.. [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            [Channel]\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        if currency is not None:\n            kwargs['currency'] = currency\n        if channel_category is not None:\n            kwargs['channel_category'] = channel_category\n        if channel_code is not None:\n            kwargs['channel_code'] = channel_code\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.get_payout_channels_endpoint.call_with_http_info(**kwargs)\n\n    def get_payouts(\n        self,\n        reference_id: str,\n        limit: Optional[float] = None,\n        after_id: Optional[str] = None,\n        before_id: Optional[str] = None,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> GetPayouts200Response:\n        \"\"\"API to retrieve all matching payouts with reference ID  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_payouts(reference_id, limit, after_id, before_id, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            reference_id (str): Reference_id provided when creating the payout\n\n        Keyword Args:\n            limit (float): Number of records to fetch per API call. [optional]\n            after_id (str): Used to fetch record after this payout unique id. [optional]\n            before_id (str): Used to fetch record before this payout unique id. [optional]\n            for_user_id (str): The sub-account user-id that you want to make this transaction for. This header is only used if you have access to xenPlatform. See xenPlatform for more information.. [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            GetPayouts200Response\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['reference_id'] = reference_id\n        if limit is not None:\n            kwargs['limit'] = limit\n        if after_id is not None:\n            kwargs['after_id'] = after_id\n        if before_id is not None:\n            kwargs['before_id'] = before_id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.get_payouts_endpoint.call_with_http_info(**kwargs)\n\n    def cancel_payout(\n        self,\n        id: str,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> GetPayouts200ResponseDataInner:\n        \"\"\"API to cancel requested payouts that have not yet been sent to partner banks and e-wallets. Cancellation is possible if the payout has not been sent out via our partner and when payout status is ACCEPTED.  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.cancel_payout(id, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            id (str): Payout id returned from the response of /v2/payouts\n\n        Keyword Args:\n            for_user_id (str): The sub-account user-id that you want to make this transaction for. This header is only used if you have access to xenPlatform. See xenPlatform for more information.. [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            GetPayouts200ResponseDataInner\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['id'] = id\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.cancel_payout_endpoint.call_with_http_info(**kwargs)\n\n",
    "uncovered_lines": [
      32,
      33,
      34,
      35,
      95,
      149,
      212,
      281,
      393,
      396,
      399,
      402,
      405,
      408,
      411,
      414,
      416,
      417,
      418,
      419,
      420,
      421,
      422,
      423,
      480,
      483,
      486,
      489,
      492,
      495,
      498,
      501,
      503,
      504,
      505,
      506,
      507,
      508,
      568,
      571,
      574,
      577,
      580,
      583,
      586,
      589,
      591,
      592,
      593,
      594,
      595,
      596,
      597,
      598,
      599,
      600,
      601,
      664,
      667,
      670,
      673,
      676,
      679,
      682,
      685,
      687,
      688,
      689,
      690,
      691,
      692,
      693,
      694,
      695,
      696,
      697,
      698,
      755,
      758,
      761,
      764,
      767,
      770,
      773,
      776,
      778,
      779,
      780,
      781,
      782,
      783
    ]
  },
  {
    "file_path": "xendit/payout/model/channel.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payout.model.channel_amount_limits import ChannelAmountLimits\nfrom xendit.payout.model.channel_category import ChannelCategory\nglobals()['ChannelAmountLimits'] = ChannelAmountLimits\nglobals()['ChannelCategory'] = ChannelCategory\n\ndef lazy_import():\n    pass\n\nclass Channel(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'channel_code': (str,),  # noqa: E501\n            'channel_category': (ChannelCategory,),  # noqa: E501\n            'currency': (str,),  # noqa: E501\n            'channel_name': (str,),  # noqa: E501\n            'amount_limits': (ChannelAmountLimits,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_category': 'channel_category',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'channel_name': 'channel_name',  # noqa: E501\n        'amount_limits': 'amount_limits',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, channel_code, channel_category, currency, channel_name, amount_limits, *args, **kwargs):  # noqa: E501\n        \"\"\"Channel - a model defined in OpenAPI\n\n        Args:\n            channel_code (str): Destination channel to send the money to, prefixed by ISO-3166 country code\n            channel_category (ChannelCategory):\n            currency (str): Currency of the destination channel using ISO-4217 currency code\n            channel_name (str): Name of the destination channel\n            amount_limits (ChannelAmountLimits):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_category = channel_category\n        self.currency = currency\n        self.channel_name = channel_name\n        self.amount_limits = amount_limits\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        channel_code: str,\n        channel_category: ChannelCategory,\n        currency: str,\n        channel_name: str,\n        amount_limits: ChannelAmountLimits,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Channel - a model defined in OpenAPI\n\n        Args:\n            channel_code (str): Destination channel to send the money to, prefixed by ISO-3166 country code\n            channel_category (ChannelCategory):\n            currency (str): Currency of the destination channel using ISO-4217 currency code\n            channel_name (str): Name of the destination channel\n            amount_limits (ChannelAmountLimits):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.channel_code = channel_code\n        self.channel_category = channel_category\n        self.currency = currency\n        self.channel_name = channel_name\n        self.amount_limits = amount_limits\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      86,
      87,
      97,
      158,
      159,
      160,
      161,
      162,
      164,
      166,
      167,
      168,
      169,
      170,
      171,
      173,
      182,
      183,
      184,
      185,
      186,
      187,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      200,
      201,
      202,
      265,
      266,
      267,
      268,
      269,
      271,
      272,
      273,
      274,
      275,
      276,
      278,
      287,
      288,
      289,
      290,
      291,
      292,
      294,
      295,
      296,
      297,
      298,
      299,
      300,
      305,
      306,
      307,
      308
    ]
  },
  {
    "file_path": "xendit/payout/model/channel_account_type.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ChannelAccountType(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'NATIONAL_ID': \"NATIONAL_ID\",\n            'MOBILE_NO': \"MOBILE_NO\",\n            'PASSPORT': \"PASSPORT\",\n            'BUSINESS_REGISTRATION': \"BUSINESS_REGISTRATION\",\n            'BANK_ACCOUNT': \"BANK_ACCOUNT\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"ChannelAccountType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Available account types (applicable for MY_DUITNOW)., must be one of [\"NATIONAL_ID\", \"MOBILE_NO\", \"PASSPORT\", \"BUSINESS_REGISTRATION\", \"BANK_ACCOUNT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Available account types (applicable for MY_DUITNOW)., must be one of [\"NATIONAL_ID\", \"MOBILE_NO\", \"PASSPORT\", \"BUSINESS_REGISTRATION\", \"BANK_ACCOUNT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"ChannelAccountType - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Available account types (applicable for MY_DUITNOW)., must be one of [\"NATIONAL_ID\", \"MOBILE_NO\", \"PASSPORT\", \"BUSINESS_REGISTRATION\", \"BANK_ACCOUNT\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Available account types (applicable for MY_DUITNOW)., must be one of [\"NATIONAL_ID\", \"MOBILE_NO\", \"PASSPORT\", \"BUSINESS_REGISTRATION\", \"BANK_ACCOUNT\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      79,
      85,
      146,
      148,
      149,
      150,
      151,
      152,
      154,
      160,
      161,
      162,
      163,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      242,
      244,
      246,
      247,
      248,
      249,
      250,
      252,
      258,
      259,
      260,
      261,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      289,
      290,
      299
    ]
  },
  {
    "file_path": "xendit/payout/model/channel_amount_limits.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ChannelAmountLimits(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'minimum': (float,),  # noqa: E501\n            'maximum': (float,),  # noqa: E501\n            'minimum_increment': (float,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'minimum': 'minimum',  # noqa: E501\n        'maximum': 'maximum',  # noqa: E501\n        'minimum_increment': 'minimum_increment',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, minimum, maximum, minimum_increment, *args, **kwargs):  # noqa: E501\n        \"\"\"ChannelAmountLimits - a model defined in OpenAPI\n\n        Args:\n            minimum (float): Lowest amount supported for a payout to this channel\n            maximum (float): Highest amount supported for a payout to this channel\n            minimum_increment (float): Supported increments\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.minimum = minimum\n        self.maximum = maximum\n        self.minimum_increment = minimum_increment\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        minimum: float,\n        maximum: float,\n        minimum_increment: float,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ChannelAmountLimits - a model defined in OpenAPI\n\n        Args:\n            minimum (float): Lowest amount supported for a payout to this channel\n            maximum (float): Highest amount supported for a payout to this channel\n            minimum_increment (float): Supported increments\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.minimum = minimum\n        self.maximum = maximum\n        self.minimum_increment = minimum_increment\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      146,
      147,
      148,
      149,
      150,
      152,
      154,
      155,
      156,
      157,
      158,
      159,
      161,
      170,
      171,
      172,
      173,
      174,
      175,
      177,
      178,
      179,
      180,
      181,
      186,
      187,
      188,
      247,
      248,
      249,
      250,
      251,
      253,
      254,
      255,
      256,
      257,
      258,
      260,
      269,
      270,
      271,
      272,
      273,
      274,
      276,
      277,
      278,
      279,
      280,
      285,
      286,
      287,
      288
    ]
  },
  {
    "file_path": "xendit/payout/model/channel_category.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ChannelCategory(ModelSimple):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('value',): {\n            'BANK': \"BANK\",\n            'EWALLET': \"EWALLET\",\n            'OTC': \"OTC\",\n            'XENDIT_ENUM_DEFAULT_FALLBACK': 'UNKNOWN_ENUM_VALUE',\n        },\n    }\n\n    validations = {\n    }\n\n    additional_properties_type = None\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'value': (str,),\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {}\n\n    read_only_vars = set()\n\n    _composed_schemas = None\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):\n        \"\"\"ChannelCategory - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Category of channel code, as some channels might require more fields during processing., must be one of [\"BANK\", \"EWALLET\", \"OTC\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Category of channel code, as some channels might require more fields during processing., must be one of [\"BANK\", \"EWALLET\", \"OTC\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        self.value = value\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):\n        \"\"\"ChannelCategory - a model defined in OpenAPI\n\n        Note that value can be passed either in args or in kwargs, but not in both.\n\n        Args:\n            args[0] (str): Category of channel code, as some channels might require more fields during processing., must be one of [\"BANK\", \"EWALLET\", \"OTC\", ]  # noqa: E501\n\n        Keyword Args:\n            value (str): Category of channel code, as some channels might require more fields during processing., must be one of [\"BANK\", \"EWALLET\", \"OTC\", ]  # noqa: E501\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n        # required up here when default value is not given\n        _path_to_item = kwargs.pop('_path_to_item', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if 'value' in kwargs:\n            value = kwargs.pop('value')\n        elif args:\n            args = list(args)\n            value = args.pop(0)\n        else:\n            raise ApiTypeError(\n                \"value is required, but not passed in args or kwargs and doesn't have default\",\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n        try:\n            self.value = value\n        except ValueError:\n            self.value = self.allowed_values[('value',)]['XENDIT_ENUM_DEFAULT_FALLBACK']\n        if kwargs:\n            raise ApiTypeError(\n                \"Invalid named arguments=%s passed to %s. Remove those invalid named arguments.\" % (\n                    kwargs,\n                    self.__class__.__name__,\n                ),\n                path_to_item=_path_to_item,\n                valid_classes=(self.__class__,),\n            )\n\n        return self\n",
    "uncovered_lines": [
      77,
      83,
      144,
      146,
      147,
      148,
      149,
      150,
      152,
      158,
      159,
      160,
      161,
      163,
      164,
      165,
      166,
      167,
      168,
      170,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      240,
      242,
      244,
      245,
      246,
      247,
      248,
      250,
      256,
      257,
      258,
      259,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      277,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      285,
      286,
      287,
      288,
      297
    ]
  },
  {
    "file_path": "xendit/payout/model/create_payout_request.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payout.model.digital_payout_channel_properties import DigitalPayoutChannelProperties\nfrom xendit.payout.model.receipt_notification import ReceiptNotification\nglobals()['DigitalPayoutChannelProperties'] = DigitalPayoutChannelProperties\nglobals()['ReceiptNotification'] = ReceiptNotification\n\ndef lazy_import():\n    pass\n\nclass CreatePayoutRequest(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n        ('reference_id',): {\n            'min_length': 1,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'reference_id': (str,),  # noqa: E501\n            'channel_code': (str,),  # noqa: E501\n            'channel_properties': (DigitalPayoutChannelProperties,),  # noqa: E501\n            'amount': (float,),  # noqa: E501\n            'currency': (str,),  # noqa: E501\n            'description': (str, none_type),  # noqa: E501\n            'receipt_notification': (ReceiptNotification, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'reference_id': 'reference_id',  # noqa: E501\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'receipt_notification': 'receipt_notification',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, reference_id, channel_code, channel_properties, amount, currency, *args, **kwargs):  # noqa: E501\n        \"\"\"CreatePayoutRequest - a model defined in OpenAPI\n\n        Args:\n            reference_id (str): A client defined payout identifier\n            channel_code (str): Channel code of selected destination bank or e-wallet\n            channel_properties (DigitalPayoutChannelProperties):\n            amount (float): Amount to be sent to the destination account and should be a multiple of the minimum increment for the selected channel\n            currency (str): Currency of the destination channel using ISO-4217 currency code\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            description (str): Description to send with the payout, the recipient may see this e.g., in their bank statement (if supported) or in email receipts we send on your behalf. [optional]  # noqa: E501\n            receipt_notification (ReceiptNotification): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): Object of additional information you may use. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.reference_id = reference_id\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        self.amount = amount\n        self.currency = currency\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        reference_id: str,\n        channel_code: str,\n        channel_properties: DigitalPayoutChannelProperties,\n        amount: float,\n        currency: str,\n        description: str | None = None,\n        receipt_notification: ReceiptNotification | None = None,\n        metadata: dict | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CreatePayoutRequest - a model defined in OpenAPI\n\n        Args:\n            reference_id (str): A client defined payout identifier\n            channel_code (str): Channel code of selected destination bank or e-wallet\n            channel_properties (DigitalPayoutChannelProperties):\n            amount (float): Amount to be sent to the destination account and should be a multiple of the minimum increment for the selected channel\n            currency (str): Currency of the destination channel using ISO-4217 currency code\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            description (str): Description to send with the payout, the recipient may see this e.g., in their bank statement (if supported) or in email receipts we send on your behalf. [optional]  # noqa: E501\n            receipt_notification (ReceiptNotification): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): Object of additional information you may use. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.reference_id = reference_id\n        self.channel_code = channel_code\n        self.channel_properties = channel_properties\n        self.amount = amount\n        self.currency = currency\n        if description is not None:\n            self.description = description\n        if receipt_notification is not None:\n            self.receipt_notification = receipt_notification\n        if metadata is not None:\n            self.metadata = metadata\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      74,
      75,
      89,
      90,
      103,
      170,
      171,
      172,
      173,
      174,
      176,
      178,
      179,
      180,
      181,
      182,
      183,
      185,
      194,
      195,
      196,
      197,
      198,
      199,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      212,
      213,
      214,
      283,
      284,
      285,
      286,
      287,
      289,
      290,
      291,
      292,
      293,
      294,
      296,
      305,
      306,
      307,
      308,
      309,
      310,
      312,
      313,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      322,
      323,
      324,
      329,
      330,
      331,
      332
    ]
  },
  {
    "file_path": "xendit/payout/model/digital_payout_channel_properties.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payout.model.channel_account_type import ChannelAccountType\nglobals()['ChannelAccountType'] = ChannelAccountType\n\ndef lazy_import():\n    pass\n\nclass DigitalPayoutChannelProperties(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'account_number': (str,),  # noqa: E501\n            'account_holder_name': (str, none_type, none_type),  # noqa: E501\n            'account_type': (ChannelAccountType, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'account_number': 'account_number',  # noqa: E501\n        'account_holder_name': 'account_holder_name',  # noqa: E501\n        'account_type': 'account_type',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, account_number, *args, **kwargs):  # noqa: E501\n        \"\"\"DigitalPayoutChannelProperties - a model defined in OpenAPI\n\n        Args:\n            account_number (str): Registered account number\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_holder_name (str, none_type): Registered account name. [optional]  # noqa: E501\n            account_type (ChannelAccountType): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.account_number = account_number\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        account_number: str,\n        account_holder_name: str | None = None,\n        account_type: ChannelAccountType | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"DigitalPayoutChannelProperties - a model defined in OpenAPI\n\n        Args:\n            account_number (str): Registered account number\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            account_holder_name (str, none_type): Registered account name. [optional]  # noqa: E501\n            account_type (ChannelAccountType): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.account_number = account_number\n        if account_holder_name is not None:\n            self.account_holder_name = account_holder_name\n        if account_type is not None:\n            self.account_type = account_type\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      93,
      150,
      151,
      152,
      153,
      154,
      156,
      158,
      159,
      160,
      161,
      162,
      163,
      165,
      174,
      175,
      176,
      177,
      178,
      179,
      181,
      182,
      183,
      188,
      189,
      190,
      249,
      250,
      251,
      252,
      253,
      255,
      256,
      257,
      258,
      259,
      260,
      262,
      271,
      272,
      273,
      274,
      275,
      276,
      278,
      279,
      280,
      281,
      282,
      283,
      284,
      289,
      290,
      291,
      292
    ]
  },
  {
    "file_path": "xendit/payout/model/error.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payout.model.error_errors_inner import ErrorErrorsInner\nglobals()['ErrorErrorsInner'] = ErrorErrorsInner\n\ndef lazy_import():\n    pass\n\nclass Error(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'error_code': (str,),  # noqa: E501\n            'message': (str,),  # noqa: E501\n            'errors': ([ErrorErrorsInner], none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n        'errors': 'errors',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, error_code, message, *args, **kwargs):  # noqa: E501\n        \"\"\"Error - a model defined in OpenAPI\n\n        Args:\n            error_code (str): Specific error encountered when processing the request, can refer to the API documentation on proper handling of each available error code https://developers.xendit.co/api-reference/#payouts\n            message (str): Human readable error message\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            errors ([ErrorErrorsInner]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str,\n        message: str,\n        errors: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Error - a model defined in OpenAPI\n\n        Args:\n            error_code (str): Specific error encountered when processing the request, can refer to the API documentation on proper handling of each available error code https://developers.xendit.co/api-reference/#payouts\n            message (str): Human readable error message\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            errors ([ErrorErrorsInner]): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.error_code = error_code\n        self.message = message\n        if errors is not None:\n            self.errors = errors\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      93,
      150,
      151,
      152,
      153,
      154,
      156,
      158,
      159,
      160,
      161,
      162,
      163,
      165,
      174,
      175,
      176,
      177,
      178,
      179,
      181,
      182,
      183,
      184,
      189,
      190,
      191,
      250,
      251,
      252,
      253,
      254,
      256,
      257,
      258,
      259,
      260,
      261,
      263,
      272,
      273,
      274,
      275,
      276,
      277,
      279,
      280,
      281,
      282,
      283,
      284,
      289,
      290,
      291,
      292
    ]
  },
  {
    "file_path": "xendit/payout/model/error_errors_inner.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ErrorErrorsInner(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'path': (str,),  # noqa: E501\n            'message': (str,),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'path': 'path',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, path, message, *args, **kwargs):  # noqa: E501\n        \"\"\"ErrorErrorsInner - a model defined in OpenAPI\n\n        Args:\n            path (str): Precise location of the error\n            message (str): Specific description of the error\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.path = path\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        path: str,\n        message: str,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ErrorErrorsInner - a model defined in OpenAPI\n\n        Args:\n            path (str): Precise location of the error\n            message (str): Specific description of the error\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.path = path\n        self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      143,
      144,
      145,
      146,
      147,
      149,
      151,
      152,
      153,
      154,
      155,
      156,
      158,
      167,
      168,
      169,
      170,
      171,
      172,
      174,
      175,
      176,
      177,
      182,
      183,
      184,
      241,
      242,
      243,
      244,
      245,
      247,
      248,
      249,
      250,
      251,
      252,
      254,
      263,
      264,
      265,
      266,
      267,
      268,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/payout/model/get_payouts200_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payout.model.get_payouts200_response_data_inner import GetPayouts200ResponseDataInner\nfrom xendit.payout.model.get_payouts200_response_links import GetPayouts200ResponseLinks\nglobals()['GetPayouts200ResponseDataInner'] = GetPayouts200ResponseDataInner\nglobals()['GetPayouts200ResponseLinks'] = GetPayouts200ResponseLinks\n\ndef lazy_import():\n    pass\n\nclass GetPayouts200Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'data': ([GetPayouts200ResponseDataInner], none_type),  # noqa: E501\n            'has_more': (bool, none_type),  # noqa: E501\n            'links': (GetPayouts200ResponseLinks, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'data': 'data',  # noqa: E501\n        'has_more': 'has_more',  # noqa: E501\n        'links': 'links',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"GetPayouts200Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            data ([GetPayouts200ResponseDataInner]): [optional]  # noqa: E501\n            has_more (bool): [optional]  # noqa: E501\n            links (GetPayouts200ResponseLinks): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        data: list | None = None,\n        has_more: bool | None = None,\n        links: GetPayouts200ResponseLinks | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"GetPayouts200Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            data ([GetPayouts200ResponseDataInner]): [optional]  # noqa: E501\n            has_more (bool): [optional]  # noqa: E501\n            links (GetPayouts200ResponseLinks): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if data is not None:\n            self.data = data\n        if has_more is not None:\n            self.has_more = has_more\n        if links is not None:\n            self.links = links\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      72,
      86,
      87,
      95,
      150,
      151,
      152,
      153,
      154,
      156,
      158,
      159,
      160,
      161,
      162,
      163,
      165,
      174,
      175,
      176,
      177,
      178,
      179,
      181,
      182,
      187,
      188,
      189,
      246,
      247,
      248,
      249,
      250,
      252,
      253,
      254,
      255,
      256,
      257,
      259,
      268,
      269,
      270,
      271,
      272,
      273,
      275,
      276,
      277,
      278,
      279,
      280,
      281,
      282,
      287,
      288,
      289,
      290
    ]
  },
  {
    "file_path": "xendit/payout/model/get_payouts200_response_data_inner.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payout.model.digital_payout_channel_properties import DigitalPayoutChannelProperties\nfrom xendit.payout.model.payout import Payout\nfrom xendit.payout.model.receipt_notification import ReceiptNotification\nglobals()['DigitalPayoutChannelProperties'] = DigitalPayoutChannelProperties\nglobals()['Payout'] = Payout\nglobals()['ReceiptNotification'] = ReceiptNotification\n\ndef lazy_import():\n    pass\n\nclass GetPayouts200ResponseDataInner(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('failure_code',): {\n            'INSUFFICIENT_BALANCE': \"INSUFFICIENT_BALANCE\",\n            'REJECTED_BY_CHANNEL': \"REJECTED_BY_CHANNEL\",\n            'TEMPORARY_TRANSFER_ERROR': \"TEMPORARY_TRANSFER_ERROR\",\n            'INVALID_DESTINATION': \"INVALID_DESTINATION\",\n            'TRANSFER_ERROR': \"TRANSFER_ERROR\",\n        },\n        ('status',): {\n            'SUCCEEDED': \"SUCCEEDED\",\n            'FAILED': \"FAILED\",\n            'ACCEPTED': \"ACCEPTED\",\n            'REQUESTED': \"REQUESTED\",\n            'LOCKED': \"LOCKED\",\n            'CANCELLED': \"CANCELLED\",\n            'REVERSED': \"REVERSED\",\n        },\n    }\n\n    validations = {\n        ('reference_id',): {\n            'min_length': 1,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'description': (str, none_type),  # noqa: E501\n            'receipt_notification': (ReceiptNotification, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type),  # noqa: E501\n            'failure_code': (str, none_type),  # noqa: E501\n            'estimated_arrival_time': (datetime, none_type),  # noqa: E501\n            'reference_id': (str, none_type),  # noqa: E501\n            'channel_code': (str, none_type),  # noqa: E501\n            'channel_properties': (DigitalPayoutChannelProperties, none_type),  # noqa: E501\n            'amount': (float, none_type),  # noqa: E501\n            'currency': (str, none_type),  # noqa: E501\n            'id': (str, none_type),  # noqa: E501\n            'created': (datetime, none_type),  # noqa: E501\n            'updated': (datetime, none_type),  # noqa: E501\n            'business_id': (str, none_type),  # noqa: E501\n            'status': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'description': 'description',  # noqa: E501\n        'receipt_notification': 'receipt_notification',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n        'failure_code': 'failure_code',  # noqa: E501\n        'estimated_arrival_time': 'estimated_arrival_time',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'id': 'id',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'business_id': 'business_id',  # noqa: E501\n        'status': 'status',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"GetPayouts200ResponseDataInner - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            description (str): Description to send with the payout, the recipient may see this e.g., in their bank statement (if supported) or in email receipts we send on your behalf. [optional]  # noqa: E501\n            receipt_notification (ReceiptNotification): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): Object of additional information you may use. [optional]  # noqa: E501\n            failure_code (str): If the Payout failed, we include a failure code for more details on the failure.. [optional]  # noqa: E501\n            estimated_arrival_time (datetime): Our estimated time on to when your payout is reflected to the destination account. [optional]  # noqa: E501\n            reference_id (str): A client defined payout identifier. [optional]  # noqa: E501\n            channel_code (str): Channel code of selected destination bank or e-wallet. [optional]  # noqa: E501\n            channel_properties (DigitalPayoutChannelProperties): [optional]  # noqa: E501\n            amount (float): Amount to be sent to the destination account and should be a multiple of the minimum increment for the selected channel. [optional]  # noqa: E501\n            currency (str): Currency of the destination channel using ISO-4217 currency code. [optional]  # noqa: E501\n            id (str): Xendit-generated unique identifier for each payout. [optional]  # noqa: E501\n            created (datetime): The time payout was created on Xendit's system, in ISO 8601 format. [optional]  # noqa: E501\n            updated (datetime): The time payout was last updated on Xendit's system, in ISO 8601 format. [optional]  # noqa: E501\n            business_id (str): Xendit Business ID. [optional]  # noqa: E501\n            status (str): Status of payout. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"GetPayouts200ResponseDataInner - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            description (str): Description to send with the payout, the recipient may see this e.g., in their bank statement (if supported) or in email receipts we send on your behalf. [optional]  # noqa: E501\n            receipt_notification (ReceiptNotification): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): Object of additional information you may use. [optional]  # noqa: E501\n            failure_code (str): If the Payout failed, we include a failure code for more details on the failure.. [optional]  # noqa: E501\n            estimated_arrival_time (datetime): Our estimated time on to when your payout is reflected to the destination account. [optional]  # noqa: E501\n            reference_id (str): A client defined payout identifier. [optional]  # noqa: E501\n            channel_code (str): Channel code of selected destination bank or e-wallet. [optional]  # noqa: E501\n            channel_properties (DigitalPayoutChannelProperties): [optional]  # noqa: E501\n            amount (float): Amount to be sent to the destination account and should be a multiple of the minimum increment for the selected channel. [optional]  # noqa: E501\n            currency (str): Currency of the destination channel using ISO-4217 currency code. [optional]  # noqa: E501\n            id (str): Xendit-generated unique identifier for each payout. [optional]  # noqa: E501\n            created (datetime): The time payout was created on Xendit's system, in ISO 8601 format. [optional]  # noqa: E501\n            updated (datetime): The time payout was last updated on Xendit's system, in ISO 8601 format. [optional]  # noqa: E501\n            business_id (str): Xendit Business ID. [optional]  # noqa: E501\n            status (str): Status of payout. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n              Payout,\n          ],\n          'allOf': [\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      92,
      93,
      107,
      108,
      128,
      205,
      206,
      207,
      208,
      209,
      211,
      213,
      214,
      215,
      216,
      217,
      218,
      220,
      229,
      230,
      231,
      232,
      233,
      234,
      236,
      243,
      245,
      246,
      247,
      248,
      250,
      251,
      256,
      257,
      259,
      325,
      326,
      327,
      328,
      329,
      331,
      332,
      333,
      334,
      335,
      336,
      338,
      347,
      348,
      349,
      350,
      351,
      352,
      354,
      361,
      363,
      364,
      365,
      366,
      368,
      369,
      374,
      375,
      376,
      377,
      389,
      390
    ]
  },
  {
    "file_path": "xendit/payout/model/get_payouts200_response_links.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass GetPayouts200ResponseLinks(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'href': (str, none_type),  # noqa: E501\n            'rel': (str, none_type),  # noqa: E501\n            'method': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'href': 'href',  # noqa: E501\n        'rel': 'rel',  # noqa: E501\n        'method': 'method',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"GetPayouts200ResponseLinks - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            href (str): [optional]  # noqa: E501\n            rel (str): [optional]  # noqa: E501\n            method (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        href: str | None = None,\n        rel: str | None = None,\n        method: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"GetPayouts200ResponseLinks - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            href (str): [optional]  # noqa: E501\n            rel (str): [optional]  # noqa: E501\n            method (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if href is not None:\n            self.href = href\n        if rel is not None:\n            self.rel = rel\n        if method is not None:\n            self.method = method\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      181,
      182,
      183,
      240,
      241,
      242,
      243,
      244,
      246,
      247,
      248,
      249,
      250,
      251,
      253,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      275,
      276,
      281,
      282,
      283,
      284
    ]
  },
  {
    "file_path": "xendit/payout/model/payout.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.payout.model.create_payout_request import CreatePayoutRequest\nfrom xendit.payout.model.digital_payout_channel_properties import DigitalPayoutChannelProperties\nfrom xendit.payout.model.payout_all_of import PayoutAllOf\nfrom xendit.payout.model.receipt_notification import ReceiptNotification\nglobals()['CreatePayoutRequest'] = CreatePayoutRequest\nglobals()['DigitalPayoutChannelProperties'] = DigitalPayoutChannelProperties\nglobals()['PayoutAllOf'] = PayoutAllOf\nglobals()['ReceiptNotification'] = ReceiptNotification\n\ndef lazy_import():\n    pass\n\nclass Payout(ModelComposed):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('status',): {\n            'SUCCEEDED': \"SUCCEEDED\",\n            'FAILED': \"FAILED\",\n            'ACCEPTED': \"ACCEPTED\",\n            'REQUESTED': \"REQUESTED\",\n            'LOCKED': \"LOCKED\",\n            'CANCELLED': \"CANCELLED\",\n            'REVERSED': \"REVERSED\",\n        },\n        ('failure_code',): {\n            'INSUFFICIENT_BALANCE': \"INSUFFICIENT_BALANCE\",\n            'REJECTED_BY_CHANNEL': \"REJECTED_BY_CHANNEL\",\n            'TEMPORARY_TRANSFER_ERROR': \"TEMPORARY_TRANSFER_ERROR\",\n            'INVALID_DESTINATION': \"INVALID_DESTINATION\",\n            'TRANSFER_ERROR': \"TRANSFER_ERROR\",\n        },\n    }\n\n    validations = {\n        ('reference_id',): {\n            'min_length': 1,\n        },\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'reference_id': (str,),  # noqa: E501\n            'channel_code': (str,),  # noqa: E501\n            'channel_properties': (DigitalPayoutChannelProperties,),  # noqa: E501\n            'amount': (float,),  # noqa: E501\n            'currency': (str,),  # noqa: E501\n            'id': (str,),  # noqa: E501\n            'created': (datetime,),  # noqa: E501\n            'updated': (datetime,),  # noqa: E501\n            'business_id': (str,),  # noqa: E501\n            'status': (str,),  # noqa: E501\n            'description': (str, none_type),  # noqa: E501\n            'receipt_notification': (ReceiptNotification, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type),  # noqa: E501\n            'failure_code': (str, none_type),  # noqa: E501\n            'estimated_arrival_time': (datetime, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'reference_id': 'reference_id',  # noqa: E501\n        'channel_code': 'channel_code',  # noqa: E501\n        'channel_properties': 'channel_properties',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'id': 'id',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'business_id': 'business_id',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'description': 'description',  # noqa: E501\n        'receipt_notification': 'receipt_notification',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n        'failure_code': 'failure_code',  # noqa: E501\n        'estimated_arrival_time': 'estimated_arrival_time',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"Payout - a model defined in OpenAPI\n\n        Keyword Args:\n            reference_id (str): A client defined payout identifier\n            channel_code (str): Channel code of selected destination bank or e-wallet\n            channel_properties (DigitalPayoutChannelProperties):\n            amount (float): Amount to be sent to the destination account and should be a multiple of the minimum increment for the selected channel\n            currency (str): Currency of the destination channel using ISO-4217 currency code\n            id (str): Xendit-generated unique identifier for each payout\n            created (datetime): The time payout was created on Xendit's system, in ISO 8601 format\n            updated (datetime): The time payout was last updated on Xendit's system, in ISO 8601 format\n            business_id (str): Xendit Business ID\n            status (str): Status of payout\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            description (str): Description to send with the payout, the recipient may see this e.g., in their bank statement (if supported) or in email receipts we send on your behalf. [optional]  # noqa: E501\n            receipt_notification (ReceiptNotification): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): Object of additional information you may use. [optional]  # noqa: E501\n            failure_code (str): If the Payout failed, we include a failure code for more details on the failure.. [optional]  # noqa: E501\n            estimated_arrival_time (datetime): Our estimated time on to when your payout is reflected to the destination account. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n        '_composed_instances',\n        '_var_name_to_model_instances',\n        '_additional_properties_model_instances',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self, *args, **kwargs):  # noqa: E501\n        \"\"\"Payout - a model defined in OpenAPI\n\n        Keyword Args:\n            reference_id (str): A client defined payout identifier\n            channel_code (str): Channel code of selected destination bank or e-wallet\n            channel_properties (DigitalPayoutChannelProperties):\n            amount (float): Amount to be sent to the destination account and should be a multiple of the minimum increment for the selected channel\n            currency (str): Currency of the destination channel using ISO-4217 currency code\n            id (str): Xendit-generated unique identifier for each payout\n            created (datetime): The time payout was created on Xendit's system, in ISO 8601 format\n            updated (datetime): The time payout was last updated on Xendit's system, in ISO 8601 format\n            business_id (str): Xendit Business ID\n            status (str): Status of payout\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            description (str): Description to send with the payout, the recipient may see this e.g., in their bank statement (if supported) or in email receipts we send on your behalf. [optional]  # noqa: E501\n            receipt_notification (ReceiptNotification): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}): Object of additional information you may use. [optional]  # noqa: E501\n            failure_code (str): If the Payout failed, we include a failure code for more details on the failure.. [optional]  # noqa: E501\n            estimated_arrival_time (datetime): Our estimated time on to when your payout is reflected to the destination account. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        constant_args = {\n            '_check_type': _check_type,\n            '_path_to_item': _path_to_item,\n            '_spec_property_naming': _spec_property_naming,\n            '_configuration': _configuration,\n            '_visited_composed_classes': self._visited_composed_classes,\n        }\n        composed_info = validate_get_composed_info(\n            constant_args, kwargs, self)\n        self._composed_instances = composed_info[0]\n        self._var_name_to_model_instances = composed_info[1]\n        self._additional_properties_model_instances = composed_info[2]\n        discarded_args = composed_info[3]\n\n        for var_name, var_value in kwargs.items():\n            if var_name in discarded_args and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self._additional_properties_model_instances:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n\n    @cached_property\n    def _composed_schemas():\n        # we need this here to make our import statements work\n        # we must store _composed_schemas in here so the code is only run\n        # when we invoke this method. If we kept this at the class\n        # level we would get an error because the class level\n        # code would be run when this module is imported, and these composed\n        # classes don't exist yet because their module has not finished\n        # loading\n        lazy_import()\n        return {\n          'anyOf': [\n          ],\n          'allOf': [\n              CreatePayoutRequest,\n              PayoutAllOf,\n          ],\n          'oneOf': [\n          ],\n        }\n",
    "uncovered_lines": [
      94,
      95,
      109,
      110,
      130,
      207,
      208,
      209,
      210,
      211,
      213,
      215,
      216,
      217,
      218,
      219,
      220,
      222,
      231,
      232,
      233,
      234,
      235,
      236,
      238,
      245,
      247,
      248,
      249,
      250,
      252,
      253,
      258,
      259,
      261,
      327,
      328,
      329,
      330,
      331,
      333,
      334,
      335,
      336,
      337,
      338,
      340,
      349,
      350,
      351,
      352,
      353,
      354,
      356,
      363,
      365,
      366,
      367,
      368,
      370,
      371,
      376,
      377,
      378,
      379,
      391,
      392
    ]
  },
  {
    "file_path": "xendit/payout/model/payout_all_of.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass PayoutAllOf(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('status',): {\n            'SUCCEEDED': \"SUCCEEDED\",\n            'FAILED': \"FAILED\",\n            'ACCEPTED': \"ACCEPTED\",\n            'REQUESTED': \"REQUESTED\",\n            'LOCKED': \"LOCKED\",\n            'CANCELLED': \"CANCELLED\",\n            'REVERSED': \"REVERSED\",\n        },\n        ('failure_code',): {\n            'INSUFFICIENT_BALANCE': \"INSUFFICIENT_BALANCE\",\n            'REJECTED_BY_CHANNEL': \"REJECTED_BY_CHANNEL\",\n            'TEMPORARY_TRANSFER_ERROR': \"TEMPORARY_TRANSFER_ERROR\",\n            'INVALID_DESTINATION': \"INVALID_DESTINATION\",\n            'TRANSFER_ERROR': \"TRANSFER_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'id': (str,),  # noqa: E501\n            'created': (datetime,),  # noqa: E501\n            'updated': (datetime,),  # noqa: E501\n            'business_id': (str,),  # noqa: E501\n            'status': (str,),  # noqa: E501\n            'failure_code': (str, none_type),  # noqa: E501\n            'estimated_arrival_time': (datetime, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'id': 'id',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'business_id': 'business_id',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'failure_code': 'failure_code',  # noqa: E501\n        'estimated_arrival_time': 'estimated_arrival_time',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, id, created, updated, business_id, status, *args, **kwargs):  # noqa: E501\n        \"\"\"PayoutAllOf - a model defined in OpenAPI\n\n        Args:\n            id (str): Xendit-generated unique identifier for each payout\n            created (datetime): The time payout was created on Xendit's system, in ISO 8601 format\n            updated (datetime): The time payout was last updated on Xendit's system, in ISO 8601 format\n            business_id (str): Xendit Business ID\n            status (str): Status of payout\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            failure_code (str): If the Payout failed, we include a failure code for more details on the failure.. [optional]  # noqa: E501\n            estimated_arrival_time (datetime): Our estimated time on to when your payout is reflected to the destination account. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.created = created\n        self.updated = updated\n        self.business_id = business_id\n        self.status = status\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        id: str,\n        created: datetime,\n        updated: datetime,\n        business_id: str,\n        status: str,\n        failure_code: str | None = None,\n        estimated_arrival_time: datetime | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"PayoutAllOf - a model defined in OpenAPI\n\n        Args:\n            id (str): Xendit-generated unique identifier for each payout\n            created (datetime): The time payout was created on Xendit's system, in ISO 8601 format\n            updated (datetime): The time payout was last updated on Xendit's system, in ISO 8601 format\n            business_id (str): Xendit Business ID\n            status (str): Status of payout\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            failure_code (str): If the Payout failed, we include a failure code for more details on the failure.. [optional]  # noqa: E501\n            estimated_arrival_time (datetime): Our estimated time on to when your payout is reflected to the destination account. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.created = created\n        self.updated = updated\n        self.business_id = business_id\n        self.status = status\n        if failure_code is not None:\n            self.failure_code = failure_code\n        if estimated_arrival_time is not None:\n            self.estimated_arrival_time = estimated_arrival_time\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      83,
      97,
      109,
      174,
      175,
      176,
      177,
      178,
      180,
      182,
      183,
      184,
      185,
      186,
      187,
      189,
      198,
      199,
      200,
      201,
      202,
      203,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      216,
      217,
      218,
      285,
      286,
      287,
      288,
      289,
      291,
      292,
      293,
      294,
      295,
      296,
      298,
      307,
      308,
      309,
      310,
      311,
      312,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      322,
      323,
      324,
      329,
      330,
      331,
      332
    ]
  },
  {
    "file_path": "xendit/payout/model/receipt_notification.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.0.0\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass ReceiptNotification(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'email_to': ([str], none_type, none_type),  # noqa: E501\n            'email_cc': ([str], none_type, none_type),  # noqa: E501\n            'email_bcc': ([str], none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'email_to': 'email_to',  # noqa: E501\n        'email_cc': 'email_cc',  # noqa: E501\n        'email_bcc': 'email_bcc',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"ReceiptNotification - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            email_to ([str], none_type): Valid email address to send the payout receipt. [optional]  # noqa: E501\n            email_cc ([str], none_type): Valid email address to cc the payout receipt. [optional]  # noqa: E501\n            email_bcc ([str], none_type): Valid email address to bcc the payout receipt. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        email_to: list | None = None,\n        email_cc: list | None = None,\n        email_bcc: list | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"ReceiptNotification - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            email_to ([str], none_type): Valid email address to send the payout receipt. [optional]  # noqa: E501\n            email_cc ([str], none_type): Valid email address to cc the payout receipt. [optional]  # noqa: E501\n            email_bcc ([str], none_type): Valid email address to bcc the payout receipt. [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if email_to is not None:\n            self.email_to = email_to\n        if email_cc is not None:\n            self.email_cc = email_cc\n        if email_bcc is not None:\n            self.email_bcc = email_bcc\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      89,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      181,
      182,
      183,
      240,
      241,
      242,
      243,
      244,
      246,
      247,
      248,
      249,
      250,
      251,
      253,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      270,
      271,
      272,
      273,
      274,
      275,
      276,
      281,
      282,
      283,
      284
    ]
  },
  {
    "file_path": "xendit/refund/refund_api.py",
    "code": "\"\"\"\n    Refund Service\n\n    This API is used for the unified refund service  # noqa: E501\n\n    The version of the OpenAPI document: 1.3.4\n\"\"\"\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\n\nfrom xendit.api_client import ApiClient, Endpoint as _Endpoint\nfrom xendit.model_utils import (  # noqa: F401\n    check_allowed_values,\n    check_validations,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_and_convert_types\n)\nfrom typing import Optional, List # noqa: F401\n\nfrom xendit.refund.model import *  # noqa: F401,E501\n\nclass RefundApi(object):\n    \"\"\"NOTE: This class is auto generated by the OpenAPI Generator.\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None):\n        if api_client is None:\n            api_client = ApiClient()\n        self.api_client = api_client\n        self.create_refund_endpoint = _Endpoint(\n            settings={\n                'response_type': (Refund,),\n                'auth': [],\n                'endpoint_path': '/refunds',\n                'operation_id': 'create_refund',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'idempotency_key',\n                    'for_user_id',\n                    'create_refund',\n                ],\n                'required': [],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'idempotency_key':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                    'create_refund':\n                        (CreateRefund,),\n                },\n                'attribute_map': {\n                    'idempotency_key': 'idempotency-key',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'idempotency_key': 'header',\n                    'for_user_id': 'header',\n                    'create_refund': 'body',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [\n                    'application/json'\n                ]\n            },\n            api_client=api_client\n        )\n        self.get_refund_endpoint = _Endpoint(\n            settings={\n                'response_type': (Refund,),\n                'auth': [],\n                'endpoint_path': '/refunds/{refundID}',\n                'operation_id': 'get_refund',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'refund_id',\n                    'idempotency_key',\n                    'for_user_id',\n                ],\n                'required': [\n                    'refund_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'refund_id':\n                        (str,),\n                    'idempotency_key':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'refund_id': 'refundID',\n                    'idempotency_key': 'idempotency-key',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'refund_id': 'path',\n                    'idempotency_key': 'header',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.get_all_refunds_endpoint = _Endpoint(\n            settings={\n                'response_type': (RefundList,),\n                'auth': [],\n                'endpoint_path': '/refunds',\n                'operation_id': 'get_all_refunds',\n                'http_method': 'GET',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'for_user_id',\n                    'payment_request_id',\n                    'invoice_id',\n                    'payment_method_type',\n                    'channel_code',\n                    'limit',\n                    'after_id',\n                    'before_id',\n                ],\n                'required': [],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'for_user_id':\n                        (str,),\n                    'payment_request_id':\n                        (str,),\n                    'invoice_id':\n                        (str,),\n                    'payment_method_type':\n                        (str,),\n                    'channel_code':\n                        (str,),\n                    'limit':\n                        (float,),\n                    'after_id':\n                        (str,),\n                    'before_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'for_user_id': 'for-user-id',\n                    'payment_request_id': 'payment_request_id',\n                    'invoice_id': 'invoice_id',\n                    'payment_method_type': 'payment_method_type',\n                    'channel_code': 'channel_code',\n                    'limit': 'limit',\n                    'after_id': 'after_id',\n                    'before_id': 'before_id',\n                },\n                'location_map': {\n                    'for_user_id': 'header',\n                    'payment_request_id': 'query',\n                    'invoice_id': 'query',\n                    'payment_method_type': 'query',\n                    'channel_code': 'query',\n                    'limit': 'query',\n                    'after_id': 'query',\n                    'before_id': 'query',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n        self.cancel_refund_endpoint = _Endpoint(\n            settings={\n                'response_type': (Refund,),\n                'auth': [],\n                'endpoint_path': '/refunds/{refundID}/cancel',\n                'operation_id': 'cancel_refund',\n                'http_method': 'POST',\n                'servers': None,\n            },\n            params_map={\n                'all': [\n                    'refund_id',\n                    'idempotency_key',\n                    'for_user_id',\n                ],\n                'required': [\n                    'refund_id',\n                ],\n                'nullable': [\n                ],\n                'enum': [\n                ],\n                'validation': [\n                ]\n            },\n            root_map={\n                'validations': {\n                },\n                'allowed_values': {\n                },\n                'openapi_types': {\n                    'refund_id':\n                        (str,),\n                    'idempotency_key':\n                        (str,),\n                    'for_user_id':\n                        (str,),\n                },\n                'attribute_map': {\n                    'refund_id': 'refundID',\n                    'idempotency_key': 'idempotency-key',\n                    'for_user_id': 'for-user-id',\n                },\n                'location_map': {\n                    'refund_id': 'path',\n                    'idempotency_key': 'header',\n                    'for_user_id': 'header',\n                },\n                'collection_format_map': {\n                }\n            },\n            headers_map={\n                'accept': [\n                    'application/json'\n                ],\n                'content_type': [],\n            },\n            api_client=api_client\n        )\n\n    def create_refund(\n        self,\n        idempotency_key: Optional[str] = None,\n        for_user_id: Optional[str] = None,\n        create_refund: Optional[CreateRefund] = None,\n        **kwargs\n    ) -> Refund:\n        \"\"\"create_refund  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.create_refund(idempotency_key, for_user_id, create_refund, async_req=True)\n        >>> result = thread.get()\n\n\n        Keyword Args:\n            idempotency_key (str): [optional]\n            for_user_id (str): [optional]\n            create_refund (CreateRefund): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            Refund\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        if idempotency_key is not None:\n            kwargs['idempotency_key'] = idempotency_key\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if create_refund is not None:\n            kwargs['create_refund'] = create_refund\n        return self.create_refund_endpoint.call_with_http_info(**kwargs)\n\n    def get_refund(\n        self,\n        refund_id: str,\n        idempotency_key: Optional[str] = None,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> Refund:\n        \"\"\"get_refund  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_refund(refund_id, idempotency_key, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            refund_id (str):\n\n        Keyword Args:\n            idempotency_key (str): [optional]\n            for_user_id (str): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            Refund\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['refund_id'] = refund_id\n        if idempotency_key is not None:\n            kwargs['idempotency_key'] = idempotency_key\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.get_refund_endpoint.call_with_http_info(**kwargs)\n\n    def get_all_refunds(\n        self,\n        for_user_id: Optional[str] = None,\n        payment_request_id: Optional[str] = None,\n        invoice_id: Optional[str] = None,\n        payment_method_type: Optional[str] = None,\n        channel_code: Optional[str] = None,\n        limit: Optional[float] = None,\n        after_id: Optional[str] = None,\n        before_id: Optional[str] = None,\n        **kwargs\n    ) -> RefundList:\n        \"\"\"get_all_refunds  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.get_all_refunds(for_user_id, payment_request_id, invoice_id, payment_method_type, channel_code, limit, after_id, before_id, async_req=True)\n        >>> result = thread.get()\n\n\n        Keyword Args:\n            for_user_id (str): [optional]\n            payment_request_id (str): [optional]\n            invoice_id (str): [optional]\n            payment_method_type (str): [optional]\n            channel_code (str): [optional]\n            limit (float): [optional]\n            after_id (str): [optional]\n            before_id (str): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            RefundList\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        if payment_request_id is not None:\n            kwargs['payment_request_id'] = payment_request_id\n        if invoice_id is not None:\n            kwargs['invoice_id'] = invoice_id\n        if payment_method_type is not None:\n            kwargs['payment_method_type'] = payment_method_type\n        if channel_code is not None:\n            kwargs['channel_code'] = channel_code\n        if limit is not None:\n            kwargs['limit'] = limit\n        if after_id is not None:\n            kwargs['after_id'] = after_id\n        if before_id is not None:\n            kwargs['before_id'] = before_id\n        return self.get_all_refunds_endpoint.call_with_http_info(**kwargs)\n\n    def cancel_refund(\n        self,\n        refund_id: str,\n        idempotency_key: Optional[str] = None,\n        for_user_id: Optional[str] = None,\n        **kwargs\n    ) -> Refund:\n        \"\"\"cancel_refund  # noqa: E501\n\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n\n        >>> thread = api.cancel_refund(refund_id, idempotency_key, for_user_id, async_req=True)\n        >>> result = thread.get()\n\n        Args:\n            refund_id (str):\n\n        Keyword Args:\n            idempotency_key (str): [optional]\n            for_user_id (str): [optional]\n            _return_http_data_only (bool): response data without head status\n                code and headers. Default is True.\n            _preload_content (bool): if False, the urllib3.HTTPResponse object\n                will be returned without reading/decoding response data.\n                Default is True.\n            _request_timeout (int/float/tuple): timeout setting for this request. If\n                one number provided, it will be total request timeout. It can also\n                be a pair (tuple) of (connection, read) timeouts.\n                Default is None.\n            _check_input_type (bool): specifies if type checking\n                should be done one the data sent to the server.\n                Default is True.\n            _check_return_type (bool): specifies if type checking\n                should be done one the data received from the server.\n                Default is True.\n            _spec_property_naming (bool): True if the variable names in the input data\n                are serialized names, as specified in the OpenAPI document.\n                False if the variable names in the input data\n                are pythonic names, e.g. snake case (default)\n            _content_type (str/None): force body content-type.\n                Default is None and content-type will be predicted by allowed\n                content-types and body.\n            _host_index (int/None): specifies the index of the server\n                that we want to use.\n                Default is read from the configuration.\n            _request_auths (list): set to override the auth_settings for an a single\n                request; this effectively ignores the authentication\n                in the spec for a single request.\n                Default is None\n            async_req (bool): execute request asynchronously\n\n        Returns:\n            Refund\n                If the method is called asynchronously, returns the request\n                thread.\n        \"\"\"\n        kwargs['async_req'] = kwargs.get(\n            'async_req', False\n        )\n        kwargs['_return_http_data_only'] = kwargs.get(\n            '_return_http_data_only', True\n        )\n        kwargs['_preload_content'] = kwargs.get(\n            '_preload_content', True\n        )\n        kwargs['_request_timeout'] = kwargs.get(\n            '_request_timeout', None\n        )\n        kwargs['_check_input_type'] = kwargs.get(\n            '_check_input_type', True\n        )\n        kwargs['_check_return_type'] = kwargs.get(\n            '_check_return_type', True\n        )\n        kwargs['_spec_property_naming'] = kwargs.get(\n            '_spec_property_naming', False\n        )\n        kwargs['_content_type'] = kwargs.get(\n            '_content_type')\n        kwargs['_host_index'] = kwargs.get('_host_index')\n        kwargs['_request_auths'] = kwargs.get('_request_auths', None)\n        kwargs['refund_id'] = refund_id\n        if idempotency_key is not None:\n            kwargs['idempotency_key'] = idempotency_key\n        if for_user_id is not None:\n            kwargs['for_user_id'] = for_user_id\n        return self.cancel_refund_endpoint.call_with_http_info(**kwargs)\n\n",
    "uncovered_lines": [
      32,
      33,
      34,
      35,
      93,
      152,
      234,
      350,
      353,
      356,
      359,
      362,
      365,
      368,
      371,
      373,
      374,
      375,
      376,
      377,
      378,
      379,
      380,
      381,
      440,
      443,
      446,
      449,
      452,
      455,
      458,
      461,
      463,
      464,
      465,
      466,
      467,
      468,
      469,
      470,
      538,
      541,
      544,
      547,
      550,
      553,
      556,
      559,
      561,
      562,
      563,
      564,
      565,
      566,
      567,
      568,
      569,
      570,
      571,
      572,
      573,
      574,
      575,
      576,
      577,
      578,
      579,
      638,
      641,
      644,
      647,
      650,
      653,
      656,
      659,
      661,
      662,
      663,
      664,
      665,
      666,
      667,
      668
    ]
  },
  {
    "file_path": "xendit/refund/model/create_refund400_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.3.4\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CreateRefund400Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'API_VALIDATION_ERROR': \"API_VALIDATION_ERROR\",\n            'INELIGIBLE_TRANSACTION': \"INELIGIBLE_TRANSACTION\",\n            'INSUFFICIENT_BALANCE': \"INSUFFICIENT_BALANCE\",\n            'MAXIMUM_REFUND_AMOUNT_REACHED': \"MAXIMUM_REFUND_AMOUNT_REACHED\",\n            'PARTIAL_REFUND_NOT_SUPPORTED': \"PARTIAL_REFUND_NOT_SUPPORTED\",\n            'REFUND_NOT_SUPPORTED': \"REFUND_NOT_SUPPORTED\",\n            'TRANSACTION_NOT_FOUND': \"TRANSACTION_NOT_FOUND\",\n            'REFUND_IN_PROGRESS': \"REFUND_IN_PROGRESS\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CreateRefund400Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CreateRefund400Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      77,
      91,
      98,
      151,
      152,
      153,
      154,
      155,
      157,
      159,
      160,
      161,
      162,
      163,
      164,
      166,
      175,
      176,
      177,
      178,
      179,
      180,
      182,
      183,
      188,
      189,
      190,
      245,
      246,
      247,
      248,
      249,
      251,
      252,
      253,
      254,
      255,
      256,
      258,
      267,
      268,
      269,
      270,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      279,
      284,
      285,
      286,
      287
    ]
  },
  {
    "file_path": "xendit/refund/model/create_refund403_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.3.4\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CreateRefund403Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'UNAUTHORIZED': \"UNAUTHORIZED\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CreateRefund403Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional] if omitted the server will use the default value of \"UNAUTHORIZED\"  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        message: str | None = None,\n        error_code: str | None = \"UNAUTHORIZED\",\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CreateRefund403Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional] if omitted the server will use the default value of \"UNAUTHORIZED\"  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      91,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      181,
      182,
      183,
      238,
      239,
      240,
      241,
      242,
      244,
      245,
      246,
      247,
      248,
      249,
      251,
      260,
      261,
      262,
      263,
      264,
      265,
      267,
      268,
      269,
      270,
      271,
      272,
      277,
      278,
      279,
      280
    ]
  },
  {
    "file_path": "xendit/refund/model/create_refund404_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.3.4\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CreateRefund404Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'DATA_NOT_FOUND': \"DATA_NOT_FOUND\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CreateRefund404Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional] if omitted the server will use the default value of \"DATA_NOT_FOUND\"  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        message: str | None = None,\n        error_code: str | None = \"DATA_NOT_FOUND\",\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CreateRefund404Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional] if omitted the server will use the default value of \"DATA_NOT_FOUND\"  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      70,
      84,
      91,
      144,
      145,
      146,
      147,
      148,
      150,
      152,
      153,
      154,
      155,
      156,
      157,
      159,
      168,
      169,
      170,
      171,
      172,
      173,
      175,
      176,
      181,
      182,
      183,
      238,
      239,
      240,
      241,
      242,
      244,
      245,
      246,
      247,
      248,
      249,
      251,
      260,
      261,
      262,
      263,
      264,
      265,
      267,
      268,
      269,
      270,
      271,
      272,
      277,
      278,
      279,
      280
    ]
  },
  {
    "file_path": "xendit/refund/model/create_refund409_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.3.4\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CreateRefund409Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'DUPLICATE_ERROR': \"DUPLICATE_ERROR\",\n            'IDEMPOTENCY_ERROR': \"IDEMPOTENCY_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CreateRefund409Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CreateRefund409Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      85,
      92,
      145,
      146,
      147,
      148,
      149,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      160,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/refund/model/create_refund503_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.3.4\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CreateRefund503Response(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('error_code',): {\n            'CHANNEL_UNAVAILABLE': \"CHANNEL_UNAVAILABLE\",\n            'OTP_DELIVERY_ERROR': \"OTP_DELIVERY_ERROR\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CreateRefund503Response - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CreateRefund503Response - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      71,
      85,
      92,
      145,
      146,
      147,
      148,
      149,
      151,
      153,
      154,
      155,
      156,
      157,
      158,
      160,
      169,
      170,
      171,
      172,
      173,
      174,
      176,
      177,
      182,
      183,
      184,
      239,
      240,
      241,
      242,
      243,
      245,
      246,
      247,
      248,
      249,
      250,
      252,
      261,
      262,
      263,
      264,
      265,
      266,
      268,
      269,
      270,
      271,
      272,
      273,
      278,
      279,
      280,
      281
    ]
  },
  {
    "file_path": "xendit/refund/model/create_refund.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.3.4\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass CreateRefund(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n        ('reason',): {\n            'FRAUDULENT': \"FRAUDULENT\",\n            'DUPLICATE': \"DUPLICATE\",\n            'REQUESTED_BY_CUSTOMER': \"REQUESTED_BY_CUSTOMER\",\n            'CANCELLATION': \"CANCELLATION\",\n            'OTHERS': \"OTHERS\",\n        },\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'payment_request_id': (str, none_type),  # noqa: E501\n            'invoice_id': (str, none_type),  # noqa: E501\n            'reference_id': (str, none_type),  # noqa: E501\n            'amount': (float, none_type),  # noqa: E501\n            'currency': (str, none_type),  # noqa: E501\n            'reason': (str, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'payment_request_id': 'payment_request_id',  # noqa: E501\n        'invoice_id': 'invoice_id',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'reason': 'reason',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"CreateRefund - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_request_id (str): [optional]  # noqa: E501\n            invoice_id (str): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            amount (float): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            reason (str): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        payment_request_id: str | None = None,\n        invoice_id: str | None = None,\n        reference_id: str | None = None,\n        amount: float | None = None,\n        currency: str | None = None,\n        reason: str | None = None,\n        metadata: dict | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"CreateRefund - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            payment_request_id (str): [optional]  # noqa: E501\n            invoice_id (str): [optional]  # noqa: E501\n            reference_id (str): [optional]  # noqa: E501\n            amount (float): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            reason (str): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if payment_request_id is not None:\n            self.payment_request_id = payment_request_id\n        if invoice_id is not None:\n            self.invoice_id = invoice_id\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if amount is not None:\n            self.amount = amount\n        if currency is not None:\n            self.currency = currency\n        if reason is not None:\n            self.reason = reason\n        if metadata is not None:\n            self.metadata = metadata\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      74,
      88,
      100,
      163,
      164,
      165,
      166,
      167,
      169,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      187,
      188,
      189,
      190,
      191,
      192,
      194,
      195,
      200,
      201,
      202,
      267,
      268,
      269,
      270,
      271,
      273,
      274,
      275,
      276,
      277,
      278,
      280,
      289,
      290,
      291,
      292,
      293,
      294,
      296,
      297,
      298,
      299,
      300,
      301,
      302,
      303,
      304,
      305,
      306,
      307,
      308,
      309,
      310,
      311,
      316,
      317,
      318,
      319
    ]
  },
  {
    "file_path": "xendit/refund/model/get_all_refunds_default_response.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.3.4\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass GetAllRefundsDefaultResponse(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'error_code': (str, none_type),  # noqa: E501\n            'message': (str, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'error_code': 'error_code',  # noqa: E501\n        'message': 'message',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"GetAllRefundsDefaultResponse - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        error_code: str | None = None,\n        message: str | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"GetAllRefundsDefaultResponse - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            error_code (str): [optional]  # noqa: E501\n            message (str): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if error_code is not None:\n            self.error_code = error_code\n        if message is not None:\n            self.message = message\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      88,
      141,
      142,
      143,
      144,
      145,
      147,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      165,
      166,
      167,
      168,
      169,
      170,
      172,
      173,
      178,
      179,
      180,
      235,
      236,
      237,
      238,
      239,
      241,
      242,
      243,
      244,
      245,
      246,
      248,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      268,
      269,
      274,
      275,
      276,
      277
    ]
  },
  {
    "file_path": "xendit/refund/model/refund.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.3.4\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass Refund(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'id': (str, none_type),  # noqa: E501\n            'payment_request_id': (str, none_type),  # noqa: E501\n            'amount': (float, none_type),  # noqa: E501\n            'channel_code': (str, none_type),  # noqa: E501\n            'country': (str, none_type),  # noqa: E501\n            'currency': (str, none_type),  # noqa: E501\n            'reference_id': (str, none_type, none_type),  # noqa: E501\n            'failure_code': (str, none_type, none_type),  # noqa: E501\n            'refund_fee_amount': (float, none_type, none_type),  # noqa: E501\n            'created': (str, none_type),  # noqa: E501\n            'updated': (str, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'id': 'id',  # noqa: E501\n        'payment_request_id': 'payment_request_id',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'channel_code': 'channel_code',  # noqa: E501\n        'country': 'country',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'failure_code': 'failure_code',  # noqa: E501\n        'refund_fee_amount': 'refund_fee_amount',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501\n        \"\"\"Refund - a model defined in OpenAPI\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            id (str): [optional]  # noqa: E501\n            payment_request_id (str): [optional]  # noqa: E501\n            amount (float): [optional]  # noqa: E501\n            channel_code (str): [optional]  # noqa: E501\n            country (str): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            reference_id (str, none_type): [optional]  # noqa: E501\n            failure_code (str, none_type): [optional]  # noqa: E501\n            refund_fee_amount (float, none_type): [optional]  # noqa: E501\n            created (str): [optional]  # noqa: E501\n            updated (str): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        id: str | None = None,\n        payment_request_id: str | None = None,\n        amount: float | None = None,\n        channel_code: str | None = None,\n        country: str | None = None,\n        currency: str | None = None,\n        reference_id: str | None = None,\n        failure_code: str | None = None,\n        refund_fee_amount: float | None = None,\n        created: str | None = None,\n        updated: str | None = None,\n        metadata: dict | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"Refund - a model defined in OpenAPI\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            id (str): [optional]  # noqa: E501\n            payment_request_id (str): [optional]  # noqa: E501\n            amount (float): [optional]  # noqa: E501\n            channel_code (str): [optional]  # noqa: E501\n            country (str): [optional]  # noqa: E501\n            currency (str): [optional]  # noqa: E501\n            reference_id (str, none_type): [optional]  # noqa: E501\n            failure_code (str, none_type): [optional]  # noqa: E501\n            refund_fee_amount (float, none_type): [optional]  # noqa: E501\n            created (str): [optional]  # noqa: E501\n            updated (str): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        if id is not None:\n            self.id = id\n        if payment_request_id is not None:\n            self.payment_request_id = payment_request_id\n        if amount is not None:\n            self.amount = amount\n        if channel_code is not None:\n            self.channel_code = channel_code\n        if country is not None:\n            self.country = country\n        if currency is not None:\n            self.currency = currency\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if failure_code is not None:\n            self.failure_code = failure_code\n        if refund_fee_amount is not None:\n            self.refund_fee_amount = refund_fee_amount\n        if created is not None:\n            self.created = created\n        if updated is not None:\n            self.updated = updated\n        if metadata is not None:\n            self.metadata = metadata\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      98,
      171,
      172,
      173,
      174,
      175,
      177,
      179,
      180,
      181,
      182,
      183,
      184,
      186,
      195,
      196,
      197,
      198,
      199,
      200,
      202,
      203,
      208,
      209,
      210,
      285,
      286,
      287,
      288,
      289,
      291,
      292,
      293,
      294,
      295,
      296,
      298,
      307,
      308,
      309,
      310,
      311,
      312,
      314,
      315,
      316,
      317,
      318,
      319,
      320,
      321,
      322,
      323,
      324,
      325,
      326,
      327,
      328,
      329,
      330,
      331,
      332,
      333,
      334,
      335,
      336,
      337,
      338,
      339,
      344,
      345,
      346,
      347
    ]
  },
  {
    "file_path": "xendit/refund/model/refund_callback.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.3.4\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.refund.model.refund_callback_data import RefundCallbackData\nglobals()['RefundCallbackData'] = RefundCallbackData\n\ndef lazy_import():\n    pass\n\nclass RefundCallback(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'event': (str,),  # noqa: E501\n            'business_id': (str,),  # noqa: E501\n            'created': (str,),  # noqa: E501\n            'data': (RefundCallbackData, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'event': 'event',  # noqa: E501\n        'business_id': 'business_id',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'data': 'data',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, event, business_id, created, *args, **kwargs):  # noqa: E501\n        \"\"\"RefundCallback - a model defined in OpenAPI\n\n        Args:\n            event (str): Identifies the event that triggered a notification to the merchant\n            business_id (str): business_id\n            created (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            data (RefundCallbackData): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.event = event\n        self.business_id = business_id\n        self.created = created\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        event: str,\n        business_id: str,\n        created: str,\n        data: RefundCallbackData | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"RefundCallback - a model defined in OpenAPI\n\n        Args:\n            event (str): Identifies the event that triggered a notification to the merchant\n            business_id (str): business_id\n            created (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            data (RefundCallbackData): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.event = event\n        self.business_id = business_id\n        self.created = created\n        if data is not None:\n            self.data = data\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      94,
      153,
      154,
      155,
      156,
      157,
      159,
      161,
      162,
      163,
      164,
      165,
      166,
      168,
      177,
      178,
      179,
      180,
      181,
      182,
      184,
      185,
      186,
      187,
      188,
      193,
      194,
      195,
      256,
      257,
      258,
      259,
      260,
      262,
      263,
      264,
      265,
      266,
      267,
      269,
      278,
      279,
      280,
      281,
      282,
      283,
      285,
      286,
      287,
      288,
      289,
      290,
      291,
      296,
      297,
      298,
      299
    ]
  },
  {
    "file_path": "xendit/refund/model/refund_callback_data.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.3.4\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\n\ndef lazy_import():\n    pass\n\nclass RefundCallbackData(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        return {\n            'id': (str,),  # noqa: E501\n            'payment_id': (str,),  # noqa: E501\n            'payment_method_type': (str,),  # noqa: E501\n            'amount': (float,),  # noqa: E501\n            'channel_code': (str,),  # noqa: E501\n            'status': (str,),  # noqa: E501\n            'reason': (str,),  # noqa: E501\n            'country': (str,),  # noqa: E501\n            'currency': (str,),  # noqa: E501\n            'created': (str,),  # noqa: E501\n            'updated': (str,),  # noqa: E501\n            'invoice_id': (str, none_type, none_type),  # noqa: E501\n            'reference_id': (str, none_type, none_type),  # noqa: E501\n            'failure_code': (str, none_type, none_type),  # noqa: E501\n            'refund_fee_amount': (float, none_type, none_type),  # noqa: E501\n            'metadata': ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'id': 'id',  # noqa: E501\n        'payment_id': 'payment_id',  # noqa: E501\n        'payment_method_type': 'payment_method_type',  # noqa: E501\n        'amount': 'amount',  # noqa: E501\n        'channel_code': 'channel_code',  # noqa: E501\n        'status': 'status',  # noqa: E501\n        'reason': 'reason',  # noqa: E501\n        'country': 'country',  # noqa: E501\n        'currency': 'currency',  # noqa: E501\n        'created': 'created',  # noqa: E501\n        'updated': 'updated',  # noqa: E501\n        'invoice_id': 'invoice_id',  # noqa: E501\n        'reference_id': 'reference_id',  # noqa: E501\n        'failure_code': 'failure_code',  # noqa: E501\n        'refund_fee_amount': 'refund_fee_amount',  # noqa: E501\n        'metadata': 'metadata',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, id, payment_id, payment_method_type, amount, channel_code, status, reason, country, currency, created, updated, *args, **kwargs):  # noqa: E501\n        \"\"\"RefundCallbackData - a model defined in OpenAPI\n\n        Args:\n            id (str):\n            payment_id (str):\n            payment_method_type (str):\n            amount (float):\n            channel_code (str):\n            status (str):\n            reason (str):\n            country (str):\n            currency (str):\n            created (str):\n            updated (str):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            invoice_id (str, none_type): [optional]  # noqa: E501\n            reference_id (str, none_type): [optional]  # noqa: E501\n            failure_code (str, none_type): [optional]  # noqa: E501\n            refund_fee_amount (float, none_type): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.payment_id = payment_id\n        self.payment_method_type = payment_method_type\n        self.amount = amount\n        self.channel_code = channel_code\n        self.status = status\n        self.reason = reason\n        self.country = country\n        self.currency = currency\n        self.created = created\n        self.updated = updated\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        id: str,\n        payment_id: str,\n        payment_method_type: str,\n        amount: float,\n        channel_code: str,\n        status: str,\n        reason: str,\n        country: str,\n        currency: str,\n        created: str,\n        updated: str,\n        invoice_id: str | None = None,\n        reference_id: str | None = None,\n        failure_code: str | None = None,\n        refund_fee_amount: float | None = None,\n        metadata: dict | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"RefundCallbackData - a model defined in OpenAPI\n\n        Args:\n            id (str):\n            payment_id (str):\n            payment_method_type (str):\n            amount (float):\n            channel_code (str):\n            status (str):\n            reason (str):\n            country (str):\n            currency (str):\n            created (str):\n            updated (str):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            invoice_id (str, none_type): [optional]  # noqa: E501\n            reference_id (str, none_type): [optional]  # noqa: E501\n            failure_code (str, none_type): [optional]  # noqa: E501\n            refund_fee_amount (float, none_type): [optional]  # noqa: E501\n            metadata ({str: (bool, date, datetime, dict, float, int, list, str, none_type)}, none_type): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.id = id\n        self.payment_id = payment_id\n        self.payment_method_type = payment_method_type\n        self.amount = amount\n        self.channel_code = channel_code\n        self.status = status\n        self.reason = reason\n        self.country = country\n        self.currency = currency\n        self.created = created\n        self.updated = updated\n        if invoice_id is not None:\n            self.invoice_id = invoice_id\n        if reference_id is not None:\n            self.reference_id = reference_id\n        if failure_code is not None:\n            self.failure_code = failure_code\n        if refund_fee_amount is not None:\n            self.refund_fee_amount = refund_fee_amount\n        if metadata is not None:\n            self.metadata = metadata\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      67,
      81,
      102,
      185,
      186,
      187,
      188,
      189,
      191,
      193,
      194,
      195,
      196,
      197,
      198,
      200,
      209,
      210,
      211,
      212,
      213,
      214,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      233,
      234,
      235,
      320,
      321,
      322,
      323,
      324,
      326,
      327,
      328,
      329,
      330,
      331,
      333,
      342,
      343,
      344,
      345,
      346,
      347,
      349,
      350,
      351,
      352,
      353,
      354,
      355,
      356,
      357,
      358,
      359,
      360,
      361,
      362,
      363,
      364,
      365,
      366,
      367,
      368,
      369,
      370,
      371,
      376,
      377,
      378,
      379
    ]
  },
  {
    "file_path": "xendit/refund/model/refund_list.py",
    "code": "\"\"\"\n    The version of the XENDIT API: 1.3.4\n\"\"\"\n\n\nimport re  # noqa: F401\nimport sys  # noqa: F401\nfrom typing import List  # noqa: F401\n\nfrom xendit.model_utils import (  # noqa: F401\n    ApiTypeError,\n    ModelComposed,\n    ModelNormal,\n    ModelSimple,\n    cached_property,\n    change_keys_js_to_python,\n    convert_js_args_to_python_args,\n    date,\n    datetime,\n    file_type,\n    none_type,\n    validate_get_composed_info,\n    OpenApiModel\n)\nfrom xendit.exceptions import ApiAttributeError\n\nfrom xendit.refund.model.refund import Refund\nglobals()['Refund'] = Refund\n\ndef lazy_import():\n    pass\n\nclass RefundList(ModelNormal):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n\n    Attributes:\n      allowed_values (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          with a capitalized key describing the allowed value and an allowed\n          value. These dicts store the allowed enum values.\n      attribute_map (dict): The key is attribute name\n          and the value is json key in definition.\n      discriminator_value_class_map (dict): A dict to go from the discriminator\n          variable value to the discriminator class name.\n      validations (dict): The key is the tuple path to the attribute\n          and the for var_name this is (var_name,). The value is a dict\n          that stores validations for max_length, min_length, max_items,\n          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,\n          inclusive_minimum, and regex.\n      additional_properties_type (tuple): A tuple of classes accepted\n          as additional properties values.\n    \"\"\"\n\n    allowed_values = {\n    }\n\n    validations = {\n    }\n\n    @cached_property\n    def additional_properties_type():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n        \"\"\"\n        lazy_import()\n        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501\n\n    _nullable = False\n\n    @cached_property\n    def openapi_types():\n        \"\"\"\n        This must be a method because a model may have properties that are\n        of type self, this must run after the class is loaded\n\n        Returns\n            openapi_types (dict): The key is attribute name\n                and the value is attribute type.\n        \"\"\"\n        lazy_import()\n        return {\n            'data': ([Refund],),  # noqa: E501\n            'has_more': (bool, none_type),  # noqa: E501\n        }\n\n    @cached_property\n    def discriminator():\n        return None\n\n\n    attribute_map = {\n        'data': 'data',  # noqa: E501\n        'has_more': 'has_more',  # noqa: E501\n    }\n\n    read_only_vars = {\n    }\n\n    _composed_schemas = {}\n\n    @classmethod\n    @convert_js_args_to_python_args\n    def _from_openapi_data(cls, data, *args, **kwargs):  # noqa: E501\n        \"\"\"RefundList - a model defined in OpenAPI\n\n        Args:\n            data ([Refund]):\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            has_more (bool): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', True)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        self = super(OpenApiModel, cls).__new__(cls)\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.data = data\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n        return self\n\n    required_properties = set([\n        '_data_store',\n        '_check_type',\n        '_spec_property_naming',\n        '_path_to_item',\n        '_configuration',\n        '_visited_composed_classes',\n    ])\n\n    @convert_js_args_to_python_args\n    def __init__(self,\n        data: list,\n        has_more: bool | None = None,\n        *args, **kwargs\n    ):  # noqa: E501\n        \"\"\"RefundList - a model defined in OpenAPI\n\n        Args:\n            data ([Refund]):\n\n\n        Keyword Args:\n            _check_type (bool): if True, values for parameters in openapi_types\n                                will be type checked and a TypeError will be\n                                raised if the wrong type is input.\n                                Defaults to True\n            _path_to_item (tuple/list): This is a list of keys or values to\n                                drill down to the model in received_data\n                                when deserializing a response\n            _spec_property_naming (bool): True if the variable names in the input data\n                                are serialized names, as specified in the OpenAPI document.\n                                False if the variable names in the input data\n                                are pythonic names, e.g. snake case (default)\n            _configuration (Configuration): the instance to use when\n                                deserializing a file_type parameter.\n                                If passed, type conversion is attempted\n                                If omitted no type conversion is done.\n            _visited_composed_classes (tuple): This stores a tuple of\n                                classes that we have traveled through so that\n                                if we see that class again we will not use its\n                                discriminator again.\n                                When traveling through a discriminator, the\n                                composed schema that is\n                                is traveled through is added to this set.\n                                For example if Animal has a discriminator\n                                petType and we pass in \"Dog\", and the class Dog\n                                allOf includes Animal, we move through Animal\n                                once using the discriminator, and pick Dog.\n                                Then in Dog, we will make an instance of the\n                                Animal class but this time we won't travel\n                                through its discriminator because we passed in\n                                _visited_composed_classes = (Animal,)\n            has_more (bool): [optional]  # noqa: E501\n        \"\"\"\n\n        _check_type = kwargs.pop('_check_type', True)\n        _spec_property_naming = kwargs.pop('_spec_property_naming', False)\n        _path_to_item = kwargs.pop('_path_to_item', ())\n        _configuration = kwargs.pop('_configuration', None)\n        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())\n\n        if args:\n            for arg in args:\n                if isinstance(arg, dict):\n                    kwargs.update(arg)\n                elif isinstance(arg, str):\n                    kwargs.update({\"value\": arg})\n                else:\n                    raise ApiTypeError(\n                        \"Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments.\" % (\n                            args,\n                            self.__class__.__name__,\n                        ),\n                        path_to_item=_path_to_item,\n                        valid_classes=(self.__class__,),\n                    )\n\n        self._data_store = {}\n        self._check_type = _check_type\n        self._spec_property_naming = _spec_property_naming\n        self._path_to_item = _path_to_item\n        self._configuration = _configuration\n        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)\n\n        self.data = data\n        if has_more is not None:\n            self.has_more = has_more\n        for var_name, var_value in kwargs.items():\n            if var_name not in self.attribute_map and \\\n                        self._configuration is not None and \\\n                        self._configuration.discard_unknown_keys and \\\n                        self.additional_properties_type is None:\n                # discard variable.\n                continue\n            setattr(self, var_name, var_value)\n            if var_name in self.read_only_vars:\n                raise ApiAttributeError(f\"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate \"\n                                     f\"class with read only attributes.\")\n",
    "uncovered_lines": [
      69,
      70,
      84,
      85,
      92,
      147,
      148,
      149,
      150,
      151,
      153,
      155,
      156,
      157,
      158,
      159,
      160,
      162,
      171,
      172,
      173,
      174,
      175,
      176,
      178,
      179,
      180,
      185,
      186,
      187,
      244,
      245,
      246,
      247,
      248,
      250,
      251,
      252,
      253,
      254,
      255,
      257,
      266,
      267,
      268,
      269,
      270,
      271,
      273,
      274,
      275,
      276,
      277,
      282,
      283,
      284,
      285
    ]
  }
]